[{"title":"在滚动列表中播放视频","date":"2022-03-01T15:35:00.000Z","path":"2022/03/01/Implementing-video-playback-in-a-scrolled list/","text":"原文链接 : Implementing video playback in a scrolled list (ListView &amp; RecyclerView) 原文作者 : Danylo Volokh 译文出自 : 开发技术前线 www.devtf.cn 本篇博文将会介绍如何实现在列表中播放视频，具体效果参见：Facebook，Instagram 或 Magiston： Facebook Magisto Instagram 博文内容基于此Github 项目：VideoPlayerManager. 博文中涉及的所有代码和范例都在该项目中，所以本篇博文不会详细讲解每一个细节。如果有人真的想知道实现的机制，最好是下载源码，结合 IDE 边看源码边阅读本文。不过就算你不结合源码，光看我在这里说的内容，也能理解的七七八八了。 两个问题为了实现这个功能，我们需要解决以下两个问题： 管理视频播放。在 Android 框架层中我们可以利用 MediaPlayer 和 SurfaceView 来播放视频，但这种实现方式有许多缺点。我们不能在列表中使用一般的 VideoView，因为 VideoView 是 SurfaceView 的子类，而 SurfaceView 不具有 UI 异步缓存。而这会导致我们无法在滚动时记录视频到底播放到哪个时间点。TextureView 具有 UI 异步缓存，但在 Android SDK 15 没有 VideoView 的实现方式是借助 TextureView 来完成的。因此，我们需要一个 TextureView 的子类与 MediaPlayer 协作完成视频播放的功能。当然了，MediaPlayer 中的所有方法（准备，开始，停止等等……）几乎都是调用与硬件交互的内核层代码。而硬件往往意味着复杂，如果我们需要完成的任何工作的耗时超过 16ms（一般都会），就会看到滞后的视频列表。这也是为什么需要在后台线程中调用它们的原因。 我们还需要知道滚动列表中的哪一个 View 要被激活（播放视频），所以我们还需要追踪用户的滚动行为并定义可见域最大的 View。 管理视频播放我们希望提供以下功能： 假设某个视频正在播放，此时用户滚动了列表使得列表中某个子项目的可见域大于正在播放视频的子项目的可见域，这样我们就需要停止正在播放的视频，并开始播放新的视频（可见域更大的子项目对应的视频）。 ##VideoPlayerView 我们要做的第一件事就是以 TextureView 为父类实现 VideoView。而且我们在滚动列表中不能使用系统的 VideoView，因为用户在视频播放的过程中滚动列表的话，视频渲染就会乱掉。 我把这部分工作分为几个部分： 创建继承于 TextureView 的 ScalableTextureView，它能够调整 SurfaceTexture（正在播放视频的表面结构中）而且提供了一些类似于 ImageView 缩放类型的选项。 123public enum ScaleType &#123; CENTER_CROP, TOP, BOTTOM, FILL&#125; 创建 ScalableTextureView 的子类 VideoPlayerView，它包含所有与 MediaPlayer 相关的功能。即，这是一个封装了 MediaPlayer 并提供与 VideoView 几近一致的 API 的自定义 View。VideoPlayerView 具有所有直接调用 MediaPlayer 的方法：setDataSource，prepare, start, stop, pause, reset, release。 ViedioPlayer 管理器及消息控制机制视频播放管理器与负责异步调用 MediaPlayer 方法的 MessageHandlerThread 协作。因为我们需要调用的方法，如：prepare(), start() 等等……与硬件直接相关，所以我们需要在一个独立的线程中完成这些调用。此外，当我们在 UI 线程中调用 MediaPlayer.reset() MediaPlayer 会发生一些奇怪的问题，使得该方法阻塞了将近 4 分钟！这也是我们不必须调用异步的 MediaPlayer.prepareAsync() 方法的原因，因为我们完全可以在另一个线程中调用 MediaPlayer.prepare() 方法，免得让这些奇怪的问题折腾自己。因此，我们将在一个独立的线程中异步完成所有任务。 在开始新的视频播放任务的事件流中，下面是一些与 MediaPlayer 相关的步骤： 停止前一个播放任务，通过调用 MediaPlayer.stop() 方法完成。 通过调用 MediaPlayer.reset 方法重置 MediaPlayer。之所以需要这样做是因为：在滚动列表中，View 可能会被重用，而我们想要释放所有的资源。 通过调用 MediaPlayer.release() 方法释放 MediaPlayer 占用的资源。 清除 MediaPlayer 的实例，当 View 执行新的播放任务时，创建新的 MediaPlayer 实例。 为新的可见域最大的 View 创建 MediaPlayer 实例。 调用 MediaPlayer.setDataSource(String url) 为新的 MediaPlayer 设置数据源。 调用 MediaPlayer.prepare() 方法而不是 MediaPlayer.prepareAsync()。 调用 MediaPlayer.start()。 等待播放开始。 以上所有行为都被包裹到 Message 中，交给一个独立的线程完成，例如这是一个 Stop 命令的 Message，它将调用 VideoPlayerView.stop()，实际上他调用的是 MediaPlayer.stop()。我们需要自定义 Message，因为我们可能需要设置当前状态，例如现在是正在停止，还是已经停止，或者是其他的状态……这有助于我们了解当前处理的 Message 是什么命令，如果我们需要用这个命令的话我们可以做什么，例如，开始一个新的播放任务。 1234567891011121314151617181920212223/** * This PlayerMessage calls &#123;@link MediaPlayer#stop()&#125; on the instance that is used inside &#123;@link VideoPlayerView&#125; */public class Stop extends PlayerMessage &#123; public Stop(VideoPlayerView videoView, VideoPlayerManagerCallback callback) &#123; super(videoView, callback); &#125; @Override protected void performAction(VideoPlayerView currentPlayer) &#123; currentPlayer.stop(); &#125; @Override protected PlayerMessageState stateBefore() &#123; return PlayerMessageState.STOPPING; &#125; @Override protected PlayerMessageState stateAfter() &#123; return PlayerMessageState.STOPPED; &#125;&#125; 如果我们需要开始一个新的播放任务，我们只需要调用 VideoPlayerManager 的一个方法，它就会添加下列 Message 到 MessagesHandlerThread 中： 12345678910111213141516// pause the queue processing and check current state// if current state is \"started\" then stop old playbackmPlayerHandler.addMessage(new Stop(mCurrentPlayer, this));mPlayerHandler.addMessage(new Reset(mCurrentPlayer, this));mPlayerHandler.addMessage(new Release(mCurrentPlayer, this));mPlayerHandler.addMessage(new ClearPlayerInstance(mCurrentPlayer, this));// set new video player viewmPlayerHandler.addMessage(new SetNewViewForPlayback(newVideoPlayerView, this));// start new playbackmPlayerHandler.addMessages(Arrays.asList( new CreateNewPlayerInstance(videoPlayerView, this), new SetAssetsDataSourceMessage(videoPlayerView, assetFileDescriptor, this), // I use local file for demo new Prepare(videoPlayerView, this), new Start(videoPlayerView, this)));// resume queue processing 这些 Message 都是异步处理的，因此我们能在任意时刻停止消息队列对消息的处理，并投递新的消息，例如： 当前一个影片处于准备状态（已经调用了 MediaPlayer.prepare() 方法，而且 MediaPlayer.start() 方法正在消息队列中等待被执行），此时用户滚动了列表，所以我们需要在一个新的 View 上开始新的播放任务。在这种情况下我们会： 停止正在执行的消息队列 移除所有等待执行的消息 投递 “Stop”, “Reset”, “Release”, “Clear Player instance” 这些消息给消息队列，它们将会在 Prepare 消息回调方法执行完成后立刻被执行。 投递 “Create new Media Player instance”, “Set Current Media Player”（将 MediaPlayer 对象绑定到当前需要播放视频的消息上），“Set data source”, “Prepare”, “Start”等消息。这样就会在新的 View 上播放相应的视频。 这样我们就能依照我们设想的那样执行播放任务：停止前一个播放任务，并开始新的播放任务。 下面是相关的依赖： 123dependencies &#123; compile 'com.github.danylovolokh:video-player-manager:0.2.0'&#125; 区分列表中可见域最大的 View——列表可见域判断工具第一个问题是控制视频的播放，第二个问题则是判断哪一个 View 可见域最大，并切换该 View 对应的视频为新的播放视频。下面是调用 ListItemsVisibilityCalculator 的实体，它的具体实现 SingleListViewItemActiveCalculator 会完成对应的工作。 在 Adapter 中被使用的 Model 类必须实现 ListItem 接口，以计算 List 中子项目的可见域： 1234567891011121314151617181920212223242526272829303132333435/** * A general interface for list items. * This interface is used by &#123;@link ListItemsVisibilityCalculator&#125; * * @author danylo.volokh */public interface ListItem &#123; /** * When this method is called, the implementation should provide a * visibility percents in range 0 - 100 % * @param view the view which visibility percent should be * calculated. * Note: visibility doesn't have to depend on the visibility of a * full view. * It might be calculated by calculating the visibility of any * inner View * * @return percents of visibility */ int getVisibilityPercents(View view); /** * When view visibility become bigger than \"current active\" view * visibility then the new view becomes active. * This method is called */ void setActive(View newActiveView, int newActiveViewPosition); /** * There might be a case when not only new view becomes active, * but also when no view is active. * When view should stop being active this method is called */ void deactivate(View currentView, int position);&#125; ListItemsVisibilityCalculator 将追踪滚动方向，并在运行时计算子项目的可见域。子项目的可见域依赖于列表中的任意一个咨询项目，即取决于你实现 getVisibilityPercents() 方法的方式： 123456789101112131415161718192021222324/** * This method calculates visibility percentage of currentView. * This method works correctly when currentView is smaller then it's enclosure. * @param currentView - view which visibility should be calculated * @return currentView visibility percents */@Overridepublic int getVisibilityPercents(View currentView) &#123; int percents = 100; currentView.getLocalVisibleRect(mCurrentViewRect); int height = currentView.getHeight(); if(viewIsPartiallyHiddenTop())&#123; // view is partially hidden behind the top edge percents = (height - mCurrentViewRect.top) * 100 / height; &#125; else if(viewIsPartiallyHiddenBottom(height))&#123; percents = mCurrentViewRect.bottom * 100 / height; &#125; return percents;&#125; 因此，每一个 View 都需要知道计算其可见域的细节。当发生滚动时，SingleListViewItemActiveCalculator 会要求每一个 View 计算其可见域大小，这也意味其开销之重。 当任意一个子项目的可见域大小超过了当前播放视频项目的可见域大小，就会调用 setActive 方法切换播放任务。 下面是与 Adapter 功能类似的的 ItemsPositionGetter 的抽象逻辑，它将建立 ListItemsVisibilityCalculator 与 ListView/RecyclerView 交互的桥梁。这样的话 ListItemsVisibilityCalculator 不需要了解它需要操作的 View 到底是 ListView 还是 RecyclerView。只需要完成它自己的工作，但仍需要一些由 ItemsPositionGetter 提供的信息。 1234567891011121314151617181920212223/** * This class is an API for &#123;@link ListItemsVisibilityCalculator&#125; * Using this class is can access all the data from RecyclerView / * ListView * * There is two different implementations for ListView and for * RecyclerView. * RecyclerView introduced LayoutManager that's why some of data moved * there * * Created by danylo.volokh on 9/20/2015. */public interface ItemsPositionGetter &#123; View getChildAt(int position); int indexOfChild(View view); int getChildCount(); int getLastVisiblePosition(); int getFirstVisiblePosition();&#125; 这样的实现无疑会让 Model 类混入一些业务逻辑，违反了设计模式的部分原则。但通过一些简单的修改就能将它们解耦。不过现在这样它用起来也没多大的问题。 下面是预览图和依赖： 123dependencies &#123; compile 'com.github.danylovolokh:list-visibility-utils:0.2.0'&#125; 组合使用上面完成的工作现在我们需要将上面的工具库结合起来使用以完成我们的功能，下面是使用 RecyclerView 实现的代码： 初始化 ListItemsVisibilityCalculator，并传递列表的引用 123456/** * Only the one (most visible) view should be active (and playing). * To calculate visibility of views we use &#123;@link SingleListViewItemActiveCalculator&#125; */private final ListItemsVisibilityCalculator mVideoVisibilityCalculator = new SingleListViewItemActiveCalculator(new DefaultSingleItemCalculatorCallback(), mList); 当被激活（播放视频）的 View 发生改变，DefaultSingleItemCalculatorCallback 只调用 ListItem.setActive 方法，但你可以重载该方法并按照你的需求实现相应逻辑： 12345678/** * Methods of this callback will be called when new active item is found &#123;@link Callback#activateNewCurrentItem(ListItem, View, int)&#125; * or when there is no active item &#123;@link Callback#deactivateCurrentItem(ListItem, View, int)&#125; - this might happen when user scrolls really fast */public interface Callback&lt;T extends ListItem&gt;&#123; void activateNewCurrentItem(T item, View view, int position); void deactivateCurrentItem(T item, View view, int position);&#125; 初始化 VideoPlayerManager 123456789/** * Here we use &#123;@link SingleVideoPlayerManager&#125;, which means that only one video playback is possible. */private final VideoPlayerManager&lt;MetaData&gt; mVideoPlayerManager = new SingleVideoPlayerManager(new PlayerItemChangeListener() &#123; @Override public void onPlayerItemChanged(MetaData metaData) &#123; &#125;&#125;); 为 RecyclerView 设置滚动监听，并传递滚动事件给列表可见工具库处理。 123456789101112131415161718192021222324@Overridepublic void onScrollStateChanged(RecyclerView view, int scrollState) &#123; mScrollState = scrollState; if(scrollState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mList.isEmpty())&#123; mVideoVisibilityCalculator.onScrollStateIdle( mItemsPositionGetter, mLayoutManager.findFirstVisibleItemPosition(), mLayoutManager.findLastVisibleItemPosition()); &#125; &#125;@Overridepublic void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; if(!mList.isEmpty())&#123; mVideoVisibilityCalculator.onScroll( mItemsPositionGetter, mLayoutManager.findFirstVisibleItemPosition(), mLayoutManager.findLastVisibleItemPosition() - mLayoutManager.findFirstVisibleItemPosition() + 1, mScrollState); &#125;&#125;&#125;); 创建 ItemsPositionGetter 12ItemsPositionGetter mItemsPositionGetter = new RecyclerViewItemPositionGetter(mLayoutManager, mRecyclerView); 在 onResume() 中调用方法以开始计算子项目的可见域，在我们显示出列表时选出可见域最大的子项目 12345678910111213141516171819@Overridepublic void onResume() &#123; super.onResume(); if(!mList.isEmpty())&#123; // need to call this method from list view handler in order to have filled list mRecyclerView.post(new Runnable() &#123; @Override public void run() &#123; mVideoVisibilityCalculator.onScrollStateIdle( mItemsPositionGetter, mLayoutManager.findFirstVisibleItemPosition(), mLayoutManager.findLastVisibleItemPosition()); &#125; &#125;); &#125;&#125; 然后就完成了，在滚动列表中播放许多视频： 这个项目关键部分的讲解基本上已经完成了，下面是具体的代码和范例： https://github.com/danylovolokh/VideoPlayerManager 感谢阅读;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell.github.io/tags/笔记/"},{"name":"收藏","slug":"收藏","permalink":"http://londbell.github.io/tags/收藏/"},{"name":"转载","slug":"转载","permalink":"http://londbell.github.io/tags/转载/"},{"name":"android","slug":"android","permalink":"http://londbell.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"http://londbell.github.io/tags/java/"}]},{"title":"高性能ListViews","date":"2020-03-01T15:31:06.000Z","path":"2020/03/01/performance-listviews/","text":"原文链接 : Performance ListViews 原文作者 : Brandon 译文出自 : 开发技术前线 www.devtf.cn。未经允许，不得转载! 列表展示功能几乎在所有app中都会被用到，使用列表可以很方便的展示一些列表项，比如菜谱、联系人，或者任意类型的类别。所以Android有一个内置的方式来展示此类型的数据，也是在情理之中的。RecyclerView是一种最新的展示列表数据的方式，它非常高效，因为它重用视图而不是每一行出现在屏幕上都重新创建。在RecyclerView出现之前，我们可以使用ListView，即使到了现在，ListView也是广泛的被开发者所使用。虽然ListView也是可以回收视图的，但它也一直都是Android中最容易被错误使用的一个控件。我们知道在此之前这个话题已经被写过无数遍了，但是今天我还是要在博客中提出来，因为我们仍然发现很多app在错误的使用它们。 关于ListView中ArrayAdapter的用法，标准的新手写法是这样子的： 1234567891011121314@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; LayoutInflater inflater = (LayoutInflater) context .getSystemService(Context.LAYOUT_INFLATER_SERVICE); View rowView = inflater.inflate(R.layout.view_test_row, parent, false); TextView testName = (TextView)rowView.findViewById(R.id.text_view_test_name); TextView testDesc = (TextView)rowView.findViewById(R.id.text_view_test_desc); //modify TextViews, in some arbitrary way return rowView;&#125; 当所有列表项都能够一次性在一屏中显示的时候，这种写法并没有什么问题，但这样你就创建了一个基本视图，并完全避免了ArrayAdapter的麻烦了吗？当ListView需要显示一个很大的列表集，而且列表子项是一个非常复杂的视图的时候，上面的方式会消耗大量的性能。当用户滑动屏幕的时候，每个视图都会被inflate并且调用findViewById()方法。当findViewById()方法被调用的时候，会遍历整个视图层级，直到找到正确的Id。每个子视图都要执行上述过程！并且用户滑动的越快，卡顿现象愈加明显。为了解决这个问题，我们可以使用一个静态类来绑定还没被使用的convertView。 12345678910111213141516171819202122232425262728293031static class ViewHolder()&#123; TextView testName; TextView testDesc;&#125;@Override public View getView(int position, View convertView, ViewGroup parent) &#123; View rowView = convertView; //reference to one of the previous Views in the list that we can reuse. if(convertView == null) &#123; LayoutInflater inflater = (LayoutInflater) context .getSystemService(Context.LAYOUT_INFLATER_SERVICE); rowView = inflater.inflate(R.layout.view_test_row, parent, false); ViewHolder viewHolder = new ViewHolder(); viewHolder.testName = (TextView) rowView.findViewById(R.id.text_view_test_name); viewHolder.testDesc = (TextView) rowView.findViewById(R.id.text_view_test_desc); rowView.setTag(viewHolder); &#125; ViewHolder holder = (ViewHolder) rowView.getTag(); //in real code these strings should be in res holder.testName.setText(\"Test\"+position); holder.testDesc.setText(\"This is number \"+position); return rowView;&#125; 那convertView又是什么呢？它可以让ListView跳过一些显示一行内容所需要的设置。如果某一行的视图不在屏幕中显示，我们可以重复使用这个视图来显示一个新行。当ListView刚开始显示的时候，一切都是正常的。既然没有视图可以被用来复用，convertView为空。视图也像前面版本一样被inflate，但是TextViews会被找到且它的引用被保存在一个ViewHolder中。然后我们可以调用setTag()方法将ViewHolder存储在视图中。正如修订过后的getView()方法中后半段代码所示，我们可以在视图中存储后面我们需要用到的数据。 我们所做的更改可能看起来并没有太大的效果，但是随着布局越来越复杂并且数量也越来越多，效果将变得越来越明显。作为开发者，我最不想做的事就是开发一个用户体验很差的app。所以请记住，仅仅一个低水平的ListView都有可能让一个app死掉，我们一定得避免这种情况发生。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell.github.io/tags/笔记/"},{"name":"收藏","slug":"收藏","permalink":"http://londbell.github.io/tags/收藏/"},{"name":"转载","slug":"转载","permalink":"http://londbell.github.io/tags/转载/"},{"name":"android","slug":"android","permalink":"http://londbell.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"http://londbell.github.io/tags/java/"}]},{"title":"Powerlevel10k:Instant Prompt模式","date":"2020-03-01T08:08:50.000Z","path":"2020/03/01/zsh-p10k-instant-prompt/","text":"最近在折腾我的zsh配置，oh-my-zsh、prezto、zinit等框架都折腾了个遍。以后大概会使用zinit为主体，混合搭配oh-my-zsh和prezto的插件来使用。其实我现在比较在意shell的反应速度，oh-my-zsh实在是有些臃肿（功能多插件多无解），prezto虽然优化了启动速度，但在功能性上不能让我满意（其实也是速度不够快orz)。 在研究这些zsh框架的时候，我读到这么一篇文章：Comparison of ZSH frameworks and plugin managers，作者测试了各个框架的性能表现，得出来的结论是zplugin的速度是最快的，而且领先优势非常大。作者后来将zplugin改名为zinit，我们后面统一用zinit来称呼。 使用感受在zinit的实际使用过程中，可以感觉到zinit速度上确实有所提升，但类似于我使用prezto的体验，总感觉还是不够快。大致有以下使用感受： 插件加载管理的性能和prezto类似，都要比oh-my-zsh更好，但也就这样了。 插件机制非常强大，可以无缝使用prezto和oh-my-zsh的插件，灵活性非常好，配合延迟加载机制，整个插件系统的编排、拓展能力非常强力。 zinit的其他高级特性我还没研究明白，我建议大家可以参考加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程 来配置自己的zinit，当然官方文档也很不错。 在折腾这些框架的几天里，我发现zsh的性能其实由两方面决定，首先是前面讲到的插件数量和加载策略，这方面zinit和prezto已经做的很不错了。而另一方面就是pyenv和nvm这种包管理器插件非常影响性能，这也是为什么zinit和prezto不能让我满意的原因。 这是我的.bash_profile里面的内容： 123456789101112131415161718192021222324252627PATH=\"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/VMware Fusion.app/Contents/Public:/usr/local/aria2/bin:/Users/unicorn/.zinit/polaris/bin:/Users/unicorn/.nvm/versions/node/v11.3.0/bin:/Users/unicorn/sdk:/Users/unicorn/sdk/platform-tools:/Users/unicorn/sdk/tools:/Users/unicorn/maven/bin:/Users/unicorn/.rvm/bin\"; export PATH;MANPATH=\"/usr/share/man:/usr/local/share/man:/usr/local/aria2/share/doc/man:/Users/unicorn/.nvm/versions/node/v11.3.0/share/man:/usr/local/aria2/share/man:/Users/unicorn/.rvm/man:/Library/Developer/CommandLineTools/usr/share/man\"; export MANPATH;ANDROID_HOME=$HOME/sdkGRADLE_USER_HOME=$HOME/.gradleexport GRADLE_USER_HOMEexport ANDROID_HOMEexport PATH=$PATH:$ANDROID_HOMEexport PATH=$PATH:$ANDROID_HOME/platform-toolsexport PATH=$PATH:$ANDROID_HOME/toolsexport M2_HOME=$HOME/mavenexport M2=$M2_HOME/bin#export MAVEN_OPTS=-Xmx:1024M#export JAVA_TOOL_OPTIONS=-Xmx2028Mexport PATH=$PATH:$M2# Add RVM to PATH for scripting. Make sure this is the last PATH variable change.export PATH=\"$PATH:$HOME/.rvm/bin\"export NVM_DIR=\"/Users/unicorn/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; . \"$NVM_DIR/nvm.sh\" # This loads nvm[[ -s \"$HOME/.rvm/scripts/rvm\" ]] &amp;&amp; source \"$HOME/.rvm/scripts/rvm\" # Load RVM into a shell session *as a function*export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottlesif [ -f ~/.bashrc ]; then source ~/.bashrcfi 可以直接参考P10K作者的demo，就能知道这些玩意对性能的影响: powerlevel10korz前面废话太多了，终于到正题了。powerlevel10k是romkatv为zsh开发的主题；其实称作主题还挺奇怪的，powerlevel10k有着普通主题做不到的魔力，它主打速度、灵活性和开箱即用的体验。以后可能会单独研究一下这个主题，但今天我只想讲讲它的Instant prompt模式。 Instant prompt我们再来重放一下之前的lag表现： 开启Instant prompt之后： 说实话当我看到这个对比时确实惊到了，通过在shell加载过程中提供一个简化的prompt，Instant prompt通过后台加载机制大幅度降低了启动延迟，对于我这种强迫症患者真是太棒了（反正我输入第一条指令也需要至少2-3s的时间，那时候后台加载过程早就结束了）。 开启Instant prompt遇到的问题根据作者给出的指南How do I enable instant prompt?，绝大多数情况下只要将这段代码加入到.zshrc文件的开头即可： 123456# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.# Initialization code that may require console input (password prompts, [y/n]# confirmations, etc.) must go above this block; everything else may go below.if [[ -r \"$&#123;XDG_CACHE_HOME:-$HOME/.cache&#125;/p10k-instant-prompt-$&#123;(%):-%n&#125;.zsh\" ]]; then source \"$&#123;XDG_CACHE_HOME:-$HOME/.cache&#125;/p10k-instant-prompt-$&#123;(%):-%n&#125;.zsh\"fi 比较诡异的是我这么做之后发现打开速度还是很慢，于是开始了逐项排查。 zinit加载方式因为我使用zinit来加载p10k主题，理所当然的我开始排查zinit。 zinit加载： 1zinit ice depth=1; zinit light romkatv/powerlevel10k 我换成了这样： 1source ~/.zinit/plugins/romkatv---powerlevel10k/powerlevel10k.zsh-theme 但实测结果是和zinit无关，看来不是zinit的锅。 instant prompt enable检查在开启instant prompt的时候，根据作者的指引，我们在.zshrc的开头加入了 123if [[ -r \"$&#123;XDG_CACHE_HOME:-$HOME/.cache&#125;/p10k-instant-prompt-$&#123;(%):-%n&#125;.zsh\" ]]; then source \"$&#123;XDG_CACHE_HOME:-$HOME/.cache&#125;/p10k-instant-prompt-$&#123;(%):-%n&#125;.zsh\"fi 其中的${XDG_CACHE_HOME:-$HOME/.cache路径其实就是~/.cache，但我并没有发现p10k-instant-prompt-unicorn.zsh文件： 难道是没有开启成功吗？于是我又执行了一次p10k configure指令重新配置p10k，根据帮助文档，执行p10k configure会自动开启instant prompt模式。实测多次后还是没有生成instant-prompt文件。 正在我一筹莫展的时候，我看到了作者在reddit上的讨论，上面有位用户的留言和我的状况很类似： Just updated to the latest version, but seems nothing changed.[[ -r “\\${XDG_CACHE_HOME:-\\$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh” ]]returns false since theres no instant-prompt file in ~/.cacheAny idea what might be the problem?I’m no macOS Majave.Thanks in advance! 而p10k的作者回复： What’s the output of echo $ZSH_VERSION? If it’s less than 5.4, this is the expected behavior. From the docs:NOTE: Instant prompt requires ZSH &gt;= 5.4. It’s OK to enable it even when using an older ZSH version but it won’t do anything. 看到这里我才恍然大悟，这个特性需要高版本的zsh支持，至少要在5.4之上。以后应该养成仔细阅读readme文档的习惯。 升级zsh版本遇到的问题mac内置的zsh并非是最新版本： 既然zsh版本升级就能解决这个问题，于是我直接升级了zsh版本： 1brew install zsh 完事大吉，重新打开iterm2，结果速度还是很慢，一看.cache目录，比之前多了一些文件，但依然没有instant-prompt文件： 这时候我又去仔细看作者的回复，发现我又少看东西了： Keep in mind that the output of echo $ZSH_VERSION can be different from zsh –version. You need to use the former. 好吧，原来brew install zsh并不会成为默认的zsh，而且echo $ZSH_VERSION和zsh --version的version也不一致: 参考How do I update zsh to the latest version?，切换到升级后的zsh版本，重新打开终端，重新进行p10k configure后，Instant Prompt模式设置项终于出来了： 最终效果： 真的是非常快…","tags":[{"name":"zsh","slug":"zsh","permalink":"http://londbell.github.io/tags/zsh/"},{"name":"shell","slug":"shell","permalink":"http://londbell.github.io/tags/shell/"},{"name":"p10k","slug":"p10k","permalink":"http://londbell.github.io/tags/p10k/"},{"name":"dotfiles","slug":"dotfiles","permalink":"http://londbell.github.io/tags/dotfiles/"}]},{"title":"模除运算","date":"2020-02-28T01:32:30.000Z","path":"2020/02/28/modulo/","text":"定义来自wiki百科的模除定义： 模除（又称模数、取模操作、取模运算等，英语：modulo 有时也称作 modulus）得到的是一个数除以另一个数的余数。 给定两个正整数：被除数 a 和除数 n，a modulo n (缩写为 a mod n)得到的是使用欧几里德除法时 a/n 的余数。 举个例子：计算表达式 “5 mod 2” 得到 1，因为 5÷2=2…1（5 除以 2 商 2 余 1）；而 “9 mod 3” 得到 0，因为 9÷3=3…0；注意：如果使用计算器做除法，不能整除时，你不会得到商，而是会得到一个小数，如：5÷2=2.5。 虽然通常情况下 a 和 n 都是整数，但许多计算系统允许其他类型的数字操作，如：对浮点数取模。一个整数对 n 取模的结果范围为： 0 到 n − 1（a mod 1 恒等于 0；a mod 0 则是未定义的，在编程语言里可能会导致除零错误）。 有关概念在数论中的应用请参阅模算数。 当 a 和 n 均为负数时，通常的定义就不适用了，不同的编程语言对结果有不同的处理。 数学性质基本概念模除的定义：给定一个正整数$p$,任意一个整数n（包括正数,负数,0),一定存在这样的等式：$$n = p*k+r （0\\le r&lt;p）$$此时k为整数，也就是商。这个等式很重要，后面许多性质都要用到这个等式。 根据这个等式，我们可以计算出：$$r = n\\bmod p$$ 同余式：如果有$a\\bmod p = b\\bmod p$成立，则记作$$a\\equiv b\\pmod p$$ 运算定义模p加法：$$ (a+b)\\bmod p $$ 模p减法：$$ (a-b)\\bmod p $$ 模p乘法：$$(a*b)\\bmod p$$ 基本性质恒等式： $$ (a\\bmod p)\\bmod p =a\\bmod p$$ 这个等式很好证明：$$\\because r=a\\bmod p$$$$\\therefore 0\\le r=a-pk&lt;p$$$$\\therefore 0\\le r-p0&lt;p$$$$\\therefore r\\bmod p=r-p*0=r$$$$\\therefore r\\bmod p=a\\bmod p$$$$\\therefore (a\\bmod p)\\bmod p=r\\bmod p=a\\bmod p$$ 运算规则模p加法规则：$$ (a+b)\\bmod p = (a\\bmod p + b\\bmod p)\\bmod p$$加法的证明并不困难：$$\\because r=(a+b)\\bmod p$$$$\\therefore r=(a+b)-pk(存在整数k，且0\\le r&lt;p)$$$$\\therefore 取k_1,k_2使得0\\le a-pk_1&lt;p,0\\le b-pk_2&lt;p$$$$\\therefore 0\\le r=a-pk_1+b-pk_2-(k-k_1-k_2)p&lt;p$$$$\\therefore 0\\le r=a\\bmod p+b\\bmod p-(k-k_1-k_2)*p&lt;p$$$$\\therefore 0\\le r=(a\\bmod p+b\\bmod p)\\bmod p&lt;p$$$$\\therefore r=(a+b)\\bmod p=(a\\bmod p+b\\bmod p)\\bmod p$$ 模p减法规则：$$(a-b)\\bmod p=(a\\bmod p- b\\bmod p)\\bmod p$$减法的证明：$$\\because r=(a-b)\\bmod p$$$$\\therefore r=(a-b)-pk(存在整数k，且0\\le r&lt;p)$$$$\\therefore 取k_1,k_2使得0\\le a-pk_1&lt;p,0\\le b-pk_2&lt;p$$$$\\therefore 0\\le r=a-pk_1-(b-pk_2)-(k-k_1+k_2)p&lt;p$$$$\\therefore 0\\le r=a\\bmod p-b\\bmod p-(k-k_1+k_2)*p&lt;p$$$$\\therefore 0\\le r=(a\\bmod p-b\\bmod p)\\bmod p&lt;p$$$$\\therefore r=(a-b)\\bmod p=(a\\bmod p-b\\bmod p)\\bmod p$$ 模p乘法规则：$$ (ab)\\mod p = ((a\\bmod p) (b\\bmod p))\\bmod p$$利用前面的加法规则来完成乘法的证明：$$c = a\\bmod p = (mp+c)\\bmod p$$$$d = b\\bmod p = (np+d)\\bmod p$$$$(ab)\\bmod p=((mp+c)(np+d))\\bmod p$$$$((mp+c)(np+d))\\bmod p=(mnp^2+dmp+cnp+cd)\\bmod p$$$$((mp+c)(np+d))\\bmod p=0+0+0+cd\\bmod p=cd\\bmod p$$$$(ab)\\bmod p=(c*d)\\bmod p$$ 结合律：$$((x+y)\\bmod p +z)\\bmod p = (x+(y+z)\\bmod p)\\bmod p$$ 证明：$$等式左边展开:(r_1+r_2+z)\\bmod p=r_1+r_2+z\\bmod p$$$$等式右边展开(x+(y+z)\\bmod p)\\bmod p=(r_1+pk_1+r_2+z\\bmod p)\\bmod p$$$$整理得到(r_1+pk_1+r_2+z\\bmod p)\\bmod p=r_1+0+r_2+(z\\bmod p)\\bmod p$$$$即等式右边=r_1+r_2+z\\bmod p$$$$等式两边相等$$$$\\therefore ((x+y)\\bmod p +z)\\bmod p = (x+(y+z)\\bmod p)\\bmod p$$","tags":[{"name":"数学","slug":"数学","permalink":"http://londbell.github.io/tags/数学/"},{"name":"质数","slug":"质数","permalink":"http://londbell.github.io/tags/质数/"},{"name":"RSA","slug":"RSA","permalink":"http://londbell.github.io/tags/RSA/"}]},{"title":"Mac下的Sed问题","date":"2020-02-22T13:00:50.000Z","path":"2020/02/22/mac-sed/","text":"我最近在折腾自己的dotfiles配置，由于在初始化自己使用环境的步骤中，要经常对配置文件进行字符串替换、添加等操作。所以我大量地使用了sed来操作字符串，可是在实际运用中，发现了sed指令在GNU和BSD下有很大的不同，这个问题是在Mac下发现的。 来龙去脉大体来讲，Mac下的sed和GNU的sed最大的不同是不可忽略备份扩展，换言之你必须指定一个备份扩展，即使可以为空。 下面这条指令在GNU下没有问题，语义是在.zshrc文件中搜索prompt pure字符串并将其删除。 1sed -i \"\\:prompt pure:d\" $&#123;HOME&#125;/.zshrc 但是在mac下，这条指令会直接报错： 1sed: 1: \"~/.zshrc\": undefined label '/.zshrc' 12345man sed -i extension Edit files in-place, saving backups with the specified extension. If a zero-length extension is given, no backup will be saved. It is not recommended to give a zero-length extension when in-place editing files, as you risk corruption or partial content in situations where disk space is exhausted, etc. 无论如何，你要制定备份扩展，可以改成这样子： 1sed -i '' \"\\:prompt pure:d\" $&#123;HOME&#125;/.zshrc 你以为这就完了?如果改成这样，会导致GNU下的sed无法使用。 参考这位同学给出的实验结果，这些兼容写法都是不行的: 123456sed -i -e ...在Mac上不起作用，会创建 -e 备份sed -i'' -e ...在 OS X 10.6 不起作用，但在 10.9+ 可行sed -i '' -e ...兼容了Mac的写法，但是GNU运行出错 解决方法 用gnu-sed代替sed，需要自己安装，然后创建sed的alias指向gsed 使用perl指令来代替 perl用法 1perl -i -pe's/foo/bar/g' target","tags":[{"name":"Mac","slug":"Mac","permalink":"http://londbell.github.io/tags/Mac/"},{"name":"sed","slug":"sed","permalink":"http://londbell.github.io/tags/sed/"},{"name":"GNU","slug":"GNU","permalink":"http://londbell.github.io/tags/GNU/"},{"name":"BSD","slug":"BSD","permalink":"http://londbell.github.io/tags/BSD/"}]},{"title":"WSL安装Manjaro体验(烂尾工程)","date":"2020-02-22T12:48:05.000Z","path":"2020/02/22/manjaro-in-wsl/","text":"安装Arch使用LxRunOffline来安装Arch，需要准备好Arch 在管理员权限运行下的Powershell中，使用以下的指令： 1.\\LxRunOffline.exe i -n Manjaro -d .\\Manjaro\\ -f .\\archlinux-bootstrap-2020.01.01-x86_64.tar.gz -s -r root.x86_64 上面只针对于我自己的配置，需要根据你自己想安装到的位置和名称来修改。 对于Arch，命令中的-r root.x86_64是必须的，-s说明会生成快捷方式。 如上图所示，说明完成了Manjaro的安装。 直接启动LxRunOffline生成的快捷方式，会进入这个WSL环境的Bash，默认以Root用户登录。说明已经安装成功： 配置Arch部署完毕后，需要先生成新的resolv.conf文件,否则无法联网： 1echo \"# This file was automatically generated by WSL. To stop automatic generation of this file, remove this line.\" &gt; /etc/resolv.conf 这时候resolv.conf文件应该长这样： 退出WSL的Bash，重新打开后(不需要任务管理器关闭相关进程)，可以看到resolv.conf文件已经变成了这样： 配置Manjaro因为目前Arch里并没有Vi/Nano等编辑器，我们可以直接进入Windows下面的WSL目录，在Windows中做一部分文本编辑。 先配置Arch的软件源: 默认的Arch源，我们都不需要： 由于我在中国，直接使用清华源即可： 123## Country : ChinaServer = https://mirrors.tuna.tsinghua.edu.cn/manjaro/stable/$repo/$archServer = http://mirrors.tuna.tsinghua.edu.cn/manjaro/stable/$repo/$arch 配置pacman：1pacman-key --init # 初始化key 1pacman -Syy manjaro-keyring # 尝试安装manjaro-keyring软件包，是否导入key选择y，会安装失败，是否选择删除已下载文件时选n 实际上如果前面不对resolv.conf做修改，会提示连接超时错误： 这里我们按正常连接成功流程走: 参考：利用WSL打造Arch开发环境的做法:尝试安装manjaro-keyring软件包，是否导入key选择y，会安装失败，是否选择删除已下载文件时选n 然后，使用-U指令：1pacman -U 上一步提示的下载文件路径 # 强制安装，导入Manjaro的key 1pacman -U /var/cache/pacman/pkg/manjaro-keyring-20190608-1-any.pkg.tar.xz 接着：123pacman-key --init # 再次初始化keypacman-key --populate archlinux manjaro # 下载Arch和Manjaro的keypacman -Syyu # 强制更新软件源索引列表，并更新系统软件包 一路无脑y下去就完事了。 这个时候，mirrorlist文件被自动修改成了一堆没用的mirror： 我们修改回原来的清华源： 123## Country : ChinaServer = https://mirrors.tuna.tsinghua.edu.cn/manjaro/stable/$repo/$archServer = http://mirrors.tuna.tsinghua.edu.cn/manjaro/stable/$repo/$arch 参考：利用WSL打造Arch开发环境的packages.txt，将下面的软件包列表拷贝到一个packages.txt中，手动安装即可。 1pacman -Sy --needed $(comm -12 &lt;(pacman -Slq | sort) &lt;(sort packages.txt)) 创建用户123passwd # 初始化root密码useradd -m -s /bin/bash 用户名 # 创建用户passwd 用户名 # 初始化用户密码 修改新增用户的权限组编辑/etc/sudoers文件，在root一行（大约79行）之下添加下列代码，设置 sudo 权限：1用户名 ALL=(ALL) ALL","tags":[{"name":"wsl","slug":"wsl","permalink":"http://londbell.github.io/tags/wsl/"},{"name":"arch","slug":"arch","permalink":"http://londbell.github.io/tags/arch/"},{"name":"manjaro","slug":"manjaro","permalink":"http://londbell.github.io/tags/manjaro/"}]},{"title":"傻瓜函数式编程","date":"2020-02-15T14:34:00.000Z","path":"2020/02/15/FunctionalProgrammingForTheRestOfUs.cn/","text":"开篇我们这些码农做事都是很拖拉的。每天例行报到后，先来点咖啡，看看邮件还有RSS订阅的文章。然后翻翻新闻还有那些技术网站上的更新，再过一遍编程论坛口水区里那些无聊的论战。最后从头把这些再看一次以免错过什么精彩的内容。然后就可以吃午饭了。饭饱过后，回来盯着IDE发一会呆，再看看邮箱，再去搞杯咖啡。光阴似箭，可以回家了…… （在被众人鄙视之前）我唯一想说的是，在这些拖拉的日子里总会时不时读到一些不明觉厉的文章。如果没有打开不应该打开的网站，每隔几天你都可以看到至少一篇这样的东西。它们的共性：难懂，耗时，于是这些文章就慢慢的堆积成山了。很快你就会发现自己已经累积了一堆的收藏链接还有数不清的PDF文件，此时你只希望隐入一个杳无人烟的深山老林里什么也不做，用一年半载好好的消化这些私藏宝贝。当然，我是说最好每天还是能有人来给送吃的顺带帮忙打扫卫生倒垃圾，哇哈哈。 我不知道你都收藏了些什么，我的阅读清单里面相当大部分都是函数式编程相关的东东：基本上是最难啃的。这些文章充斥着无比枯燥的教科书语言，我想就连那些在华尔街浸淫10年以上的大牛都无法搞懂这些函数式编程（简称FP）文章到底在说什么。你可以去花旗集团或者德意志银行找个项目经理来问问1：你们为什么要选JMS而不用Erlang？答案基本上是：我认为这个学术用的语言还无法胜任实际应用。可是，现有的一些系统不仅非常复杂还需要满足十分严苛的需求，它们就都是用函数式编程的方法来实现的。这，就说不过去了。关于FP的文章确实比较难懂，但我不认为一定要搞得那么晦涩。有一些历史原因造成了这种知识断层，可是FP概念本身并不难理解。我希望这篇文章可以成为一个“FP入门指南”，帮助你从指令式编程走向函数式编程。先来点咖啡，然后继续读下去。很快你对FP的理解就会让同事们刮目相看了。 什么是函数式编程（Functional Programming，FP）？它从何而来？可以吃吗？倘若它真的像那些鼓吹FP的人说的那么好，为什么实际应用中那么少见？为什么只有那些在读博士的家伙想要用它？而最重要的是，它母亲的怎么就那么难学？那些所谓的closure、continuation，currying，lazy evaluation还有no side effects都是什么东东（译者：本着保留专用术语的原则，此处及下文类似情形均不译）？如果没有那些大学教授的帮忙怎样把它应用到实际工程里去？为什么它和我们熟悉的万能而神圣的指令式编程那么的不一样？我们很快就会解开这些谜团。刚才我说过实际工程和学术界之间的知识断层是有其历史原因的，那么就先让我来解释一下这个问题。答案，就在接下来的一次公园漫步中： 公园漫步时间机器启动……我们来到公元前380年，也就是2000多年前的雅典城外。这是一个阳光明媚的久违的春天，柏拉图和一个帅气的小男仆走在一片橄榄树荫下。他们正准备前往一个学院。天气很好，吃得很饱，渐渐的，两人的谈话转向了哲学。 “你看那两个学生，哪一个更高一些？”，柏拉图小心的选择用字，以便让这个问题更好的引导眼前的这个小男孩。小男仆望向水池旁边的两个男生，“他们差不多一样高。”。“‘差不多一样高’是什么意思？”柏拉图问。“嗯……从这里看来他们是一样高的，但是如果走近一点我肯定能看出差别来。”柏拉图笑了。他知道这个小孩已经朝他引导的方向走了。“这么说来你的意思是世界上没有什么东西是完全相同的咯？”思考了一会，小男孩回答：“是的。万物之间都至少有一丁点差别，哪怕我们无法分辨出来。”说到点子上了！“那你说，如果世界上没有什么东西是完全相等的，你怎么理解‘完全相等’这个概念？”小男仆看起来很困惑。“这我就不知道了。” 这是人类第一次试图了解数学的本质。柏拉图认为我们所在的世界中，万事万物都是完美模型的一个近似。他同时意识到虽然我们不能感受到完美的模型，但这丝毫不会阻止我们了解完美模型的概念。柏拉图进而得出结论：完美的数学模型只存在于另外一个世界，而因为某种原因我们却可以通过联系着这两个世界的一个纽带来认识这些模型。一个简单的例子就是完美的圆形。没有人见过这样的一个圆，但是我们知道怎样的圆是完美的圆，而且可以用公式把它描述出来。 如此说来，什么是数学呢？为什么可以用数学法则来描述我们的这个宇宙？我们所处的这个世界中万事万物都可以用数学来描述吗？2数理哲学是一门很复杂的学科。它和其他多数哲学一样，更着重于提出问题而不是给出答案。数学就像拼图一样，很多结论都是这样推导出来的：先是确立一些互不冲突的基础原理，以及一些操作这些原理的规则，然后就可以把这些原理以及规则拼凑起来形成新的更加复杂的规则或是定理了。数学家把这种方法称为“形式系统”或是“演算”。如果你想做的话，可以用形式系统描述俄罗斯方块这个游戏。而事实上，俄罗斯方块这个游戏的实现，只要它正确运行，就是一个形式系统。只不过它以一种不常见的形式表现出来罢了。 如果半人马阿尔法上有文明存在的话，那里的生物可能无法解读我们的俄罗斯方块形式系统甚至是简单的圆形的形式系统，因为它们感知世界的唯一器官可能只有鼻子（译者：偶的妈你咋知道？）也许它们是无法得知俄罗斯方块的形式系统了，但是它们很有可能知道圆形。它们的圆形我们可能没法解读，因为我们的鼻子没有它们那么灵敏（译者：那狗可以么？）可是只要越过形式系统的表示方式（比如通过使用“超级鼻子”之类的工具来感知这些用味道表示的形式系统，然后使用标准的解码技术把它们翻译成人类能理解的语言），那么任何有足够智力的文明都可以理解这些形式系统的本质。有意思的是，哪怕宇宙中完全不存在任何文明，类似俄罗斯方块还有圆形这样的形式系统依旧是成立的：只不过没有智慧生物去发现它们而已。这个时候如果忽然一个文明诞生了，那么这些具有智慧的生物就很有可能发现各种各样的形式系统，并且用它们发现的系统去描述各种宇宙法则。不过它们可能不会发现俄罗斯方块这样的形式系统，因为在它们的世界里没有俄罗斯方块这种东西嘛。有很多像俄罗斯方块这样的形式系统是与客观世界无关的，比如说自然数，很难说所有的自然数都与客观世界有关，随便举一个超级大的数，这个数可能就和世界上任何事物无关，因为这个世界可能不是无穷大的。 历史回眸3再次启动时间机……这次到达的是20世纪30年代，离今天近了很多。无论新旧大陆，经济大萧条都造成了巨大的破坏。社会各阶层几乎每一个家庭都深受其害。只有极其少数的几个地方能让人们免于遭受穷困之苦。几乎没有人能够幸运的在这些避难所里度过危机，注意，我说的是几乎没有，还真的有这么些幸运儿，比如说当时普林斯顿大学的数学家们。 新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿，他们将组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。一个名叫阿隆佐·邱奇(Alonzo Church)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有艾伦·图灵、约翰·冯·诺伊曼、库尔特·哥德尔。这四个人都对形式系统感兴趣。相对于现实世界，他们更关心如何解决抽象的数学问题。而他们的问题都有这么一个共同点：都在尝试解答关于计算的问题。诸如：如果有一台拥有无穷计算能力的超级机器，可以用来解决什么问题？它可以自动的解决这些问题吗？是不是还是有些问题解决不了，如果有的话，是为什么？如果这样的机器采用不同的设计，它们的计算能力相同吗？在与这些人的合作下，阿隆佐设计了一个名为lambda演算的形式系统。这个系统实质上是为其中一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。这种函数用希腊字母lambda（λ），这种系统因此得名4。有了这种形式系统，阿隆佐终于可以分析前面的那些问题并且能够给出答案了。除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。 如果二战没有发生，这个故事到这里就应该结束了，我的这篇小文没什么好说的了，你们也可以去看看有什么其他好看的文章。可是二战还是爆发了，整个世界陷于火海之中。那时的美军空前的大量使用炮兵。为了提高轰炸的精度，军方聘请了大批数学家夜以继日的求解各种差分方程用于计算各种火炮发射数据表。后来他们发现单纯手工计算这些方程太耗时了，为了解决这个问题，各种各样的计算设备应运而生。IBM制造的Mark一号就是用来计算这些发射数据表的第一台机器。Mark一号重5吨，由75万个零部件构成，每一秒可以完成3次运算。战后，人们为提高计算能力而做出的努力并没有停止。1949年第一台电子离散变量自动计算机诞生并取得了巨大的成功。它是冯·诺伊曼设计架构的第一个实例，也是一台现实世界中实现的图灵机。相比他的这些同事，那个时候阿隆佐的运气就没那么好了。到了50年代末，一个叫John McCarthy的MIT教授（他也是普林斯顿的硕士）对阿隆佐的成果产生了兴趣。1958年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！很多计算机科学家都认识到了Lisp强大的能力。1973年在MIT人工智能实验室的一些程序员研发出一种机器，并把它叫做Lisp机。于是阿隆佐的lambda演算也有自己的硬件实现了！ 函数式编程函数式编程是阿隆佐思想的在现实世界中的实现。不过不是全部的lambda演算思想都可以运用到实际中，因lambda演算在设计的时候就不是为了在各种现实世界中的限制下工作的。所以，就像面向对象的编程思想一样，函数式编程只是一系列想法，而不是一套严苛的规定。有很多支持函数式编程的程序语言，它们之间的具体设计都不完全一样。在这里我将用Java写的例子介绍那些被广泛应用的函数式编程思想（没错，如果你是受虐狂你可以用Java写出函数式程序）。在下面的章节中我会在Java语言的基础上，做一些修改让它变成实际可用的函数式编程语言。那么现在就开始吧。 Lambda演算在最初设计的时候就是为了研究计算相关的问题。所以函数式编程主要解决的也是计算问题，而出乎意料的是，是用函数来解决的！（译者：请理解原作者的苦心，我想他是希望加入一点调皮的风格以免读者在中途睡着或是转台……）。函数就是函数式编程中的基础元素，可以完成几乎所有的操作，哪怕最简单的计算，也是用函数完成的。我们通常理解的变量在函数式编程中也被函数代替了：在函数式编程中变量仅仅代表某个表达式（这样我们就不用把所有的代码都写在同一行里了）。所以我们这里所说的‘变量’是不能被修改的。所有的变量只能被赋一次初值。在Java中就意味着每一个变量都将被声明为final（如果你用C++，就是const）。在FP中，没有非final的变量。 12final int i = 5;final int j = i + 3; 既然FP中所有的变量都是final的，可以引出两个规定：一是变量前面就没有必要再加上final这个关键字了，二是变量就不能再叫做‘变量’了……于是现在开始对Java做两个改动：所有Java中声明的变量默认为final，而且我们把所谓的‘变量’称为‘符号’。到现在可能会有人有疑问：这个新创造出来的语言可以用来写什么有用的复杂一些的程序吗？毕竟，如果每个符号的值都是不能修改的，那么我们就什么东西都不能改变了！别紧张，这样的说法不完全正确。阿隆佐在设计lambda演算的时候他并不想要保留状态的值以便稍后修改这些值。他更关心的是基于数据之上的操作（也就是更容易理解的“计算”）。而且，lambda演算和图灵机已经被证明了是具有同样能力的系统，因此指令式编程能做到的函数式编程也同样可以做到。那么，怎样才能做到呢？事实上函数式程序是可以保存状态的，只不过它们用的不是变量，而是函数。状态保存在函数的参数中，也就是说在栈上。如果你需要保存一个状态一段时间并且时不时的修改它，那么你可以编写一个递归函数。举个例子，试着写一个函数，用来反转一个Java的字符串。记住咯，这个程序里的变量都是默认为final的5。 12345678String reverse(String arg) &#123; if(arg.length == 0) &#123; return arg; &#125; else &#123; return reverse(arg.substring(1, arg.length)) + arg.substring(0, 1); &#125;&#125; 这个方程运行起来会相对慢一些，因为它重复调用自己6。同时它也会大量的消耗内存，因为它会不断的分配创建内存对象。无论如何，它是用函数式编程思想写出来的。这时候可能有人要问了，为什么要用这种奇怪的方式编写程序呢？嘿，我正准备告诉你。 FP之优点你大概已经在想：上面这种怪胎函数怎么也不合理嘛。在我刚开始学习FP的时候我也这样想的。不过后来我知道我是错的。使用这种方式编程有很多好处。其中一些是主观的。比如说有人认为函数式程序更容易理解。这个我就不说了，哪怕街上随便找个小孩都知道‘容易理解’是多么主观的事情。幸运的是，客观方面的好处还有很多。 单元测试因为FP中的每个符号都是final的，于是没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用（在指令式编程中可以用类成员或是全局变量做到）。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。这正是单元测试工程师梦寐以求的啊。现在测试程序中的函数时只需要关注它的参数就可以了。完全不需要担心函数调用的顺序，也不用费心设置外部某些状态值。唯一需要做的就是传递一些可以代表边界条件的参数给这些函数。相对于指令式编程，如果FP程序中的每一个函数都能通过单元测试，那么我们对这个软件的质量必将信心百倍。反观Java或者C++，仅仅检查函数的返回值是不够的：代码可能修改外部状态值，因此我们还需要验证这些外部的状态值的正确性。在FP语言中呢，就完全不需要。 调试查错如果一段FP程序没有按照预期设计那样运行，调试的工作几乎不费吹灰之力。这些错误是百分之一百可以重现的，因为FP程序中的错误不依赖于之前运行过的不相关的代码。而在一个指令式程序中，一个bug可能有时能重现而有些时候又不能。因为这些函数的运行依赖于某些外部状态， 而这些外部状态又需要由某些与这个bug完全不相关的代码通过某个特别的执行流程才能修改。在FP中这种情况完全不存在：如果一个函数的返回值出错了，它一直都会出错，无论你之前运行了什么代码。一旦问题可以重现，解决它就变得非常简单，几乎就是一段愉悦的旅程。中断程序的运行，检查一下栈，就可以看到每一个函数调用时使用的每一个参数，这一点和指令式代码一样。不同的是指令式程序中这些数据还不足够，因为函数的运行还可能依赖于成员变量，全局变量，还有其他类的状态（而这些状态又依赖于类似的变量）。FP中的函数只依赖于传给它的参数，而这些参数就在眼前！还有，对指令式程序中函数返回值的检查并不能保证这个函数是正确运行的。还要逐一检查若干作用域以外的对象以确保这个函数没有对这些牵连的对象做出什么越轨的行为（译者：好吧，翻译到这里我自己已经有点激动了）。对于一个FP程序，你要做的仅仅是看一下函数的返回值。把栈上的数据过一遍就可以得知有哪些参数传给了什么函数，这些函数又返回了什么值。当一个返回值看起来不对头的那一刻，跳进这个函数看看里面发生了什么。一直重复跟进下去就可以找到bug的源头！ 并发执行不需要任何改动，所有FP程序都是可以并发执行的。由于根本不需要采用锁机制，因此完全不需要担心死锁或是并发竞争的发生。在FP程序中没有哪个线程可以修改任何数据，更不用说多线程之间了。这使得我们可以轻松的添加线程，至于那些祸害并发程序的老问题，想都不用想！既然是这样，为什么没有人在那些高度并行的那些应用程序中采用FP编程呢？事实上，这样的例子并不少见。爱立信开发了一种FP语言，名叫Erlang，并应用在他们的电信交换机上，而这些交换机不仅容错度高而且拓展性强。许多人看到了Erlang的这些优势也纷纷开始使用这一语言。在这里提到的电信交换控制系统远远要比华尔街上使用的系统具有更好的扩展性也更可靠。事实上，用Erlang搭建的系统并不具备可扩展性和可靠性，而Java可以提供这些特性。Erlang只是像岩石一样结实不容易出错而已。FP关于并行的优势不仅于此。就算某个FP程序本身只是单线程的，编译器也可以将其优化成可以在多CPU上运行的并发程序。以下面的程序为例： 123String s1 = somewhatLongOperation1();String s2 = somewhatLongOperation2();String s3 = concatenate(s1, s2); 如果是函数式程序，编译器就可以对代码进行分析，然后可能分析出生成字符串s1和s2的两个函数可能会比较耗时，进而安排它们并行运行。这在指令式编程中是无法做到的，因为每一个函数都有可能修改其外部状态，然后接下来的函数又可能依赖于这些状态的值。在函数式编程中，自动分析代码并找到适合并行执行的函数十分简单，和分析C的内联函数没什么两样。从这个角度来说用FP风格编写的程序是“永不过时”的（虽然我一般不喜欢说大话空话，不过这次就算个例外吧）。硬件厂商已经没办法让CPU运行得再快了。他们只能靠增加CPU核的数量然后用并行来提高运算的速度。这些厂商故意忽略一个事实：只有可以并行的软件才能让你花大价钱买来的这些硬件物有所值。指令式的软件中只有很小一部分能做到跨核运行，而所有的函数式软件都能实现这一目标，因为FP的程序从一开始就是可以并行运行的。 热部署在Windows早期，如果要更新系统那可是要重启电脑的，而且还要重启很多次。哪怕只是安装一个新版本的播放器。到了XP的时代这种情况得到比较大的改善，尽管还是不理想（我工作的时候用的就是Windows，就在现在，我的系统托盘上就有个讨厌的图标，我不重启机子就不消失）。这一方面Unix好一些，曾经。只需要暂停一些相关的部件而不是整个操作系统，就可以安装更新了。虽然是要好一些了，对很多服务器应用来说这也还是不能接受的。电信系统要求的是100%的在线率，如果一个救急电话因为系统升级而无法拨通，成千上万的人就会因此丧命。同样的，华尔街的那些公司怎么也不能说要安装软件而在整个周末停止他们系统的服务。最理想的情况是更新相关的代码而不用暂停系统的其他部件。对指令性程序来说是不可能的。想想看，试着在系统运行时卸载掉一个Java的类然后再载入这个类的新的实现，这样做的话系统中所有该类的实例都会立刻不能运行，因为该类的相关状态已经丢失了。这种情况下可能需绞尽脑汁设计复杂的版本控制代码，需要将所有这种类正在运行的实例序列化，逐一销毁它们，然后创建新类的实例，将现有数据也序列化后装载到这些新的实例中，最后希望负责装载的程序可以正确的把这些数据移植到新实例中并正常的工作。这种事很麻烦，每次有新的改动都需要手工编写装载程序来完成更新，而且这些装载程序还要很小心，以免破坏了现有对象之间的联系。理论上是没问题，可是实际上完全行不通。FP的程序中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。其它的事情有FP的语言工具自动完成！如果还有人认为这只存在于科幻小说中，他需要再想想：多年来Erlang工程师已经使用这种技术对它们的系统进行升级而完全不用暂停运行了。 机器辅助优化及证明FP语言有一个特性很有意思，那就是它们是可以用数学方法来分析的。FP语言本身就是形式系统的实现，只要是能在纸上写出来的数学运算就可以用这种语言表述出来。于是只要能够用数学方法证明两段代码是一致的，编译器就可以把某段代码解析成在数学上等同的但效率又更高的另外一段代码7。 关系数据库已经用这种方法进行优化很多年了。没有理由在常规的软件行业就不能应用这种技术。另外，还可以用这种方法来证明代码的正确性，甚至可以设计出能够自动分析代码并为单元测试自动生成边缘测试用例的工具出来！对于那些对缺陷零容忍的系统来说，这一功能简直就是无价之宝。例如心脏起搏器，例如飞行管控系统，这几乎就是必须满足的需求。哪怕你正在开发的程序不是为了完成什么重要核心任务，这些工具也可以帮助你写出更健壮的程序，直接甩竞争对手n条大街。 高阶函数我还记得在了解到FP以上的各种好处后想到：“这些优势都很吸引人，可是，如果必须非要用这种所有变量都是final的蹩脚语言，估计还是不怎么实用吧”。其实这样的想法是不对的。对于Java这样的指令式语言来说，如果所有的变量都是必须是final的，那么确实很束手束脚。然而对函数式语言来说，情况就不一样了。函数式语言提供了一种特别的抽象工具，这种工具将帮助使用者编写FP代码，让他们甚至都没想到要修改变量的值。高阶函数就是这种工具之一。FP语言中的函数有别于Java或是C。可以说这种函数是一个全集：Java函数可以做到的它都能做，同时它还有更多的能力。首先，像在C里写程序那样创建一个函数： 123int add(int i, int j) &#123; return i + j;&#125; 看起来和C程序没什么区别，但是很快你就可以看出区别来。接下来我们扩展Java的编译器以便支持这种代码，也就是说，当我们写下以上的程序编译器会把它转化成下面的Java程序（别忘了，所有的变量都是final的）： 1234567class add_function_t &#123; int add(int i, int j) &#123; return i + j; &#125;&#125;add_function_t add = new add_function_t(); 在这里，符号add并不是一个函数，它是只有一个函数作为其成员的简单的类。这样做有很多好处，可以在程序中把add当成参数传给其他的函数，也可以把add赋给另外一个符号，还可以在运行时创建add_function_t的实例然后在不再需要这些实例的时候由系统回收机制处理掉。这样做使得函数成为和integer或是string这样的第一类对象。对其他函数进行操作（比如说把这些函数当成参数）的函数，就是所谓的高阶函数。别让这个看似高深的名字吓倒你（译者：好死不死起个这个名字，初一看还准备搬出已经尘封的高数教材……），它和Java中操作其他类（也就是把一个类实例传给另外的类）的类没有什么区别。可以称这样的类为“高阶类”，但是没人会在意，因为Java圈里就没有什么很强的学术社团。（译者：这是高级黑吗？）那么什么时候该用高阶函数，又怎样用呢？我很高兴有人问这个问题。设想一下，你写了一大堆程序而不考虑什么类结构设计，然后发现有一部分代码重复了几次，于是你就会把这部分代码独立出来作为一个函数以便多次调用（所幸学校里至少会教这个）。如果你发现这个函数里有一部分逻辑需要在不同的情况下实现不同的行为，那么你可以把这部分逻辑独立出来作为一个高阶函数。搞晕了？下面来看看我工作中的一个真实的例子。 假设有一段Java的客户端程序用来接收消息，用各种方式对消息做转换，然后发给一个服务器。 1234567891011class MessageHandler &#123; void handleMessage(Message msg) &#123; // ... msg.setClientCode(\"ABCD_123\"); // ... sendMessage(msg); &#125; // ...&#125; 再进一步假设，整个系统改变了，现在需要发给两个服务器而不再是一个了。系统其他部分都不变，唯独客户端的代码需要改变：额外的那个服务器需要用另外一种格式发送消息。应该如何处理这种情况呢？我们可以先检查一下消息要发送到哪里，然后选择相应的格式把这个消息发出去： 123456789101112131415class MessageHandler &#123; void handleMessage(Message msg) &#123; // ... if(msg.getDestination().equals(\"server1\") &#123; msg.setClientCode(\"ABCD_123\"); &#125; else &#123; msg.setClientCode(\"123_ABC\"); &#125; // ... sendMessage(msg); &#125; // ...&#125; 可是这样的实现是不具备扩展性的。如果将来需要增加更多的服务器，上面函数的大小将呈线性增长，使得维护这个函数最终变成一场噩梦。面向对象的编程方法告诉我们，可以把MessageHandler变成一个基类，然后将针对不同格式的消息编写相应的子类。 12345678910111213141516171819202122232425abstract class MessageHandler &#123; void handleMessage(Message msg) &#123; // ... msg.setClientCode(getClientCode()); // ... sendMessage(msg); &#125; abstract String getClientCode(); // ...&#125;class MessageHandlerOne extends MessageHandler &#123; String getClientCode() &#123; return \"ABCD_123\"; &#125;&#125;class MessageHandlerTwo extends MessageHandler &#123; String getClientCode() &#123; return \"123_ABCD\"; &#125;&#125; 这样一来就可以为每一个接收消息的服务器生成一个相应的类对象，添加服务器就变得更加容易维护了。可是，这一个简单的改动引出了很多的代码。仅仅是为了支持不同的客户端行为代码，就要定义两种新的类型！现在来试试用我们刚才改造的语言来做同样的事情，注意，这种语言支持高阶函数： 12345678910111213141516171819202122class MessageHandler &#123; void handleMessage(Message msg, Function getClientCode) &#123; // ... Message msg1 = msg.setClientCode(getClientCode()); // ... sendMessage(msg1); &#125; // ...&#125;String getClientCodeOne() &#123; return \"ABCD_123\";&#125;String getClientCodeTwo() &#123; return \"123_ABCD\";&#125;MessageHandler handler = new MessageHandler();handler.handleMessage(someMsg, getClientCodeOne); 在上面的程序里，我们没有创建任何新的类型或是多层类的结构。仅仅是把相应的函数作为参数进行传递，就做到了和用面向对象编程一样的事情，而且还有额外的好处：一是不再受限于多层类的结构。这样做可以做运行时传递新的函数，可以在任何时候改变这些函数，而且这些改变不仅更加精准而且触碰的代码更少。这种情况下编译器其实就是在替我们编写面向对象的“粘合”代码（译者：又称胶水代码，粘接代码）！除此之外我们还可以享用FP编程的其他所有优势。函数式编程能提供的抽象服务还远不止于此。高阶函数只不过是个开始。 Currying我遇见的大多数码农都读过“四人帮”的那本《设计模式》。任何稍有自尊心的码农都会说这本书和语言无关，因此无论你用什么编程语言，当中提到的那些模式大体上适用于所有软件工程。听起来很厉害，然而事实却不是这样。 函数式语言的表达能力很强。用这种语言编程的时候基本不需要设计模式，因为这种语言层次已经足够高，使得使用者可以以概念编程，从而完全不需要设计模式了。以适配器模式为例（有人知道这个模式和外观模式有什么区别吗？怎么觉得有人为了出版合同的要求而硬生生凑页数？）（译者：您不愧是高级黑啊）。对于一个支持currying技术的语言来说，这个模式就是多余的。在Java中最有名的适配器模式就是在其“默认”抽象单元中的应用：类。在函数式语言中这种模式其实就是函数。在这个模式中，一个接口被转换成另外一个接口，让不同的用户代码调用。接下来就有一个适配器模式的例子： 12345int pow(int i, int j);int square(int i)&#123; return pow(i, 2);&#125; 上面的代码中square函数计算一个整数的平方，这个函数的接口被转换成计算一个整数的任意整数次幂。在学术圈里这种简单的技术就被叫做currying（因为逻辑学家哈斯凯尔·加里用其数学技巧将这种技术描述出来，于是就以他的名字来命名了）。在一个FP语言中函数（而不是类）被作为参数进行传递，currying常常用于转化一个函数的接口以便于其他代码调用。函数的接口就是它的参数，于是currying通常用于减少函数参数的数量（见前例）。函数式语言生来就支持这一技术，于是没有必要为某个函数手工创建另外一个函数去包装并转换它的接口，这些函数式语言已经为你做好了。我们继续拓展Java来支持这一功能。 1square = int pow(int i, 2); 上面的语句实现了一个平方计算函数，它只需要一个参数。它会继而调用pow函数并且把第二个参数置为2。编译过后将生成以下Java代码： 123456class square_function_t &#123; int square(int i) &#123; return pow(i, 2); &#125;&#125;square_function_t square = new square_function_t(); 从上面的例子可以看到，很简单的，函数pow的封装函数就创建出来了。在FP语言中currying就这么简单：一种可以快速且简单的实现函数封装的捷径。我们可以更专注于自己的设计，编译器则会为你编写正确的代码！什么时候使用currying呢？很简单，当你想要用适配器模式（或是封装函数）的时候，就是用currying的时候。 惰性求值惰性求值（或是延迟求值）是一种有趣的技术，而当我们投入函数式编程的怀抱后这种技术就有了得以实现的可能。前面介绍并发执行的时候已经提到过如下代码： 123String s1 = somewhatLongOperation1();String s2 = somewhatLongOperation2();String s3 = concatenate(s1, s2); 在指令式语言中以上代码执行的顺序是显而易见的。由于每个函数都有可能改动或者依赖于其外部的状态，因此必须顺序执行。先是计算somewhatLongOperation1，然后到somewhatLongOperation2，最后执行concatenate。函数式语言就不一样了。在前面讨论过，somewhatLongOperation1和somewhatLongOperation2是可以并发执行的，因为函数式语言保证了一点：没有函数会影响或者依赖于全局状态。可是万一我们不想要这两个函数并发执行呢？这种情况下是不是也还是要顺序执行这些函数？答案是否定的。只有到了执行需要s1、s2作为参数的函数的时候，才真正需要执行这两个函数。于是在concatenate这个函数没有执行之前，都没有需要去执行这两个函数：这些函数的执行可以一直推迟到concatenate()中需要用到s1和s2的时候。假如把concatenate换成另外一个函数，这个函数中有条件判断语句而且实际上只会需要两个参数中的其中一个，那么就完全没有必要执行计算另外一个参数的函数了！Haskell语言就是一个支持惰性求值的例子。Haskell不能保证任何语句会顺序执行（甚至完全不会执行到），因为Haskell的代码只有在需要的时候才会被执行到。除了这些优点，惰性求值也有缺点。这里介绍了它的优点，我们将在下一章节介绍这些缺点以及如何克服它们。 代码优化惰性求值使得代码具备了巨大的优化潜能。支持惰性求值的编译器会像数学家看待代数表达式那样看待函数式程序：抵消相同项从而避免执行无谓的代码，安排代码执行顺序从而实现更高的执行效率甚至是减少错误。在此基础上优化是不会破坏代码正常运行的。严格使用形式系统的基本元素进行编程带来的最大的好处，是可以用数学方法分析处理代码，因为这样的程序是完全符合数学法则的。 抽象化控制结构惰性求值技术提供了更高阶的抽象能力，这提供了实现程序设计独特的方法。比如说下面的控制结构： 123unless(stock.isEuropean()) &#123; sendToSEC(stock);&#125; 程序中只有在stock为European的时候才执行sendToSEC。如何实现例子中的unless？如果没有惰性求值就需要求助于某种形式的宏（译者：用if不行么？），不过在像Haskell这样的语言中就不需要那么麻烦了。直接实现一个unless函数就可以！ 1234void unless(boolean condition, List code) &#123; if(!condition) code;&#125; 请注意，如果condition值为真，那就不会计算code。在其他严格语言（见严格求值）中这种行为是做不到的，因为在进入unless这个函数之前，作为参数的code已经被计算过了。 无穷数据结构惰性求值技术允许定义无穷数据结构，这要在严格语言中实现将非常复杂。例如一个储存Fibonacci数列数字的列表。很明显这样一个列表是无法在有限的时间内计算出这个无穷的数列并存储在内存中的。在像Java这样的严格语言中，可以定义一个Fibonacci函数，返回这个序列中的某个数。而在Haskell或是类似的语言中，可以把这个函数进一步抽象化并定义一个Fibonacci数列的无穷列表结构。由于语言本身支持惰性求值，这个列表中只有真正会被用到的数才会被计算出来。这让我们可以把很多问题抽象化，然后在更高的层面上解决它们（比如可以在一个列表处理函数中处理无穷多数据的列表）。 不足之处俗话说天下没有免费的午餐™。惰性求值当然也有其缺点。其中最大的一个就是，嗯，惰性。现实世界中很多问题还是需要严格求值的。比如说下面的例子： 12System.out.println(\"Please enter your name: \");System.in.readLine(); 在惰性语言中没人能保证第一行会中第二行之前执行！这也就意味着我们不能处理IO，不能调用系统函数做任何有用的事情（这些函数需要按照顺序执行，因为它们依赖于外部状态），也就是说不能和外界交互了！如果在代码中引入支持顺序执行的代码原语，那么我们就失去了用数学方式分析处理代码的优势（而这也意味着失去了函数式编程的所有优势）。幸运的是我们还不算一无所有。数学家们研究了不同的方法用以保证代码按一定的顺序执行（in a functional setting?）。这一来我们就可以同时利用到函数式和指令式编程的优点了！这些方法有continuations，monads以及uniqueness typing。这篇文章仅仅介绍了continuations，以后再讨论monads和uniqueness typing。有意思的是呢，coutinuations处理强制代码以特定顺序执行之外还有其他很多出处，这些我们在后面也会提及。 Continuationcontinuation对于编程，就像是达芬奇密码对于人类历史一样：它揭开了人类有史以来最大的谜团。好吧，也许没有那么夸张，不过它们的影响至少和当年发现负数有平方根不相上下。 我们对函数的理解只有一半是正确的，因为这样的理解基于一个错误的假设：函数一定要把其返回值返回给调用者。按照这样的理解，continuation就是更加广义的函数。这里的函数不一定要把返回值传回给调用者，相反，它可以把返回值传给程序中的任意代码。continuation就是一种特别的参数，把这种参数传到函数中，函数就能够根据continuation将返回值传递到程序中的某段代码中。说得很高深，实际上没那么复杂。直接来看看下面的例子好了： 12int i = add(5, 10);int j = square(i); add这个函数将返回15然后这个值会赋给i，这也是add被调用的地方。接下来i的值又会被用于调用square。请注意支持惰性求值的编译器是不能打乱这段代码执行顺序的，因为第二个函数的执行依赖于第一个函数成功执行并返回结果。这段代码可以用Continuation Pass Style（CPS）技术重写，这样一来add的返回值就不是传给其调用者，而是直接传到square里去了。 1int j = add(5, 10, square); 在上例中，add多了一个参数：一个函数，add必须在完成自己的计算后，调用这个函数并把结果传给它。这时square就是add的一个continuation。上面两段程序中j的值都是225。 这样，我们学习到了强制惰性语言顺序执行两个表达式的第一个技巧。再来看看下面IO程序（是不是有点眼熟？）： 12System.out.println(\"Please enter your name: \");System.in.readLine(); 这两行代码彼此之间没有依赖关系，因此编译器可以随意的重新安排它们的执行顺序。可是只要用CPS重写它，编译器就必须顺序执行了，因为重写后的代码存在依赖关系了。 1System.out.println(\"Please enter your name: \", System.in.readLine); 这段新的代码中println需要结合其计算结果调用readLine，然后再返回readLine的返回值。这使得两个函数得以保证按顺序执行而且readLine总被执行（这是由于整个运算需要它的返回值作为最终结果）。Java的println是没有返回值的，但是如果它可以返回一个能被readnLine接受的抽象值，问题就解决了！（译者：别忘了，这里作者一开始就在Java的基础上修改搭建自己的语言）当然，如果一直把函数按照这种方法串下去，代码很快就变得不可读了，可是没有人要求你一定要这样做。可以通过在语言中添加语法糖的方式来解决这个问题，这样程序员只要按照顺序写代码，编译器负责自动把它们串起来就好了。于是就可以任意安排代码的执行顺序而不用担心会失去FP带来的好处了（包括可以用数学方法来分析我们的程序）！如果到这里还有人感到困惑，可以这样理解，函数只是有唯一成员的类的实例而已。试着重写上面两行程序，让println和readLine编程这种类的实例，所有问题就都搞清楚了。到这里本章基本可以结束了，而我们仅仅了解到continuation的一点皮毛，对它的用途也知之甚少。我们可以用CPS完成整个程序，程序里所有的函数都有一个额外的continuation作为参数接受其他函数的返回值。还可以把任何程序转换为CPS的，需要做的只是把当中的函数看作是特殊的continuation（总是将返回值传给调用者的continuation）就可以了，简单到完全可以由工具自动完成（史上很多编译器就是这样做的）。 一旦将程序转为CPS的风格，有些事情就变得显而易见了：每一条指令都会有一些continuation，都会将它的计算结果传给某一个函数并调用它，在一个普通的程序中这个函数就是该指令被调用并且返回的地方。随便找个之前提到过的代码，比如说add(5,10)好了。如果add属于一个用CPS风格写出的程序，add的continuation很明显就是当它执行结束后要调用的那个函数。可是在一个非CPS的程序中，add的continuation又是什么呢？当然我们还是可以把这段程序转成CPS的，可是有必要这样做吗？事实上没有必要。注意观察整个CPS转换过程，如果有人尝试要为CPS程序写编译器并且认真思考过就会发现：CPS的程序是不需要栈的！在这里完全没有函数需要做传统意义上的“返回”操作，函数执行完后仅需要接着调用另外一个函数就可以了。于是就不需要在每次调用函数的时候把参数压栈再将它们从中取出，只要把这些参数存放在一片内存中然后使用跳转指令就解决问题了。也完全不需要保留原来的参数：因为这种程序里的函数都不返回，所以它们不会被用第二次！简单点说呢，用CPS风格写出来的程序不需要栈，但是每次调用函数的时候都会要多加一个参数。非CPS风格的程序不需要额外的参数但又需要栈才能运行。栈里面存的是什么？仅仅是参数还有一个供函数运行结束后返回的程序指针而已。这个时候你是不是已经恍然大悟了？对啊，栈里面的数据实际上就是continuation的信息！栈上的程序返回指针实质上就是CPS程序中需要调用的下一个函数！想要知道add(5, 10)的continuation是什么？只要看它运行时栈的内容就可以了。接下来就简单多了。continuation和栈上指示函数返回地址的指针其实是同一样东西，只是continuation是显式的传递该地址并且因此代码就不局限于只能返回到函数被调用的地方了。前面说过，continuation就是函数，而在我们特制的语言中函数就是类的实例，那么可以得知栈上指向函数返回地址的指针和continuation的参数是一样的，因为我们所谓的函数（就像类的一个实例）其实就是指针。这也意味着在程序运行的任何时候，你都可以得到当前的continuation（就是栈上的信息）。 好了，我们已经搞清楚当前的continuation是什么了。接下来要弄明白它的存在有什么意义。只要得到了当前的continuation并将它保存起来，就相当于保存了程序的当前状态：在时间轴上把它冻结起来了。这有点像操作系统进入休眠状态。continuation对象保存了足够的信息随时可以从指定的某个状态继续运行程序。在切换线程的时候操作系统也是这样做的。唯一的区别在于它保留了所有的控制权利。当请求某个continuation对象时（在Scheme语言中是通过调用call-with-current-continuation函数实现的）得到的是一个存有当前continuation的对象，也就是栈对象（在CPS中也就是下一个要执行的函数）。可以把这个对象保存做一个变量中（或者是存在磁盘上）。当以该continuation对象“重启”该程序时，程序的状态就会立即“转换”为该对象中保存的状态。这一点和切换回一个被暂停的线程或是从系统休眠中唤醒很相像，唯一不同的是continuatoin对象可以反复的这样使用。当系统唤醒后，休眠前保存的信息就会销毁，否则你也可以反复的从该点唤醒系统，就像乘时光机回到过去一样。有了continuation你就可以做到这一点！ 那么continuation在什么情况下有用呢？有一些应用程序天生就没有状态，如果要在这样的系统中模拟出状态以简化工作的时候，就可以用到continuation。最合适的应用场合之一就是网页应用程序。微软的ASP.NET为了让程序员更轻松的编写应用程序，花了大量的精力去模拟各种状态。假如C#支持continuation的话，那么ASP.NET的复杂度将减半：因为只要把某一时刻的continuation保存起来，下次用户再次发起同样请求的时候，重新载入这个continuation即可。对于网络应用的程序员来说就再也没有中断了：轻轻松松程序就从下一行开始继续运行了！对于一些实际问题来说，continuation是一种非常有用的抽象工具。如今大量的传统胖客户端（见瘦客户端）正纷纷走进网络，continuation在未来将扮演越来越重要的角色。 模式匹配模式匹配并不是什么新功能。而事实上它和函数式编程也没有什么太大的关系。它之所以常常被认为是FP的一个特性，是因为在函数式语言已经支持模式匹配很长一段时间后的今天，指令式语言是还没有这个功能。 还是直接用例子来看看什么是模式匹配吧，这是一个用Java写的Fibonacci函数： 123456 int fib(int n) &#123; if(n == 0) return 1; if(n == 1) return 1; return fib(n - 2) + fib(n - 1);&#125; 再看看用我们基于Java修改过的新语言写出来的Fibonacci函数，这种新语言就支持模式匹配： 123456789 int fib(0) &#123; return 1;&#125;int fib(1) &#123; return 1;&#125;int fib(int n) &#123; return fib(n - 2) + fib(n - 1);&#125; 区别在哪里呢？在于后者的编译器替我们实现了程序的分支。这有什么了不起的？确实也没什么。只是有人注意到很多函数中有非常复杂的switch结构（对于函数式程序而言更是如此），于是想到如果能把这层结构也抽象化就更好了。然后就把这个复杂的函数拆分成若干新的函数，并在这些函数的某些参数中应用模式（这和重载有点类似）。这样依赖当这个函数被调用的时候，编译器会在运行时将调用者传入的参数与各个新函数的参数定义进行比较，找出合适的那个函数来执行。合适的函数往往是参数定义上最具体最接近传入参数的那个函数。在这个例子中，当n为1时，可以用函数int fib(int n)，不过真正调用的是int fib(1)因为这个函数更具体更接近调用者的要求。模式匹配一般来说要比这里举的例子更加复杂。比如说，高级模式匹配系统可以支持下面的操作： 12int f(int n &lt; 10) &#123; ... &#125;int f(int n) &#123; ... &#125; 那么什么情况下模式匹配会有用呢？在需要处理一大堆程序分支的时候！每当需要实现复杂的嵌套if语句的时候，模式匹配可以帮助你用更少的代码更好的完成任务。我所知道的一个这样的函数是标准的WndProc函数，该函数是所有Win32应用程序必须具备的（尽管它经常会被抽象化）。模式匹配系统一般都可以像匹配简单数值一样匹配数据集合。举个例子，对于一个接受数组作为参数的函数，可以通过模式匹配数组中第一个数字为1并且第三个数字大于3的输入。模式匹配的另外一个好处是每当需要添加或者修改程序分支时，再也不用面对那个庞大臃肿的函数了。只要添加（或者修改）相关的函数定义即可。有了模式匹配就不再需要四人帮的很多设计模式了。程序分支越多越复杂，模式匹配就越有用。而在习惯使用这一技术之后，你可能会怀疑没有它你一天都过不下去了。 Closure目前为止关于函数式编程各种功能的讨论都只局限在“纯”函数式语言范围内：这些语言都是lambda演算的实现并且都没有那些和阿隆佐形式系统相冲突的特性。然而，很多函数式语言的特性哪怕是在lambda演算框架之外都是很有用的。确实，如果一个公理系统的实现可以用数学思维来看待程序，那么这个实现还是很有用的，但这样的实现却不一定可以付诸实践。很多现实中的语言都选择吸收函数式编程的一些元素，却又不完全受限于函数式教条的束缚。很多这样的语言（比如Common Lisp）都不要求所有的变量必须为final，可以修改他们的值。也不要求函数只能依赖于它们的参数，而是可以读写函数外部的状态。同时这些语言又包含了FP的特性，如高阶函数。与在lambda演算限制下将函数作为参数传递不同，在指令式语言中要做到同样的事情需要支持一个有趣的特性，人们常把它称为lexical closure。还是来看看例子。要注意的是，这个例子中变量不是final，而且函数也可以读写其外部的变量： 12345678910 Function makePowerFn(int power) &#123; int powerFn(int base) &#123; return pow(base, power); &#125; return powerFn;&#125;Function square = makePowerFn(2);square(3); // returns 9 makePowerFn函数返回另一个函数，这个新的函数需要一个整数参数然后返回它的平方值。执行square(3)的时候具体发生了什么事呢？变量power并不在powerFn的域内，因为makePowerFn早就运行结束返回了，所以它的栈也已经不存在了。那么square又是怎么正常工作的呢？这个时候需要语言通过某种方式支持继续存储power的值，以便square后面继续使用。那么如果再定义一个函数，cube，用来计算立方，又应该怎么做呢？那么运行中的程序就必须存储两份power的值，提供给makePowerFn生成的两个函数分别使用。这种保存变量值的方法就叫做closure。closure不仅仅保存宿主函数的参数值，还可以用在下例的用法中： 1234567891011121314151617Function makeIncrementer() &#123; int n = 0; int increment() &#123; return ++n; &#125;&#125;Function inc1 = makeIncrementer();Function inc2 = makeIncrementer();inc1(); // returns 1;inc1(); // returns 2;inc1(); // returns 3;inc2(); // returns 1;inc2(); // returns 2;inc2(); // returns 3; 运行中的程序负责存储n的值，以便incrementer稍后可以访问它。与此同时，程序还会保存多份n的拷贝，虽然这些值应该在makeIncrementer返回后就消失，但在这个情况下却继续保留下来给每一个incrementer对象使用。这样的代码编译之后会是什么样子？closure幕后的真正工作机理又是什么？这次运气不错，我们有一个后台通行证，可以一窥究竟。一点小常识往往可以帮大忙。乍一看这些本地变量已经不再受限于基本的域限制并拥有无限的生命周期了。于是可以得出一个很明显的结论：它们已经不是存在栈上，而是堆上了8。这么说来closure的实现和前面讨论过的函数差不多，只不过closure多了一个额外的引用指向其外部的变量而已： 12345 class some_function_t &#123; SymbolTable parentScope; // ...&#125; 当closure需要访问不在它本地域的变量时，就可以通过这个引用到更外一层的父域中寻找该变量。谜底揭开了！closure将函数编程与面向对象的方法结合了起来。下一次为了保存并传递某些状态而创建类的时候，想想closure。它能在运行时从相应的域中获得变量，从而可以把该变量当初“成员变量”来访问，也因为这样，就不再需要去创建一个成员变量了。 路在何方？这篇文章仅仅涉及到函数式编程的一些皮毛。考虑到有时候星星之火可以燎原，所以如果它能给你一些帮助那就再好不过了。接下来我计划就范畴论、monads、函数式编程数据结构、函数式语言中的类型系统、并行函数式编程、数据库的函数式编程以及更多的话题写些类似的文章。如果我可以写出（在我学习的同时）以上清单的一半，我的人生就完整了。于此同时，Google将是我们的良师益友。 ###欢迎联系如果您有任何问题，评价或者建议，请发邮件到coffeemug@gmail.com（译者：如果翻译方面的问题／建议请发到yang.huang@ymail.com:)）。期待您的回复。 注：1当我在2005年求职时的的确确经常问别人这个问题。看着那些茫然的面孔实在是很好玩的事情。你们这些年薪30万美金的家伙，至少应该对自己可以利用的工具有个起码的理解嘛。2这是个有争议的问题。物理学家和数学家不得不承认目前还无法确定宇宙万物是不是都遵从可以用数学方法描述的各种法则。3我一直一来都很讨厌在历史课上罗列一堆枯燥无味的时间、人名、事件。对我来说历史就是关于那些改变世界的人们活生生的故事，是他们行为背后的个人动机，是那些他们用以影响芸芸众生的方法和工具。从这个角度来说，接下来的这堂历史课是不完整的，很遗憾。只有那些非常相关的人和事会被提及。4在我学习函数式编程的时候，“lambda”这个术语搞得我很烦，因为我不知道它到底是什么意思。在这里lambda就是一个函数，在数学符号中用这个希腊字母只是因为它更容易写。所以以后在谈及函数式编程的时候只要你听到lambda，把它在脑中翻译为“函数”就可以了。5有意思的是不论如何Java中的字符串总是不可修改的。讨论这种背叛Java的设计背后的原因会很有意思，可惜这样会让我们跑题的。6大部分函数式语言的编译器都会尽量将迭代函数转换为对等的循环语句。这种做法叫做尾调用优化。7反之则不一定成立。尽管有时候可以证明两段代码是等价的，但不是在所有的情况下都可以得出这样的结论。8实际上这样做并不比栈上存储要慢，因为在引入垃圾回收机制)后，内存分配操作的时间代价仅为O(1)。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell.github.io/tags/笔记/"},{"name":"收藏","slug":"收藏","permalink":"http://londbell.github.io/tags/收藏/"},{"name":"转载","slug":"转载","permalink":"http://londbell.github.io/tags/转载/"}]},{"title":"王垠:怎样写一个解释器","date":"2020-02-14T08:56:33.000Z","path":"2020/02/14/interpreter/","text":"原文来自于王垠的怎样写一个解释器,由于原文中的源码与图片已经无法访问，所以搜索全网找到这些资源后，在自己的blog上做一个备份，以方便以后阅读。 怎样写一个解释器写一个解释器，通常是设计和实现程序语言的第一步。解释器是简单却又深奥的东西，以至于好多人都不会写，所以我决定写一篇这方面的入门读物。 虽然我试图从最基本的原理讲起，尽量不依赖于其它知识，但这并不是一本编程入门教材。我假设你已经理解 Scheme 语言，以及基本的编程技巧（比如递归）。如果你完全不了解这些，那我建议你读一下 SICP的第一，二章，或者 HtDP 的前几章，习题可以不做。注意不要读太多书，否则你就回不来了 ;-) 当然你也可以直接读这篇文章，有不懂的地方再去查资料。 实现语言容易犯的一个错误，就是一开头就试图去实现很复杂的语言（比如 JavaScript 或者 Python）。这样你很快就会因为这些语言的复杂性，以及各种历史遗留的设计问题而受到挫折，最后不了了之。学习实现语言，最好是从最简单，最干净的语言开始，迅速写出一个可用的解释器。之后再逐步往里面添加特性，同时保持正确。这样你才能有条不紊地构造出复杂的解释器。 因为这个原因，这篇文章只针对一个很简单的语言，名叫“R2”。它可以作为一个简单的计算器用，还具有变量定义，函数定义和调用等功能。 我们的工具：Racket本文的解释器是用 Scheme 语言实现的。Scheme 有很多的“实现”，这里我用的实现叫做 Racket，它可以在这里免费下载。为了让程序简洁，我用了一点点 Racket 的模式匹配（pattern matching）功能。我对 Scheme 的实现没有特别的偏好，但 Racket 方便易用，适合教学。如果你用其它的 Scheme 实现，可能得自己做一些调整。 Racket 具有宏（macro），所以它其实可以变成很多种语言。如果你之前用过 DrRacket，那它的“语言设置”可能被你改成了 R5RS 之类的。所以如果下面的程序不能运行，你可能需要检查一下 DrRacket 的“语言设置”，把 Language 设置成 “Racket”。 Racket 允许使用方括号而不只是圆括号，所以你可以写这样的代码： 123(let ([x 1] [y 2]) (+ x y)) 方括号跟圆括号可以互换，唯一的要求是方括号必须和方括号匹配。通常我喜欢用方括号来表示“无动作”的数据（比如上面的 [x 1], [y 2]），这样可以跟函数调用和其它具有“动作”的代码，产生“视觉差”。这对于代码的可读性是一个改善，因为到处都是圆括号的话，确实有点太单调，容易打瞌睡。 另外，Racket 程序的最上面都需要加上像 #lang racket 这样的语言选择标记，这样 Racket 才可以知道你想用哪个语言变种。 解释器是什么准备工作就到这里。现在我来谈一下，解释器到底是什么。说白了，解释器跟计算器差不多。解释器是一个函数，你输入一个“表达式”，它就输出一个 “值”，像这样： 比如，你输入表达式 ‘(+ 1 2) ，它就输出值，整数3。表达式是一种“表象”或者“符号”，而值却更加接近“本质”或者“意义”。我们“解释”了符号，得到它的意义，这也许就是为什么它叫做“解释器”。 需要注意的是，表达式是一个数据结构，而不是一个字符串。我们用一种叫“S 表达式”（S-expression）的结构来存储表达式。比如表达式 ‘(+ 1 2) 其实是一个链表（list），它里面的内容是三个符号（symbol）：+, 1 和 2，而不是字符串”(+ 1 2)”。 从 S 表达式这样的“结构化数据”里提取信息，方便又可靠，而从字符串里提取信息，麻烦而且容易出错。Scheme（Lisp）语言里面大量使用结构化数据，少用字符串，这是 Lisp 系统比 Unix 系统先进的地方之一。 从计算理论的角度讲，每个程序都是一台机器的“描述”，而解释器就是在“模拟”这台机器的运转，也就是在进行“计算”。所以从某种意义上讲，解释器就是计算的本质。当然，不同的解释器就会带来不同的计算。 CPU 也是一个解释器，它专门解释执行机器语言。如果你深刻理解了解释器，就可以从本质上看出各种 CPU 的设计为什么是那个样子，它们有什么优缺点，而不只是被动的作为它们的使用者。 抽象语法树（Abstract Syntax Tree）用 S 表达式所表示的代码，本质上是一种叫做“树”（tree）的数据结构。更具体一点，这叫做“抽象语法树”（Abstract Syntax Tree，简称 AST）。下文为了简洁，我们省略掉“抽象”两个字，就叫它“语法树”。 跟普通的树结构一样，语法树里的节点，要么是一个“叶节点”，要么是一颗“子树”。叶节点是不能再细分的“原子”，比如数字，字符串，操作符，变量名。而子树是可以再细分的“结构”，比如算术表达式，函数定义，函数调用，等等。 举个简单的例子，表达式 ‘(* (+ 1 2) (+ 3 4))，就对应如下的语法树结构： 其中，*，两个+，1，2，3，4 都是叶节点，而那三个红色节点，都表示子树结构：&#39;(+ 1 2)，&#39;(+ 3 4)，&#39;(* (+ 1 2) (+ 3 4))。 树遍历算法在基础的数据结构课程里，我们都学过二叉树的遍历操作，也就是所谓先序遍历，中序遍历和后序遍历。语法树跟二叉树，其实没有很大区别，所以你也可以在它上面进行遍历。解释器的算法，就是在语法树上的一种遍历操作。由于这个渊源关系，我们先来做一个遍历二叉树的练习。做好了之后，我们就可以把这段代码扩展成一个解释器。 这个练习是这样：写出一个函数，名叫tree-sum，它对二叉树进行“求和”，把所有节点里的数加在一起，返回它们的和。举个例子，(tree-sum ‘((1 2) (3 4)))，执行后应该返回 10。注意：这是一颗二叉树，所以不会含有长度超过 2 的子树，你不需要考虑像 ((1 2) (3 4 5)) 这类情况。需要考虑的例子是像这样：(1 2)，(1 (2 3)), ((1 2) 3) ((1 2) (3 4))，…… （为了达到最好的学习效果，你最好试一下写出这个函数再继续往下看。） 好了，希望你得到了跟我差不多的结果。我的代码是这个样子： 12345678910#lang racket(define tree-sum (lambda (exp) (match exp ; 对输入exp进行模式匹配 [(? number? x) x] ; exp是一个数x吗？如果是，那么返回这个数x [`(,e1 ,e2) ; exp是一个含有两棵子树的中间节点吗？ (let ([v1 (tree-sum e1)] ; 递归调用tree-sum自己，对左子树e1求值 [v2 (tree-sum e2)]) ; 递归调用tree-sum自己，对右子树e2求值 (+ v1 v2))]))) ; 返回左右子树结果v1和v2的和 你可以通过以下的例子来测试它的正确性：12345678(tree-sum '(1 2));; =&gt; 3(tree-sum '(1 (2 3)));; =&gt; 6(tree-sum '((1 2) 3));; =&gt; 6(tree-sum '((1 2) (3 4)));; =&gt; 10 （完整的代码和示例，可以在这里下载。） 这个算法很简单，我们可以把它用文字描述如下： 如果输入 exp 是一个数，那就返回这个数。 否则如果 exp 是像 (,e1 ,e2) 这样的子树，那么分别对 e1 和 e2 递归调用 tree-sum，进行求和，得到 v1 和 v2，然后返回 v1 + v2 的和。 你自己写出来的代码，也许用了 if 或者 cond 语句来进行分支，而我的代码里面使用的是 Racket 的模式匹配（match）。这个例子用 if 或者 cond 其实也可以，但我之后要把这代码扩展成一个解释器，所以提前使用了 match。这样跟后面的代码对比的时候，就更容易看出规律来。接下来，我就简单讲一下这个 match 表达式的工作原理。 模式匹配现在不得不插入一点 Racket 的技术细节，如果你已经学会使用 Racket 的模式匹配，可以跳过这一节。你也可以通过阅读 Racket 模式匹配的文档来代替这一节。但我建议你不要读太多文档，因为我接下去只用到很少的模式匹配功能，我把它们都解释如下。 模式匹配的形式一般是这样： 12345(match x [模式 结果] [模式 结果] ... ...) 它先对 x 求值，然后根据值的结构来进行分支。每个分支由两部分组成，左边是一个模式，右边是一个结果。整个 match 语句的语义是这样：从上到下依次考虑，找到第一个可以匹配 x 的值的模式，返回它右边的结果。左边的模式在匹配之后，可能会绑定一些变量，这些变量可以在右边的表达式里使用。 模式匹配是一种分支语句，它在逻辑上就是 Scheme（Lisp） 的 cond 表达式，或者 Java 的嵌套条件语句 if … else if … else …。然而跟条件语句里的“条件”不同，每条 match 语句左边的模式，可以准确而形象地描述数据结构的形状，而且可以在匹配的同时，对结构里的成员进行“绑定”。这样我们可以在右边方便的访问结构成员，而不需要使用访问函数（accessor）或者 foo.x 这样的属性语法（attribute）。而且模式可以有嵌套的子结构，所以它能够一次性的表示复杂的数据结构。 举个实在点的例子。我的代码里用了这样一个 match 表达式： 123456(match exp [(? number? x) x] [`(,e1 ,e2) (let ([v1 (tree-sum e1)] [v2 (tree-sum e2)]) (+ v1 v2))]) 第二行里面的 ‘(,e1 ,e2) 是一个模式（pattern），它被用来匹配 exp 的值。如果 exp 是 ‘(1 2)，那么它与’(,e1 ,e2)匹配的时候，就会把 e1 绑定到 ‘1，把 e2 绑定到 ‘2。这是因为它们结构相同： 12`(,e1 ,e2)'( 1 2) 说白了，模式就是一个可以含有“名字”（像 e1 和 e2）的结构，像 ‘(,e1 ,e2)。我们拿这个带有名字的结构，去匹配实际数据，像 ‘(1 2)。当它们一一对应之后，这些名字就被绑定到数据里对应位置的值。 第一行的“模式”比较特殊，(? number? x) 表示的，其实是一个普通的条件判断，相当于 (number? exp)，如果这个条件成立，那么它把 exp 的值绑定到 x，这样右边就可以用 x 来指代 exp。对于无法细分的结构（比如数字，布尔值），你只能用这种方式来“匹配”。看起来有点奇怪，不过习惯了就好了。 模式匹配对解释器和编译器的书写相当有用，因为程序的语法树往往具有嵌套的结构。不用模式匹配的话，往往要写冗长，复杂，不直观的代码，才能描述出期望的结构。而且由于结构的嵌套比较深，很容易漏掉边界情况，造成错误。模式匹配可以直观的描述期望的结构，避免漏掉边界情况，而且可以方便的访问结构成员。 由于这个原因，很多源于 ML 的语言（比如 OCaml，Haskell）都有模式匹配的功能。因为 ML（Meta-Language）原来设计的用途，就是用来实现程序语言的。Racket 的模式匹配也是部分受了 ML 的启发，实际上它们的原理是一模一样的。 好了，树遍历的练习就做到这里。然而这跟解释器有什么关系呢？下面我们只把它改一下，就可以得到一个简单的解释器。 一个计算器计算器也是一种解释器，只不过它只能处理算术表达式。我们的下一个目标，就是写出一个计算器。如果你给它 ‘(* (+ 1 2) (+ 3 4))，它就输出 21。可不要小看这个计算器，稍后我们把它稍加改造，就可以得到一个更多功能的解释器。 上面的代码里，我们利用递归遍历，对树里的数字求和。那段代码里，其实已经隐藏了一个解释器的框架。你观察一下，一个算术表达式&#39;(* (+ 1 2) (+ 3 4))，跟二叉树&#39;((1 2) (3 4))有什么不同？发现没有，这个算术表达式比起二叉树，只不过在每个子树结构里多出了一个操作符：一个 * 和两个 + 。它不再是一棵二叉树，而是一种更通用的树结构。 这点区别，也就带来了二叉树求和与解释器算法的区别。对二叉树进行求和的时候，在每个子树节点，我们都做加法。而对表达式进行解释的时候，在每一个子树节点，我们不一定进行加法。根据子树的“操作符”不同，我们可能会选择加，减，乘，除四种操作。 好了，下面就是这个计算器的代码。它接受一个表达式，输出一个数字作为结果。 1234567891011121314#lang racket ; 声明用 Racket 语言(define calc (lambda (exp) (match exp ; 分支匹配：表达式的两种情况 [(? number? x) x] ; 是数字，直接返回 [`(,op ,e1 ,e2) ; 匹配提取操作符op和两个操作数e1,e2 (let ([v1 (calc e1)] ; 递归调用 calc 自己，得到 e1 的值 [v2 (calc e2)]) ; 递归调用 calc 自己，得到 e2 的值 (match op ; 分支匹配：操作符 op 的 4 种情况 ['+ (+ v1 v2)] ; 如果是加号，输出结果为 (+ v1 v2) ['- (- v1 v2)] ; 如果是减号，乘号，除号，相似的处理 ['* (* v1 v2)] ['/ (/ v1 v2)]))]))) 你可以得到如下的结果：123456(calc '(+ 1 2));; =&gt; 3(calc '(* 2 3));; =&gt; 6(calc '(* (+ 1 2) (+ 3 4)));; =&gt; 21 （完整的代码和示例，可以在这里下载。） 跟之前的二叉树求和代码比较一下，你会发现它们惊人的相似，因为解释器本来就是一个树遍历算法。不过你发现它们有什么不同吗？它们的不同点在于： 算术表达式的模式里面，多出了一个“操作符”（op）叶节点：(,op ,e1 ,e2) 对子树 e1 和 e2 分别求值之后，我们不是返回 (+ v1 v2)，而是根据 op 的不同，返回不同的结果： 12345(match op ['+ (+ v1 v2)] ['- (- v1 v2)] ['* (* v1 v2)] ['/ (/ v1 v2)]) 最后你发现，一个算术表达式的解释器，不过是一个稍加扩展的树遍历算法。 R2：一个很小的程序语言实现了一个计算器，现在让我们过渡到一种更强大的语言。为了方便称呼，我给它起了一个萌萌哒名字，叫 R2。R2 比起之前的计算器，只多出四个元素，它们分别是：变量，函数，绑定，调用。再加上之前介绍的算术操作，我们就得到一个很简单的程序语言，它只有5种不同的构造。用 Scheme 的语法，这5种构造看起来就像这样： 变量：x 函数：(lambda (x) e) 绑定：(let ([x e1]) e2) 调用：(e1 e2) 算术：(• e2 e2) （其中，• 是一个算术操作符，可以选择 +, -, *, / 其中之一）一般程序语言还有很多其它构造，可是一开头就试图去实现所有那些，只会让人糊涂。最好是把这少数几个东西搞清楚，确保它们正确之后，才慢慢加入其它元素。 这些构造的语义，跟 Scheme 里面的同名构造几乎一模一样。如果你不清楚什么是”绑定“，那你可以把它看成是普通语言里的”变量声明“。 需要注意的是，跟一般语言不同，我们的函数只接受一个参数。这不是一个严重的限制，因为在我们的语言里，函数可以被作为值传递，也就是所谓“first-class function”。所以你可以用嵌套的函数定义来表示有两个以上参数的函数。 举个例子， (lambda (x) (lambda (y) (+ x y))) 是个嵌套的函数定义，它也可以被看成是有两个参数（x 和 y）的函数，这个函数返回 x 和 y 的和。当这样的函数被调用的时候，需要两层调用，就像这样： 12(((lambda (x) (lambda (y) (+ x y))) 1) 2);; =&gt; 3 这种做法在PL术语里面，叫做柯里化（currying）。看起来啰嗦，但这样我们的解释器可以很简单。等我们理解了基本的解释器，再实现真正的多参数函数也不迟。 另外，我们的绑定语法 (let ([x e1]) e2)，比起 Scheme 的绑定也有一些局限。我们的 let 只能绑定一个变量，而 Scheme 可以绑定多个，像这样 (let ([x 1] [y 2]) (+ x y))。这也不是一个严重的限制，因为我们可以啰嗦一点，用嵌套的 let 绑定： 123(let ([x 1]) (let ([y 2]) (+ x y))) R2 的解释器下面是我们今天要完成的解释器，它可以运行一个 R2 程序。你可以先留意一下各部分的注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#lang racket;;; 以下三个定义 env0, ext-env, lookup 是对环境（environment）的基本操作：;; 空环境(define env0 '());; 扩展。对环境 env 进行扩展，把 x 映射到 v，得到一个新的环境(define ext-env (lambda (x v env) (cons `(,x . ,v) env)));; 查找。在环境中 env 中查找 x 的值。如果没找到就返回 #f(define lookup (lambda (x env) (let ([p (assq x env)]) (cond [(not p) #f] [else (cdr p)]))));; 闭包的数据结构定义，包含一个函数定义 f 和它定义时所在的环境(struct Closure (f env));; 解释器的递归定义（接受两个参数，表达式 exp 和环境 env）;; 共 5 种情况（变量，函数，绑定，调用，数字，算术表达式）(define interp (lambda (exp env) (match exp ; 对exp进行模式匹配 [(? symbol? x) ; 变量 (let ([v (lookup x env)]) (cond [(not v) (error \"undefined variable\" x)] [else v]))] [(? number? x) x] ; 数字 [`(lambda (,x) ,e) ; 函数 (Closure exp env)] [`(let ([,x ,e1]) ,e2) ; 绑定 (let ([v1 (interp e1 env)]) (interp e2 (ext-env x v1 env)))] [`(,e1 ,e2) ; 调用 (let ([v1 (interp e1 env)] [v2 (interp e2 env)]) (match v1 [(Closure `(lambda (,x) ,e) env-save) (interp e (ext-env x v2 env-save))]))] [`(,op ,e1 ,e2) ; 算术表达式 (let ([v1 (interp e1 env)] [v2 (interp e2 env)]) (match op ['+ (+ v1 v2)] ['- (- v1 v2)] ['* (* v1 v2)] ['/ (/ v1 v2)]))])));; 解释器的“用户界面”函数。它把 interp 包装起来，掩盖第二个参数，初始值为 env0(define r2 (lambda (exp) (interp exp env0))) 这里有一些测试例子： 123456789101112131415161718192021222324252627(r2 '(+ 1 2));; =&gt; 3(r2 '(* 2 3));; =&gt; 6(r2 '(* 2 (+ 3 4)));; =&gt; 14(r2 '(* (+ 1 2) (+ 3 4)));; =&gt; 21(r2 '((lambda (x) (* 2 x)) 3));; =&gt; 6(r2'(let ([x 2]) (let ([f (lambda (y) (* x y))]) (f 3))));; =&gt; 6(r2'(let ([x 2]) (let ([f (lambda (y) (* x y))]) (let ([x 4]) (f 3)))));; =&gt; 6 （完整的代码和示例，可以在这里下载。) 在接下来的几节，我们来仔细看看这个解释器的各个部分。 对基本算术操作的解释算术操作一般都是程序里最基本的构造，它们不能再被细分为多个步骤，所以我们先来看看对算术操作的处理。以下就是 R2 解释器处理算术的部分，它是 interp 的最后一个分支。 12345678910(match exp ... ... [`(,op ,e1 ,e2) (let ([v1 (interp e1 env)] ; 递归调用 interp 自己，得到 e1 的值 [v2 (interp e2 env)]) ; 递归调用 interp 自己，得到 e2 的值 (match op ; 分支：处理操作符 op 的 4 种情况 ['+ (+ v1 v2)] ; 如果是加号，输出结果为 (+ v1 v2) ['- (- v1 v2)] ; 如果是减号，乘号，除号，相似的处理 ['* (* v1 v2)] ['/ (/ v1 v2)]))]) 你可以看到它几乎跟刚才写的计算器一模一样，不过现在 interp 的调用多了一个参数 env 而已。这个 env 是所谓“环境”，我们下面很快就讲。 对数字的解释对数字的解释很简单，把它们原封不动返回就可以了。 1[(? number? x) x] 变量和函数变量和函数是解释器里最麻烦的部分，所以我们来仔细看看。 变量（variable）的产生，是数学史上的最大突破之一。因为变量可以被绑定到不同的值，从而使函数的实现成为可能。比如数学函数 f(x) = x * 2，其中 x 是一个变量，它把输入的值传递到函数体 x * 2 里面。如果没有变量，函数就不可能实现。 对变量最基本的操作，是对它的“绑定”（binding）和“取值”（evaluate）。什么是绑定呢？拿上面的函数 f(x) 作为例子。当我们调用 f(1) 时，函数体里面的 x 等于 1，所以x *2的值是 2，而当我们调用 f(2) 时，函数体里面的 x 等于 2，所以 x* 2 的值是 4。这里，两次对 f 的调用，分别对 x 进行了两次绑定。第一次 x 被绑定到了 1，第二次被绑定到了 2。 你可以把“绑定”理解成这样一个动作，就像当你把插头插进电源插座的那一瞬间。插头的插脚就是 f(x) 里面的那个 x，而 x * 2 里面的 x，则是电线的另外一端。所以当你把插头插进插座，电流就通过这根电线到达另外一端。如果电线导电性能良好，两头的电压应该相等。 环境我们的解释器只能一步一步的做事情。比如，当它需要求 f(1) 的值的时候，它分成两步操作： 把 x 绑定到 1，这样函数体内才能看见这个绑定。 进入 f 的函数体，对 x * 2 进行求值。 这就像一个人做出这两个动作： 把插头插进插座 。 到电线的另外一头，测量它的电压，并且把结果乘以 2。 在第一步和第二步之间，我们如何记住 x 的值呢？通过所谓“环境”！我们用环境记录变量的值，并且把它们传递到变量的“可见区域”。变量的可见区域，用术语说叫做“作用域”（scope）。 在我们的解释器里，用于处理环境的代码如下： 123456789101112131415;; 空环境(define env0 '());; 对环境 env 进行扩展，把 x 映射到 v(define ext-env (lambda (x v env) (cons `(,x . ,v) env)));; 取值。在环境中 env 中查找 x 的值(define lookup (lambda (x env) (let ([p (assq x env)]) (cond [(not p) #f] [else (cdr p)])))) 这里我们用一种最简单的数据结构，Scheme 的 association list，来表示环境。Association list 看起来像这个样子：((x . 1) (y . 2) (z . 5))。它是一个两元组（pair）的链表，左边的元素是 key，右边的元素是 value。写得直观一点就是： 123((x . 1) (y . 2) (z . 5)) 查表操作就是从头到尾搜索，如果左边的 key 是要找的变量，就返回整个 pair。简单吧？效率很低，但是足够完成我们现在的任务。 ext-env 函数扩展一个环境。比如，如果原来的环境 env1 是 ((y . 2) (x . 1)) 那么 (ext-env x 3 env1)，就会返回 ((x . 3) (y . 2) (x . 1))。也就是把 (x . 3) 加到 env1 的最前面去。 那我们什么时候需要扩展环境呢？当我们进行绑定的时候。绑定可能出现在函数调用时，也可能出现在 let 绑定时。我们选择的数据结构，使得环境自然而然的具有了作用域（scope）的特性。 环境其实是一个堆栈（stack）。内层的绑定，会出现在环境的最上面，这就是在“压栈”。这样我们查找变量的时候，会优先找到最内层定义的变量。 举个例子： 12345(let ([x 1]) ; env='()。绑定x到1。 (let ([y 2]) ; env='((x . 1))。绑定y到2。 (let ([x 3]) ; env='((y . 2) (x . 1))。绑定x到3。 (+ x y)))) ; env='((x . 3) (y . 2) (x . 1))。查找x，得到3；查找y，得到2。;; =&gt; 5 这段代码会返回5。这是因为最内层的绑定，把 (x . 3) 放到了环境的最前面，这样查找 x 的时候，我们首先看到 (x . 3)，然后就返回值3。之前放进去的 (x . 1) 仍然存在，但是我们先看到了最上面的那个(x . 3)，所以它被忽略了。 这并不等于说 (x . 1) 就可以被改写或者丢弃，因为它仍然是有用的。你只需要看一个稍微不同的例子，就知道这是怎么回事： 12345(let ([x 1]) ; env='()。绑定x到1。 (+ (let ([x 2]) ; env='((x . 1))。绑定x到2。 x) ; env='((x . 2) (x . 1))。查找x，得到2。 x)) ; env='((x . 1))。查找x，得到1。;; =&gt; 3 ; 两个不同的x的和，1+2等于3。 这个例子会返回3。它是第3行和第4行里面两个 x 的和。由于第3行的 x 处于内层 let 里面，那里的环境是 ((x . 2) (x . 1))，所以查找 x 的值得到2。第4行的 x 在内层 let 外面，但是在外层 let 里面，那里的环境是 ((x . 1))，所以查找 x 的值得到1。这很符合直觉，因为 x 总是找到最内层的定义。 值得注意的是，环境被扩展以后，形成了一个新的环境，而原来的环境并没有被改变。比如，上面的 ((y . 2) (x . 1)) 并没有删除或者修改，只不过是被“引用”到一个更大的列表里去了。 这样不对已有数据进行修改（mutation）的数据结构，叫做“函数式数据结构”。函数式数据结构只生成新的数据，而不改变或者删除老的。它可能引用老的结构，然而却不改变老的结构。这种“不修改”（immutable）的性质，在我们的解释器里是很重要的，因为当我们扩展一个环境，进入递归，返回之后，外层的代码必须仍然可以访问原来外层的环境。 当然，我们也可以用另外的，更高效的数据结构（比如平衡树，串接起来的哈希表）来表示环境。如果你学究一点，甚至可以用函数来表示环境。这里为了代码简单，我们选择了最笨，然而正确，容易理解的数据结构。 对变量的解释了解了变量，函数和环境，我们来看看解释器对变量的“取值”操作，也就是 match 的第一种情况。 [(? symbol? x) (lookup x env)] 这就是在环境中，沿着从内向外的“作用域顺序”，查找变量的值。 这里的 (? symbol? x) 是一种特殊的模式，它使用 Scheme 函数 symbol? 来判断输入是否是一个符号，如果是，就把它绑定到 x，然后你就可以在右边用 x 来指称这个输入。 对绑定的解释现在我们来看看对 let 绑定的解释： 123[`(let ([,x ,e1]) ,e2) (let ([v1 (interp e1 env)]) ; 解释右边表达式e1，得到值v1 (interp e2 (ext-env x v1 env)))] ; 把(x . v1)扩充到环境顶部，对e2求值 通过代码里的注释，你也许已经可以理解它在做什么。我们先对表达式 e1 求值，得到 v1。然后我们把 (x . v1) 扩充到环境里，这样 (let ([x e1]) …) 内部都可以看到 x 的值。然后我们使用这个扩充后的环境，递归调用解释器本身，对 let 的主体 e2 求值。它的返回值就是这个 let 绑定的值。 Lexical Scoping 和 Dynamic Scoping下面我们准备谈谈函数定义和调用。对函数的解释是一个微妙的问题，很容易弄错，这是由于函数体内也许会含有外层的变量，叫做“自由变量”。所以在分析函数的代码之前，我们来了解一下不同的“作用域”（scoping）规则。 我们举个例子来解释这个问题。下面这段代码，它的值应该是多少呢？ 1234(let ([x 2]) (let ([f (lambda (y) (* x y))]) (let ([x 4]) (f 3)))) 在这里，f 函数体 (lambda (y) (* x y)) 里的那个 x，就是一个“自由变量”。x 并不是这个函数的参数，也不是在这个函数里面定义的，所以我们必须到函数外面去找 x 的值。 我们的代码里面，有两个地方对 x 进行了绑定，一个等于2，一个等于4，那么 x 到底应该是指向哪一个绑定呢？这似乎无关痛痒，然而当我们调用 (f 3) 的时候，严重的问题来了。f 的函数体是 (* x y)，我们知道 y 的值来自参数 3，可是 x 的值是多少呢？它应该是2，还是4呢？ 在历史上，这段代码可能有两种不同的结果，这种区别一直延续到今天。如果你在 Scheme （Racket）里面写以上的代码，它的结果是6。 1234567;; Scheme(let ([x 2]) (let ([f (lambda (y) (* x y))]) (let ([x 4]) (f 3))));; =&gt; 6 现在我们来看看，在 Emacs Lisp 里面输入等价的代码，得到什么结果。如果你不熟悉 Emacs Lisp 的用法，那你可以跟我做：把代码输入 Emacs 的那个叫 scratch 的 buffer。把光标放在代码最后，然后按 C-x C-e，这样 Emacs 会执行这段代码，然后在 minibuffer 里显示结果： 结果是12！如果你把代码最内层的 x 绑定修成其它的值，输出会随之改变。 奇怪吧？Scheme 和 Emacs Lisp，到底有什么不一样呢？实际上，这两种看似差不多的 “Lisp 方言”，采用了两种完全不同的作用域方式。Scheme 的方式叫做 lexical scoping （或者 static scoping），而 Emacs 的方式叫做 dynamic scoping。 那么哪一种方式更好呢？或者用哪一种都无所谓？答案是，dynamic scoping 是非常错误的做法。历史的教训告诉我们，它会带来许许多多莫名其妙的 bug，导致 dynamic scoping 的语言几乎完全没法用。这是为什么呢？ 原因在于，像 (let ((x 4)) …) 这样的变量绑定，只应该影响它内部“看得见”的 x 的值。当我们看见 (let ((x 4)) (f 3)) 的时候，并没有在 let 的内部看见任何叫“x” 的变量，所以我们“直觉”的认为，(let ((x 4)) …) 对 x 的绑定，不应该引起 (f 3) 的结果变化。 然而对于 dynamic scoping，我们的直觉却是错误的。因为 f 的函数体里面有一个 x，虽然我们没有在 (f 3) 这个调用里面看见它，然而它却存在于 f 定义的地方。要知道，f 定义的地方也许隔着几百行代码，甚至在另外一个文件里面。而且调用函数的人凭什么应该知道， f 的定义里面有一个自由变量，它的名字叫做 x？所以 dynamic scoping 在设计学的角度来看，是一个反人类的设计 :) 相反，lexical scoping 却是符合人们直觉的。虽然在 (let ((x 4)) (f 3)) 里面，我们把 x 绑定到了 4，然而 f 的函数体并不是在那里定义的，我们也没在那里看见任何 x，所以 f 的函数体里面的 x，仍然指向我们定义它的时候看得见的那个 x，也就是最上面的那个 (let ([x 2]) …)，它的值是 2。所以 (f 3) 的值应该等于 6，而不是12。 对函数的解释为了实现 lexical scoping，我们必须把函数做成“闭包”（closure）。闭包是一种特殊的数据结构，它由两个元素组成：函数的定义和当前的环境。我们把闭包定义为一个 Racket 的 struct 结构： 1(struct Closure (f env)) 有了这个数据结构，我们对 (lambda (x) e) 的解释就可以写成这样： 12[`(lambda (,x) ,e) (Closure exp env)] 注意这里的 exp 就是 (lambda (,x) ,e)` 自己。 有意思的是，我们的解释器遇到 (lambda (x) e)，几乎没有做任何计算。它只是把这个函数包装了一下，把它与当前的环境一起，打包放到一个数据结构（Closure）里面。这个闭包结构，记录了我们在函数定义的位置“看得见”的那个环境。稍候在调用的时候，我们就能从这个闭包的环境里面，得到函数体内的自由变量的值。 对调用的解释好了，我们终于到了最后的关头，函数调用。为了直观，我们把函数调用的代码拷贝如下： 123456[`(,e1 ,e2) (let ([v1 (interp e1 env)] ; 计算函数 e1 的值 [v2 (interp e2 env)]) ; 计算参数 e2 的值 (match v1 [(Closure `(lambda (,x) ,e) env-save) ; 用模式匹配的方式取出闭包里的各个子结构 (interp e (ext-env x v2 env-save))]))] ; 在闭包的环境env-save中把x绑定到v2，解释函数体 函数调用都是 (e1 e2) 这样的形式，e1 表示函数，e2 是它的参数。我们需要先分别求出函数 e1 和参数 e2 的值。 函数调用就像把一个电器的插头插进插座，使它开始运转。比如，当 (lambda (x) ( x 2)) 被作用于 1 时，我们把 x 绑定到 1，然后解释它的函数体 ( x 2)。但是这里有一个问题，函数体内的自由变量应该取什么值呢？从上面闭包的讨论，你已经知道了，自由变量的值，应该从闭包的环境查询。 操作数 e1 的值 v1 是一个闭包，它里面包含一个函数定义时保存的环境 env-save。我们把这个环境 env-save 取出来，那我们就可以查询它，得到函数体内自由变量的值。然而函数体内不仅有自由变量，还有对函数参数的使用，所以我们必须扩展这个 env-save 环境，把参数的值加进去。这就是为什么我们使用 (ext-env x v2 env-save)，而不只是 env-save。 你可能会奇怪，那么解释器的环境 env 难道这里就不用了吗？是的。我们通过 env 来计算 e1 和 e2 的值，是因为 e1 和 e2 里面的变量，在“当前环境”（env）里面看得见。可是函数体的定义，在当前环境下是看不见的。它的代码在别的地方，而那个地方看得见的环境，被我们存在闭包里了，它就是 env-save。所以我们把 v1 里面的闭包环境 env-save 取出来，用于计算函数体的值。 有意思的是，如果我们用 env，而不是env-save 来解释函数体，那我们的语言就变成了 dynamic scoping。现在来实验一下：你可以把 (interp e (ext-env x v2 env-save)) 里面的 env-save 改成 env，再试试我们之前讨论过的代码，它的输出就会变成 12。那就是我们之前讲过的，dynamic scoping 的结果。 1234567(r2'(let ([x 2]) (let ([f (lambda (y) (* x y))]) (let ([x 4]) (f 3)))));; =&gt; 12 你也许发现了，如果我们的语言是 dynamic scoping，那就没必要使用闭包了，因为我们根本不需要闭包里面保存的环境。这样一来，dynamic scoping 的解释器就可以写成这样： 123456789101112131415(define interp (lambda (exp env) (match exp ... ... [`(lambda (,x) ,e) ; 函数：直接返回自己的表达式 exp] ... ... [`(,e1 ,e2) (let ([v1 (interp e1 env)] [v2 (interp e2 env)]) (match v1 [`(lambda (,x) ,e) ; 调用：直接使用函数的表达式本身 (interp e (ext-env x v2 env))]))] ... ...))) 注意到这个解释器的函数有多容易实现吗？它就是这个函数的表达式自己，原封不动。用函数的表达式本身来表示它的值，是很直接很简单的做法，也是大部分人一开头就会想到的。然而这样实现出来的语言，就不知不觉地采用了 dynamic scoping。 这就是为什么很多早期的 Lisp 语言，比如 Emacs Lisp，都使用 dynamic scoping。这并不是因为它们的设计者在 dynamic scoping 和 lexical scoping 两者之中做出了选择，而是因为使用函数的表达式本身来作为它的值，是最直接，一般人都会首先想到的做法。 另外，在这里我们也看到环境用“函数式数据结构”表示的好处。闭包被调用时它的环境被扩展，但是这并不会影响原来的那个环境，我们得到的是一个新的环境。所以当函数调用返回之后，函数的参数绑定就自动“注销”了。 如果你用一个非函数式的数据结构，在绑定参数时不生成新的环境，而是对已有环境进行赋值，那么这个赋值操作就会永久性的改变原来环境的内容。所以你在函数返回之后必须删除参数的绑定。这样不但麻烦，而且在复杂的情况下很容易出错。 思考题：可能有些人看过 lambda calculus，这些人可能知道 (let ([x e1]) e2) 其实等价于一个函数调用：((lambda (x) e2) e1)。现在问题来了，我们在讨论函数和调用的时候，很深入的讨论了关于 lexical scoping 和 dynamic scoping 的差别。既然 let 绑定等价于一个函数定义和调用，为什么之前我们讨论对绑定的时候，没有讨论过 lexical scoping 和 dynamic scoping 的问题，也没有制造过闭包呢？ 不足之处现在你已经学会了如何写出一个简单的解释器，它可以处理一个相当强大的函数式语言。出于教学的考虑，这个解释器并没有考虑实用的需求，所以它并不能作为工业应用。在这里，我指出它的一些不足之处。 缺少必要的语言构造。我们的语言里缺少好些实用语言必须的构造：递归，数组，赋值操作，字符串，自定义数据结构，…… 作为一篇基础性的读物，我不能把这些都加进来。如果你对这些有兴趣，可以看看其它书籍，或者等待我的后续作品。 不合法代码的检测和报告。你也许发现了，这个解释器的 match 表达式，全都假定了输入都是合法的程序，它并没有检查不合法的情况。如果你给它一个不合法的程序，它不会马上报错，而是会真去算它，以至于导致奇怪的后果。一个实用的解释器，必须加入对代码格式进行全面检测，在运行之前就报告不合法的代码结构。 低效率的数据结构。在 association list 里面查找变量，是线性的复杂度。当程序有很多变量的时候就有性能问题。一个实用的解释器，需要更高效的数据结构。这种数据结构不一定非得是函数式的。你也可以用非函数式的数据结构（比如哈希表），经过一定的改造，达到同样的性质，却具有更高的效率。 ​ 另外，你还可以把环境转化成一个数组。给环境里的每个变量分配一个下标（index），在这个数组里就可以找到它的值。如果你用数组表示环境，那么这个解释器就向编译器迈进了一步。 S 表达式的歧义问题。为了教学需要，我们的解释器直接使用 S 表达式来表达语法树，用模式匹配来进行分支遍历。在实际的语言里，这种方式会带来比较大的问题。因为 S 表达式是一种通用的数据结构，用它表示的东西，看起来都差不多的样子。一旦程序的语法构造多起来，直接对 S 表达式进行模式匹配，会造成歧义。 ​ 比如 (,op ,e1 ,e2) ，你以为它只匹配二元算术操作，比如 (+ 1 2)。但它其实也可以匹配一个 let 绑定： (let ([x 1]) (* x 2))。这是因为它们顶层元素的数目是一样的。为了消除歧义，你得小心的安排模式的顺序，比如你必须把 (let ([,x ,e1]) ,e2) 的模式放在 (,op ,e1, e2) 前面。所以最好的办法，是不要直接在 S 表达式上写解释器，而是先写一个“parser”，这个 parser 把 S 表达式转换成 Racket 的 struct 结构。然后解释器再在 struct 上面进行分支匹配。这样解释器不用担心歧义问题，而且会带来效率的提升。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell.github.io/tags/笔记/"},{"name":"转载","slug":"转载","permalink":"http://londbell.github.io/tags/转载/"}]},{"title":"zsh alias折腾记录","date":"2020-02-14T08:50:30.000Z","path":"2020/02/14/zsh-alias/","text":"zsh可以自定义alias，它的alias有很多类型，非常灵活。 zsh which aliaszsh提供了一个方法来确认某个alias真正指代的指令： 1which ll 在我的zsh上，他会输出： 1ll: aliased to la -l 所以想确认这个alias指代了什么，使用which即可。 基础alias比如说最简单的： 1alias ll='ls -al' 注意=两边不要有空格，后面最好用单引号&#39;来包裹要表达的语句。 但这种alias功能相对简单，要缩写的复杂语句无法表达。例如我想要通过一个alias将每个git分支都同步远程的最新代码(参考stackoverflow) 1git branch -r | grep -v '\\-&gt;' | while read remote;do git branch --track \"$&#123;remote#origin/&#125;\" \"$remote\";done 由于原指令中有额外的其他字符，是无法使用简单的alias形式来表示。我们需要更强大的alias语法支持。 函数alias函数alias其实很好理解，这时候alias就是一个function，还可以传递参数： 123function vnc() &#123; open vnc://\"$USER\"@\"$1\"&#125; 换言之，上面提到的git alias可以写成： 123function gua() &#123; git branch -r | grep -v '\\-&gt;' | while read remote;do git branch --track \"$&#123;remote#origin/&#125;\" \"$remote\";done&#125; 我们使用which来查看gua： 12345678which guagua () &#123; git branch -r | grep --color=auto -v '\\-&gt;' | while read remote do git branch --track \"$&#123;remote#origin/&#125;\" \"$remote\" done&#125; 实际上在我使用这种方式的时候，因为粗心大意，触发了以下的问题，这里记录下来，以后不要再踩坑了。 错误定义函数alias刚开始使用函数alias时，因为没有仔细看语法，下意识的以为语法是这样的： 123alias vnc() &#123; open vnc://\"$USER\"@\"$1\"&#125; 即我以为前缀依然还是alias 于是我的gua alias就变成了这样： 123alias gua() &#123; git branch -r | grep -v '\\-&gt;' | while read remote;do git branch --track \"$&#123;remote#origin/&#125;\" \"$remote\";done&#125; 于是每次开机的时候，gua()会自动执行…在我的终端上留下一堆错误信息： 这个问题困扰了我很久，后面才发现是语法错误了。因此我猜测写成alias就变成了js那种立即执行函数的形式。在这里提醒一下自己，以后务必要细心。 其实在上面的这个方法错误后，我在修正过程中，还使用了另外一种错误的形式： 123gua() &#123; git branch -r | grep -v '\\-&gt;' | while read remote;do git branch --track \"$&#123;remote#origin/&#125;\" \"$remote\";done&#125; 上面的写法去掉了alias，当然也没写function，在bash里面是行得通的，但是zsh不支持这么做，虽然打开终端的时候并不会出现上面的错误，但你实际执行的时候，会出现这个结果： 123guagit达到最大嵌套功能级别 具体可以参考这篇文章，总之，正儿八经的使用function就不会出现问题。 全局alias这里我就不献丑了，大家直接去看这篇文章，就知道如何使用了。","tags":[{"name":"zsh","slug":"zsh","permalink":"http://londbell.github.io/tags/zsh/"},{"name":"alias","slug":"alias","permalink":"http://londbell.github.io/tags/alias/"},{"name":"shell","slug":"shell","permalink":"http://londbell.github.io/tags/shell/"}]},{"title":"MySQL 索引","date":"2017-04-10T10:32:39.000Z","path":"2017/04/10/MySQL-索引/","text":"原地址 Markdown后加入收藏，方便阅读 摘要本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。 文章主要内容分为三个部分。 第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。 第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。 第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。 数据结构及算法基础索引的本质MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。 我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 看一个例子： 图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在(O(log_2n))的复杂度内获取到相应数据。 虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。 B-Tree和B+Tree目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。 B-Tree为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构： d为大于1的一个正整数，称为B-Tree的度。 h为一个正整数，称为B-Tree的高度。 每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。 每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。 所有叶节点具有相同的深度，等于树高h。 key和指针互相间隔，节点两端是指针。 一个节点中的key从左到右非递减排列。 所有节点组成树结构。 每个指针要么为null，要么指向另外一个节点。 如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于(v(key_1))，其中(v(key_1))为node的第一个key的值。 如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于(v(key_m))，其中(v(key_m))为node的最后一个key的值。 如果某个指针在节点node的左右相邻key分别是(key_i)和(key_{i+1})且不为null，则其指向节点的所有key小于(v(key_{i+1}))且大于(v(key_i))。 图2是一个d=2的B-Tree示意图。 由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下： 1234567891011121314BTree_Search(node, key) &#123; if(node == null) return null; foreach(node.key) &#123; if(node.key[i] == key) &#123; return node.data[i]; &#125; if(node.key[i] &amp;gt; key) &#123; return BTree_Search(point[i]-&amp;gt;node); &#125; &#125; return BTree_Search(point[i+1]-&amp;gt;node);&#125;data = BTree_Search(root, my_key); 关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为(log_d((N+1)/2))，检索一个key，其查找节点个数的渐进复杂度为(O(log_dN))。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。 另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。 B+TreeB-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。 与B-Tree相比，B+Tree有以下不同点： 每个节点的指针上限为2d而不是2d+1。 内节点不存储data，只存储key；叶子节点不存储指针。 图3是一个简单的B+Tree示意。 由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。 一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。 带有顺序访问指针的B+Tree一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。 如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。 这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。 为什么使用B-Tree（B+Tree）上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。 主存存取原理目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。 从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。 主存的存取过程如下： 当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。 写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。 这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。 磁盘存取原理上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。 图6是磁盘的整体结构示意图。 一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。 图7是磁盘结构的示意图。 盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。 当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。 局部性原理与磁盘预读由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： 当一个数据被用到时，其附近的数据也通常会马上被使用。 程序运行期间所需要的数据通常比较集中。 由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。 预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。 B-/+Tree索引的性能分析到这里终于可以分析B-/+Tree索引的性能了。 上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧： 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。 B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为(O(h)=O(log_dN))。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。 综上所述，用B-Tree作为索引结构效率是非常高的。 而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。 上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小： (d_{max}=floor(pagesize / (keysize + datasize + pointsize))) floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。 这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。 MySQL索引实现在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。 MyISAM索引实现MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图： 这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示： 同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。 MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。 InnoDB索引实现虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。 第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。 第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引： 这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。 了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。 下一章将具体讨论这些与索引有关的优化策略。 索引使用策略及优化MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。 示例数据库为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）： MySQL官方文档中关于此数据库的页面为http://dev.mysql.com/doc/employee/en/employee.html。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。 最左前缀原理与相关优化高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。 这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …, an&gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。 以employees.titles表为例，下面先查看其上都有哪些索引： 123456789SHOW INDEX FROM employees.titles;+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+| titles | 0 | PRIMARY | 1 | emp_no | A | NULL | | BTREE || titles | 0 | PRIMARY | 2 | title | A | NULL | | BTREE || titles | 0 | PRIMARY | 3 | from_date | A | 443308 | | BTREE || titles | 1 | emp_no | 1 | emp_no | A | 443308 | | BTREE |+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+ 从结果中可以到titles表的主索引为&lt;emp_no, title, from_date&gt;，还有一个辅助索引&lt;emp_no&gt;。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉： 1ALTER TABLE employees.titles DROP INDEX emp_no; 这样就可以专心分析索引PRIMARY的行为了。 情况一：全列匹配123456EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title='Senior Engineer' AND from_date='1986-06-26';+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+| 1 | SIMPLE | titles | const | PRIMARY | PRIMARY | 59 | const,const,const | 1 | |+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+ 很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒： 123456EXPLAIN SELECT * FROM employees.titles WHERE from_date='1986-06-26' AND emp_no='10001' AND title='Senior Engineer';+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+| 1 | SIMPLE | titles | const | PRIMARY | PRIMARY | 59 | const,const,const | 1 | |+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+ 效果是一样的。 情况二：最左前缀匹配123456EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001';+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+| 1 | SIMPLE | titles | ref | PRIMARY | PRIMARY | 4 | const | 1 | |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+ 当查询条件精确匹配索引的左边连续一个或几个列时，如&lt;emp_no&gt;或&lt;emp_no, title&gt;，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。 情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。123456EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND from_date='1986-06-26';+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+| 1 | SIMPLE | titles | ref | PRIMARY | PRIMARY | 4 | const | 1 | Using where |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+ 此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no, from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。 首先我们看下title一共有几种不同的值： 123456789101112SELECT DISTINCT(title) FROM employees.titles;+--------------------+| title |+--------------------+| Senior Engineer || Staff || Engineer || Senior Staff || Assistant Engineer || Technique Leader || Manager |+--------------------+ 只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀： 123456789EXPLAIN SELECT * FROM employees.titlesWHERE emp_no='10001'AND title IN ('Senior Engineer', 'Staff', 'Engineer', 'Senior Staff', 'Assistant Engineer', 'Technique Leader', 'Manager')AND from_date='1986-06-26';+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| 1 | SIMPLE | titles | range | PRIMARY | PRIMARY | 59 | NULL | 7 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ 这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较： 1234567SHOW PROFILES;+----------+------------+-------------------------------------------------------------------------------+| Query_ID | Duration | Query |+----------+------------+-------------------------------------------------------------------------------+| 10 | 0.00058000 | SELECT * FROM employees.titles WHERE emp_no='10001' AND from_date='1986-06-26'|| 11 | 0.00052500 | SELECT * FROM employees.titles WHERE emp_no='10001' AND title IN ... |+----------+------------+-------------------------------------------------------------------------------+ “填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。 情况四：查询条件没有指定索引第一列123456EXPLAIN SELECT * FROM employees.titles WHERE from_date='1986-06-26';+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+| 1 | SIMPLE | titles | ALL | NULL | NULL | NULL | NULL | 443308 | Using where |+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+ 由于不是最左前缀，索引这样的查询显然用不到索引。 情况五：匹配某列的前缀字符串123456EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title LIKE 'Senior%';+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| 1 | SIMPLE | titles | range | PRIMARY | PRIMARY | 56 | NULL | 1 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ 此时可以用到索引，但是如果通配符不是只出现在末尾，则无法使用索引。（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀） 情况六：范围查询123456EXPLAIN SELECT * FROM employees.titles WHERE emp_no &amp;lt; '10010' and title='Senior Engineer';+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| 1 | SIMPLE | titles | range | PRIMARY | PRIMARY | 4 | NULL | 16 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ 范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。 123456789EXPLAIN SELECT * FROM employees.titlesWHERE emp_no &amp;lt; '10010'AND title='Senior Engineer'AND from_date BETWEEN '1986-01-01' AND '1986-12-31';+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| 1 | SIMPLE | titles | range | PRIMARY | PRIMARY | 4 | NULL | 16 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ 可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询： 123456789EXPLAIN SELECT * FROM employees.titlesWHERE emp_no BETWEEN '10001' AND '10010'AND title='Senior Engineer'AND from_date BETWEEN '1986-01-01' AND '1986-12-31';+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| 1 | SIMPLE | titles | range | PRIMARY | PRIMARY | 59 | NULL | 16 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ 看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。 情况七：查询条件中含有函数或表达式很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如： 1234567891011121314EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND left(title, 6)='Senior';+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+| 1 | SIMPLE | titles | ref | PRIMARY | PRIMARY | 4 | const | 1 | Using where |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+&lt;/pre&gt;虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：&lt;p&gt;&lt;pre class=\"prettyprint linenums\"&gt;EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1='10000';+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+| 1 | SIMPLE | titles | ALL | NULL | NULL | NULL | NULL | 443308 | Using where |+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+ 显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。 索引选择性与前缀索引既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。 第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。 另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值： Index Selectivity = Cardinality / #T 显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性： 123456SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;+-------------+| Selectivity |+-------------+| 0.0000 |+-------------+ title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。 有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。 从图12可以看到employees表只有一个索引&lt;emp_no&gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了： 123456EXPLAIN SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido';+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+| 1 | SIMPLE | employees | ALL | NULL | NULL | NULL | NULL | 300024 | Using where |+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+ 如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建&lt;first_name&gt;或&lt;first_name, last_name&gt;，看下两个索引的选择性： 123456789101112SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees;+-------------+| Selectivity |+-------------+| 0.0042 |+-------------+SELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees;+-------------+| Selectivity |+-------------+| 0.9313 |+-------------+ &lt;first_name&gt;显然选择性太低，&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性： 123456SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees;+-------------+| Selectivity |+-------------+| 0.7879 |+-------------+ 选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4： 123456SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees;+-------------+| Selectivity |+-------------+| 0.9007 |+-------------+ 这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上： 12ALTER TABLE employees.employeesADD INDEX `first_name_last_name4` (first_name, last_name(4)); 此时再执行一遍按名字查询，比较分析一下与建索引前的结果： 1234567SHOW PROFILES;+----------+------------+---------------------------------------------------------------------------------+| Query_ID | Duration | Query |+----------+------------+---------------------------------------------------------------------------------+| 87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido' || 90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido' |+----------+------------+---------------------------------------------------------------------------------+ 性能的提升是显著的，查询速度提高了120多倍。 前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。 InnoDB的主键选择与插入优化在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。 经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。 上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示： 这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置： 此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。 因此，只要可以，请尽量在InnoDB上采用自增字段做主键。 后记这篇文章断断续续写了半个月，主要内容就是上面这些了。不可否认，这篇文章在一定程度上有纸上谈兵之嫌，因为我本人对MySQL的使用属于菜鸟级别，更没有太多数据库调优的经验，在这里大谈数据库索引调优有点大言不惭。就当是我个人的一篇学习笔记了。 其实数据库索引调优是一项技术活，不能仅仅靠理论，因为实际情况千变万化，而且MySQL本身存在很复杂的机制，如查询优化策略和各种引擎的实现差异等都会使情况变得更加复杂。但同时这些理论是索引调优的基础，只有在明白理论的基础上，才能对调优策略进行合理推断并了解其背后的机制，然后结合实践中不断的实验和摸索，从而真正达到高效使用MySQL索引的目的。 另外，MySQL索引及其优化涵盖范围非常广，本文只是涉及到其中一部分。如与排序（ORDER BY）相关的索引优化及覆盖索引（Covering index）的话题本文并未涉及，同时除B-Tree索引外MySQL还根据不同引擎支持的哈希索引、全文索引等等本文也并未涉及。如果有机会，希望再对本文未涉及的部分进行补充吧。 参考文献[1] Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010 [2] Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006 [3] 姜承尧 著；MySQL技术内幕-InnoDB存储引擎；机械工业出版社，2011 [4] D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979 [5] Codd, E. F. (1970). “A relational model of data for large shared data banks”. Communications of the ACM, , Vol. 13, No. 6, pp. 377-387 [6] MySQL5.1参考手册 - http://dev.mysql.com/doc/refman/5.1/zh/index.html","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell.github.io/tags/笔记/"},{"name":"MySQL","slug":"MySQL","permalink":"http://londbell.github.io/tags/MySQL/"},{"name":"收藏","slug":"收藏","permalink":"http://londbell.github.io/tags/收藏/"},{"name":"转载","slug":"转载","permalink":"http://londbell.github.io/tags/转载/"},{"name":"数据库","slug":"数据库","permalink":"http://londbell.github.io/tags/数据库/"},{"name":"数据结构","slug":"数据结构","permalink":"http://londbell.github.io/tags/数据结构/"}]},{"title":"阅读列表","date":"2017-04-10T07:49:11.000Z","path":"2017/04/10/阅读列表/","text":"https://exvim.github.io/docs-zh/intro/https://github.com/hehonghui/android-tech-frontier/blob/master/issue-36/Gradle%E5%B0%8F%E7%9F%A5%E8%AF%862.mdhttp://hukai.me/android-training-course-in-chinese/index.html","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell.github.io/tags/笔记/"}]},{"title":"55-Jump-Game","date":"2017-04-06T14:38:09.000Z","path":"2017/04/06/55-Jump-Game/","text":"题目描述Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example:A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. 给定一个数组，里面没有负数，都是正整数，每个元素存了最多可以走几步，现在问你能不能走到终点。 用贪心算法比较合适。[原题地址]https://leetcode.com/problems/jump-game/#/description) 我的解法：1234567891011121314151617181920212223class Solution &#123; public boolean canJump(int[] nums) &#123; if(nums.length == 1) &#123; return true; &#125; int max = 0; for(int i = 0; i &lt; nums.length; i ++) &#123; if(i &lt;= max) &#123; max = Math.max(i + nums[i], max); if(max &gt;= nums.length - 1) &#123; return true; &#125; &#125; &#125; if(max &lt; nums.length - 1) &#123; return false; &#125;else &#123; return true; &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell.github.io/tags/LeetCode/"}]},{"title":"521-longest-Uncommon-Subsequence-I","date":"2017-04-06T12:12:48.000Z","path":"2017/04/06/521-longest-Uncommon-Subsequence-I/","text":"题目描述 Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1. Example 1: 12345Input: \"aba\", \"cdc\"Output: 3Explanation: The longest uncommon subsequence is \"aba\" (or \"cdc\"), because \"aba\" is a subsequence of \"aba\", but not a subsequence of any other strings in the group of two strings. Note: Both strings&apos; lengths will not exceed 100. Only letters from a ~ z will appear in input strings. 给定两个字符串，计算其“最长不公共子序列”。最长不公共子序列是指：两字符串中某一个的子序列，该子序列不是另一个字符串的子序列，并且长度最长。 子序列是指从一个序列中删除一些字符，剩余字符顺序保持不变得到的新序列。任何字符串都是其本身的子序列，空串不属于任意字符串的子序列。 返回最长不公共子序列，若不存在，返回-1。 原题地址若两字符串不相等，选择较长的字符串返回长度即可。 否则返回-1。（若两字符串相等，则任意字符串的子串均为另一个的子串） 我的解法： 123456789class Solution &#123; public int findLUSlength(String a, String b) &#123; if(a.equals(b)) &#123; return -1; &#125;else &#123; return Math.max(a.length(), b.length()); &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell.github.io/tags/LeetCode/"}]},{"title":"Windows-Hpyer-V-Fix","date":"2017-03-30T02:46:58.000Z","path":"2017/03/30/Windows-Hpyer-V-Fix/","text":"在Windows 10操作系统中，微软为其搭载了自家的服务器虚拟化技术 Hyper-V，只需要在功能中启动即可创建并运行需要的的虚拟机实现操作系统测试或服务器虚拟化的工作。 但有的时候除了 Hyper-V 之外，还需要运行 VMware 的虚拟机，但如果在系统中同时安装着两个虚拟机平台， VMware、VM VirtualBox虚拟机都不能运行，提示与Hyper-V不兼容。 所以可以这样解决：1231、运行 bcdedit /copy &#123;current&#125; /d “Windows 10 (关闭 Hyper-V)” 命令，随后会提示已经创建了另外一个启动菜单项，记下 &#123; &#125; 中的一串代码。 2、运行 bcdedit /set &#123;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&#125; hypervisorlaunchtype OFF 命令，将上面的代码替换掉这里的红色XXX代码即可 再次启动 Windows 10 即可手动选择是否要启用 Hyper-V，在“关闭 Hyper-V”的模式中，即可运行 Vmware 虚拟机，而另一个选项则可以运行 Hyper-V 虚拟机，这样就可以避免为了运行 VMware 虚拟机而卸载 Hyper-V 功能了。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell.github.io/tags/笔记/"}]},{"title":"Spiral Matrix","date":"2017-03-28T05:03:00.000Z","path":"2017/03/28/leetcode-54-spiral-matrix/","text":"题目描述给出一个M X N的矩阵，以螺旋方式给出其序列。Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example,Given the following matrix:12345[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] You should return [1,2,3,6,9,8,7,4,5]. 原题地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123; public static List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); boolean flagSub = true; if(matrix.length == 0) &#123; return list; &#125; do &#123; boolean [][]flag = new boolean[matrix.length][matrix[0].length]; for(int i = 0; i &lt; matrix[0].length; i++) &#123; list.add(matrix[0][i]); flag[0][i] = true; &#125; for (boolean[] e: flag) &#123; for (boolean q : e) &#123; q = false; &#125; &#125; for(int i = 1; i &lt; matrix.length; i++) &#123; if (!flag[i][matrix[0].length - 1]) &#123; list.add(matrix[i][matrix[0].length - 1]); flag[i][matrix[0].length - 1] = true; &#125; &#125; for(int i = matrix[0].length - 2; i &gt;= 0; i--) &#123;// i = 0的边界条件 if(!flag[matrix.length-1][i]) &#123; list.add(matrix[matrix.length - 1][i]); flag[matrix.length - 1][i] = true; &#125; &#125; for(int i = matrix.length - 2; i &gt; 0; i--) &#123; if(!flag[i][0]) &#123; list.add(matrix[i][0]); flag[i][0] = true; &#125; &#125; flagSub = matrix.length &gt;2 &amp;&amp; matrix[0].length &gt;2; if(flagSub) &#123; matrix = getSubMatrix(matrix); &#125; &#125;while(flagSub); return list; &#125; public static int[][] getSubMatrix(int[][] matrix) &#123; int[][] subMatrix = new int[matrix.length - 2][matrix[0].length -2]; for(int i = 1; i &lt; matrix.length - 1; i ++) &#123; for(int j = 1; j &lt; matrix[0].length - 1; j++) &#123; subMatrix[i - 1][j - 1] = matrix[i][j]; &#125; &#125; return subMatrix; &#125;&#125; 这种做法比较蠢，有大佬这样做，用方向矩阵的方式来做：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* Solution 3: 使用方向矩阵来求解 */ public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;(); if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return ret; &#125; int rows = matrix.length; int cols = matrix[0].length; int visitedRows = 0; int visitedCols = 0; // indicate the direction of x // 1: means we are visiting the row by the right direction. // -1: means we are visiting the row by the left direction. int[] x = &#123;1, 0, -1, 0&#125;; // 1: means we are visiting the colum by the down direction. // -1: means we are visiting the colum by the up direction. int[] y = &#123;0, 1, 0, -1&#125;; // 0: right, 1: down, 2: left, 3: up. int direct = 0; int startx = 0; int starty = 0; int candidateNum = 0; int step = 0; while (true) &#123; if (x[direct] == 0) &#123; // visit Y axis. candidateNum = rows - visitedRows; &#125; else &#123; // visit X axis candidateNum = cols - visitedCols; &#125; if (candidateNum &lt;= 0) &#123; break; &#125; ret.add(matrix[startx][starty]); step++; if (step == candidateNum) &#123; step = 0; visitedRows += x[direct] == 0 ? 0: 1; visitedCols += y[direct] == 0 ? 0: 1; // move forward the direction. direct ++; direct = direct%4; &#125; // 根据方向来移动横坐标和纵坐标。 startx += y[direct]; starty += x[direct]; &#125; return ret; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell.github.io/tags/LeetCode/"},{"name":"矩阵","slug":"矩阵","permalink":"http://londbell.github.io/tags/矩阵/"}]},{"title":"Factorial Trailing Zeroes","date":"2017-03-28T02:03:00.000Z","path":"2017/03/28/leetcode-172-factorial-trailing-zeroes/","text":"题目描述给出一个整数N，求N阶乘中有几个0。 乘法得到0就是2*5，2的数量不知比5多到哪里去了，只要计算5的数量就行，那就一直除于5，计算即可。 Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 原题地址12345678910public class Solution &#123; public int trailingZeroes(int n) &#123; int count = 0; while(n != 0) &#123; n /= 5; count += n; &#125; return count; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell.github.io/tags/LeetCode/"}]},{"title":"Edit Distance","date":"2017-03-27T13:42:00.000Z","path":"2017/03/27/leetcode-72-Edit-Distance/","text":"题目描述给出两个字符串，看S1最少需要几步可以变成S2？1.可以插入一个字符。2.可以删除一个字符。3.可以替换一个字符。 Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: a) Insert a characterb) Delete a characterc) Replace a character 解题思路：图中表示的是，将s1:Park变成s:Spake的最小操作步数,dp[i][j] 表示从s1的前i位，变到s2的前j位，最小需要多少改变 比如我们看矩阵的第一行，分别代表从” “(空字符)变到”s”, 变到”sp”，变到”spa”,变到”spak”，变到”spake” 需要多少次改变，因为每次只能选择往上添加一个字符，所以累加操作数分别为1,2,3,4,5 同理，矩阵的第一列分别代表从”p” 变到” “(空字符)，从”pa“变空，从”par“变空,从”park”变空需要多少次改变，因为每次只能选择删去一个字符，所以累加操作数分别为1,2,3,4 可以参考图中绿色字体的那个例子 下箭头： 我们现在已经知道了从” “ 到”s“的距离，那么从”p” 到’’s” 我们只要删去这个p就行了 （Delete） 右箭头： 我们现在已经知道了从”p“到” “的距离，那么从”p” 到”s” 我们只要插入这个s就行了 （Insert） 右下箭头： 我们现在已经知道了从” “到” “的距离，那么从”p” 到”s” 我们只需要把p替换成s就行了(Replace) 注意替换的时候，如果i所代表的的字符 == j所代表的字符，那么我们便不需要做任何多余的操作（No Operation） 原题地址1234567891011121314151617181920212223242526class Solution &#123; public int minDistance(String word1, String word2) &#123; int dp[][] = new int[word1.length() + 1][word2.length() + 1]; dp[1][0] = 0; for(int i = 1; i &lt;= word1.length(); i++) &#123; dp[i][0] = dp[i - 1][0] + 1; &#125; for(int i = 1; i &lt;= word2.length(); i++) &#123; dp[0][i] = dp[0][i - 1] + 1; &#125; for(int i = 1; i &lt;= word1.length(); i++) &#123; for(int j = 1; j &lt;= word2.length(); j++) &#123; if(word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1]; //状态转移，说明此时不需要任何操作 &#125;else &#123; dp[i][j] = 1 + Math.min(dp[i][j-1], Math.min(dp[i-1][j], dp[i-1][j-1])); &#125; &#125; &#125; return dp[word1.length()][word2.length()]; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell.github.io/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://londbell.github.io/tags/动态规划/"},{"name":"字符串","slug":"字符串","permalink":"http://londbell.github.io/tags/字符串/"}]},{"title":"Interleaving String","date":"2017-03-27T12:42:00.000Z","path":"2017/03/27/leetcode-97-Interleaving-String/","text":"题目描述给出三个字符串，看S1和S2能否交叉取char字符组成S3 Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example,Given:s1 = “aabcc”,s2 = “dbbca”, When s3 = “aadbbcbcac”, return true.When s3 = “aadbbbaccc”, return false. 解题思路：DP[i][j]存的是取S1的i个字符，取S2的j个字符情况下，能否构成S3;由于存的是“个数”，所以对应到String操作上是i+1,要注意另外需要注意第二次运算交集时要并上本身（第一次运算说明本路径是有效的）。 原题地址123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public static boolean isInterleave(String s1, String s2, String s3) &#123; if(s1 == \"\" || s2 == \"\" || s3 == \"\") &#123; return false; &#125; if((s1.length() + s2.length()) != s3.length()) &#123; return false; &#125; boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1]; dp[0][0] = true; for(int m = 1; m &lt; s1.length() + 1; m++) &#123; if (s1.charAt(m - 1) == s3.charAt(m - 1)) &#123; dp[m][0] = true &amp;&amp; dp[m - 1][0]; &#125; else &#123; dp[m][0] = false; &#125; &#125; for(int m = 1; m &lt; s2.length() + 1; m++) &#123; if(s2.charAt(m - 1) == s3.charAt(m - 1)) &#123; dp[0][m] = true &amp;&amp; dp[0][m - 1]; &#125;else&#123; dp[0][m] = false; &#125; &#125; for(int m = 1; m &lt; s1.length() + 1; m++) &#123; for(int n = 1; n &lt; s2.length() + 1; n++) &#123; if(s1.charAt(m - 1) == s3.charAt(m + n - 1)) &#123; dp[m][n] = true &amp;&amp; dp[m-1][n]; &#125; if(s2.charAt(n - 1) == s3.charAt(m + n - 1)) &#123; dp[m][n] = (true &amp;&amp; dp[m][n-1]) || dp[m][n];//防止前面的true被交集运算后得到false &#125; &#125; &#125; for(int m = 0; m &lt; s1.length() + 1; m++) &#123; for(int n = 0; n &lt; s2.length() + 1; n++) &#123; //System.out.println(dp[m][n]); &#125; &#125; return dp[s1.length()][s2.length()]; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode - 动态规划 - 字符串","slug":"LeetCode-动态规划-字符串","permalink":"http://londbell.github.io/tags/LeetCode-动态规划-字符串/"}]},{"title":"Subsets","date":"2017-03-27T11:09:00.000Z","path":"2017/03/27/leetcode-78-Subsets/","text":"题目描述给出一个数组，每个元素均不同，给出所有他的子集 Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 原题地址12345678910111213141516class Solution &#123; public static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;(); int total = 2 &lt;&lt; (nums.length) - 1; for(int i = 0;i &lt; total; i ++) &#123; List&lt;Integer&gt; temp = new LinkedList&lt;&gt;(); for(int j = 0; j &lt; nums.length; j++) &#123; if((i &amp; (1 &lt;&lt; j)) != 0) &#123;//不能写==1，注意 temp.add(nums[j]); &#125; &#125; list.add(temp); &#125; return list; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell.github.io/tags/LeetCode/"}]},{"title":"等价交换","date":"2017-03-26T16:34:00.000Z","path":"2017/03/27/diary-2017-0327-0034/","text":"人没有牺牲就什么都得不到，为了得到什么东西，就需要付出同等的代价。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://londbell.github.io/tags/随笔/"}]},{"title":"Java 快速参考教程","date":"2016-04-12T10:47:22.000Z","path":"2016/04/12/Java-快速参考教程/","text":"快速参考教程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367// 单行注释/*多行注释*//**JavaDoc（Java文档）注释是这样的。可以用来描述类和类的属性。*/// 导入 java.util中的 ArrayList 类import java.util.ArrayList;// 导入 java.security 包中的所有类import java.security.*;// 每个 .java 文件都包含一个public类，这个类的名字必须和这个文件名一致。public class LearnJava &#123; // 每个程序都需要有一个main函数作为入口 public static void main (String[] args) &#123; // 使用 System.out.println 来输出到标准输出 System.out.println(\"Hello World!\"); System.out.println( \"Integer: \" + 10 + \" Double: \" + 3.14 + \" Boolean: \" + true); // 如果要在输出后不自动换行，可以使用System.out.print方法。 System.out.print(\"Hello \"); System.out.print(\"World\"); /////////////////////////////////////// // 类型与变量 /////////////////////////////////////// // 用 &lt;type&gt; &lt;name&gt; 来声明变量 // 字节类型 - 8位补码表示 // (-128 &lt;= 字节 &lt;= 127) byte fooByte = 100; // 短整型 - 16位补码表示 // (-32,768 &lt;= 短整型 &lt;= 32,767) short fooShort = 10000; // 整型 - 32位补码表示 // (-2,147,483,648 &lt;= 整型 &lt;= 2,147,483,647) int fooInt = 1; // 长整型 - 64位补码表示 // (-9,223,372,036,854,775,808 &lt;= 长整型 &lt;= 9,223,372,036,854,775,807) long fooLong = 100000L; // L可以用来表示一个数字是长整型的。 // 其他的数字都默认为整型。 // 注意：Java中没有无符号类型 // 浮点型 - 即 IEEE 754 规定的32位单精度浮点类型 float fooFloat = 234.5f; // f用来表示一个数字是浮点型的。 // 否则会被默认当做是双精度浮点型。 // 双精度浮点型 - 即 IEEE 754 规定的64位双精度浮点类型 double fooDouble = 123.4; // 布尔类型 - true 与 false boolean fooBoolean = true; boolean barBoolean = false; // 字符类型 - 16位 Unicode编码字符 char fooChar = 'A'; // 用 final 可以使一个常量不可更改 final int HOURS_I_WORK_PER_WEEK = 9001; // 字符串 String fooString = \"My String Is Here!\"; // \\n 代表一个新的换行 String barString = \"Printing on a new line?\\nNo Problem!\"; // \\t 代表一个新的制表符 String bazString = \"Do you want to add a tab?\\tNo Problem!\"; System.out.println(fooString); System.out.println(barString); System.out.println(bazString); // 数组 // 数组在声明时大小必须已经确定 // 数组的声明格式: //&lt;数据类型&gt; [] &lt;变量名&gt; = new &lt;数据类型&gt;[&lt;数组大小&gt;]; int [] intArray = new int[10]; String [] stringArray = new String[1]; boolean [] booleanArray = new boolean[100]; // 声明并初始化数组也可以这样: int [] y = &#123;9000, 1000, 1337&#125;; // 随机访问数组中的元素 System.out.println(\"intArray @ 0: \" + intArray[0]); // 数组下标从0开始并且可以被更改 intArray[1] = 1; System.out.println(\"intArray @ 1: \" + intArray[1]); // =&gt; 1 // 其他数据类型 // ArrayLists - 类似于数组，但是功能更多，并且大小也可以改变 // LinkedLists // Maps // HashMaps /////////////////////////////////////// // 操作符 /////////////////////////////////////// System.out.println(\"\\n-&gt;Operators\"); int i1 = 1, i2 = 2; // 多重声明可以简化 // 算数运算 System.out.println(\"1+2 = \" + (i1 + i2)); // =&gt; 3 System.out.println(\"2-1 = \" + (i2 - i1)); // =&gt; 1 System.out.println(\"2*1 = \" + (i2 * i1)); // =&gt; 2 System.out.println(\"1/2 = \" + (i1 / i2)); // =&gt; 0 (0.5 truncated down) // 取余 System.out.println(\"11%3 = \"+(11 % 3)); // =&gt; 2 // 比较操作符 System.out.println(\"3 == 2? \" + (3 == 2)); // =&gt; false System.out.println(\"3 != 2? \" + (3 != 2)); // =&gt; true System.out.println(\"3 &gt; 2? \" + (3 &gt; 2)); // =&gt; true System.out.println(\"3 &lt; 2? \" + (3 &lt; 2)); // =&gt; false System.out.println(\"2 &lt;= 2? \" + (2 &lt;= 2)); // =&gt; true System.out.println(\"2 &gt;= 2? \" + (2 &gt;= 2)); // =&gt; true // 位运算操作符 /* ~ 取反，求反码 &lt;&lt; 带符号左移 &gt;&gt; 带符号右移 &gt;&gt;&gt; 无符号右移 &amp; 和 ^ 异或 | 相容或 */ // 自增 int i = 0; System.out.println(\"\\n-&gt;Inc/Dec-rementation\"); // ++ 和 -- 操作符使变量加或减1。放在变量前面或者后面的区别是整个表达 // 式的返回值。操作符在前面时，先加减，后取值。操作符在后面时，先取值 // 后加减。 System.out.println(i++); // 后自增 i = 1, 输出0 System.out.println(++i); // 前自增 i = 2, 输出2 System.out.println(i--); // 后自减 i = 1, 输出2 System.out.println(--i); // 前自减 i = 0, 输出0 /////////////////////////////////////// // 控制结构 /////////////////////////////////////// System.out.println(\"\\n-&gt;Control Structures\"); // If语句和C的类似 int j = 10; if (j == 10)&#123; System.out.println(\"I get printed\"); &#125; else if (j &gt; 10) &#123; System.out.println(\"I don't\"); &#125; else &#123; System.out.println(\"I also don't\"); &#125; // While循环 int fooWhile = 0; while(fooWhile &lt; 100) &#123; //System.out.println(fooWhile); //增加计数器 //遍历99次， fooWhile 0-&gt;99 fooWhile++; &#125; System.out.println(\"fooWhile Value: \" + fooWhile); // Do While循环 int fooDoWhile = 0; do &#123; //System.out.println(fooDoWhile); //增加计数器 //遍历99次, fooDoWhile 0-&gt;99 fooDoWhile++; &#125;while(fooDoWhile &lt; 100); System.out.println(\"fooDoWhile Value: \" + fooDoWhile); // For 循环 int fooFor; //for 循环结构 =&gt; for(&lt;起始语句&gt;; &lt;循环进行的条件&gt;; &lt;步长&gt;) for(fooFor=0; fooFor&lt;10; fooFor++)&#123; //System.out.println(fooFor); //遍历 10 次, fooFor 0-&gt;9 &#125; System.out.println(\"fooFor Value: \" + fooFor); // Switch Case 语句 // switch可以用来处理 byte, short, char, 和 int 数据类型 // 也可以用来处理枚举类型,字符串类,和原始数据类型的包装类： // Character, Byte, Short, 和 Integer int month = 3; String monthString; switch (month)&#123; case 1: monthString = \"January\"; break; case 2: monthString = \"February\"; break; case 3: monthString = \"March\"; break; default: monthString = \"Some other month\"; break; &#125; System.out.println(\"Switch Case Result: \" + monthString); /////////////////////////////////////// // 类型转换 /////////////////////////////////////// // 数据转换 // 将字符串转换为整型 Integer.parseInt(\"123\");//返回整数123 // 将整型转换为字符串 Integer.toString(123);//返回字符串\"123\" // 其他的数据也可以进行互相转换: // Double // Long // String // 类型转换 // 你也可以对java对象进行类型转换, 但其中会牵扯到很多概念 // 在这里可以查看更详细的信息: // http://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html /////////////////////////////////////// // 类与函数 /////////////////////////////////////// System.out.println(\"\\n-&gt;Classes &amp; Functions\"); // (Bicycle类定义如下) // 用new来实例化一个类 Bicycle trek = new Bicycle(); // 调用对象的方法 trek.speedUp(3); // 需用getter和setter方法 trek.setCadence(100); // toString 可以把对象转换为字符串 System.out.println(\"trek info: \" + trek.toString()); &#125; // main 方法结束&#125; // LearnJava 类结束// 你也可以把其他的非public类放入到.java文件中// 类定义的语法:// &lt;public/private/protected&gt; class &lt;类名&gt;&#123;// //成员变量, 构造函数, 函数// //Java中函数被称作方法// &#125;class Bicycle &#123; // Bicycle 类的成员变量和方法 public int cadence; // Public: 任意位置均可访问 private int speed; // Private: 只在同类中可以访问 protected int gear; // Protected: 可以在同类与子类中可以访问 String name; // default: 可以在包内中可以访问 // 构造函数是初始化一个对象的方式 // 以下是一个默认构造函数 public Bicycle() &#123; gear = 1; cadence = 50; speed = 5; name = \"Bontrager\"; &#125; // 一下是一个含有参数的构造函数 public Bicycle(int startCadence, int startSpeed, int startGear, String name) &#123; this.gear = startGear; this.cadence = startCadence; this.speed = startSpeed; this.name = name; &#125; // 函数语法: // &lt;public/private/protected&gt; &lt;返回值类型&gt; &lt;函数名称&gt;(&lt;参数列表&gt;) // Java类中经常会用getter和setter来对成员变量进行操作 // 方法声明的语法: // &lt;作用域&gt; &lt;返回值类型&gt; &lt;方法名&gt;(&lt;参数列表&gt;) public int getCadence() &#123; return cadence; &#125; // void返回值函数没有返回值 public void setCadence(int newValue) &#123; cadence = newValue; &#125; public void setGear(int newValue) &#123; gear = newValue; &#125; public void speedUp(int increment) &#123; speed += increment; &#125; public void slowDown(int decrement) &#123; speed -= decrement; &#125; public void setName(String newName) &#123; name = newName; &#125; public String getName() &#123; return name; &#125; //返回对象属性的方法 @Override public String toString() &#123; return \"gear: \" + gear + \" cadence: \" + cadence + \" speed: \" + speed + \" name: \" + name; &#125;&#125; // Bicycle 类结束// PennyFarthing 是 Bicycle 的子类class PennyFarthing extends Bicycle &#123; // (Penny Farthings 是前轮很大的 Bicycle， 并且没有齿轮) public PennyFarthing(int startCadence, int startSpeed)&#123; // 通过super调用父类的构造函数 super(startCadence, startSpeed, 0, \"PennyFarthing\"); &#125; // 你可以用@注释来表示需要重载的方法 // 了解更多的注释使用方法，可以访问下面的地址： // http://docs.oracle.com/javase/tutorial/java/annotations/ @Override public void setGear(int gear) &#123; gear = 0; &#125;&#125;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"}]},{"title":"21分钟 MySQL 入门教程","date":"2016-04-10T10:50:56.000Z","path":"2016/04/10/21分钟-MySQL-入门教程/","text":"MySQL的相关概念介绍MySQL 为关系型数据库(Relational Database Management System), 这种所谓的”关系型”可以理解为”表格”的概念, 一个关系型数据库由一个或数个表格组成, 如图所示的一个表格: 表头(header): 每一列的名称; 列(row): 具有相同数据类型的数据的集合; 行(col): 每一行用来描述某个人/物的具体信息; 值(value): 行的具体信息, 每个值必须与该列的数据类型相同; 键(key): 表中用来识别某个特定的人\\物的方法, 键的值在当前列中具有唯一性。 Windows下MySQL的配置以 MySQL 5.1 免安装版为例, 下载 mysql-noinstall-5.1.69-win32.zip(官方下载页: http://dev.mysql.com/downloads/mysql/5.1.html#downloads) 配置步骤: 将下载的 mysql-noinstall-5.1.69-win32.zip 解压至需要安装的位置, 如: C:\\Program Files; 在安装文件夹下找到 my-small.ini 配置文件, 将其重命名为 my.ini , 打开进行编辑, 在 [client] 与 [mysqld] 下均添加一行: default-character-set = gbk 打开 Windows 环境变量设置, 新建变量名 MYSQL_HOME , 变量值为 MySQL 安装目录路径, 这里为 C:\\Program Files\\mysql-5.1.69-win32 在 环境变量 的 Path 变量中添加 ;%MYSQL_HOME%\\bin; 安装 MySQL 服务, 打开Windows命令提示符, 执行命令: mysqld –install MySQL –defaults-file=”my.ini” 提示”Service successfully installed.”表示成功; MySQL服务的启动、停止与卸载 在 Windows 命令提示符下运行: 启动: net start MySQL 停止: net stop MySQL 卸载: sc delete MySQL MySQL脚本的基本组成与常规的脚本语言类似, MySQL 也具有一套对字符、单词以及特殊符号的使用规定, MySQL 通过执行 SQL 脚本来完成对数据库的操作, 该脚本由一条或多条MySQL语句(SQL语句 + 扩展语句)组成, 保存时脚本文件后缀名一般为 .sql。在控制台下, MySQL 客户端也可以对语句进行单句的执行而不用保存为.sql文件。 标识符标识符用来命名一些对象, 如数据库、表、列、变量等, 以便在脚本中的其他地方引用。MySQL标识符命名规则稍微有点繁琐, 这里我们使用万能命名规则: 标识符由字母、数字或下划线(_)组成, 且第一个字符必须是字母或下划线。 对于标识符是否区分大小写取决于当前的操作系统, Windows下是不敏感的, 但对于大多数 linux\\unix 系统来说, 这些标识符大小写是敏感的。 关键字MySQL的关键字众多, 这里不一一列出, 在学习中学习。 这些关键字有自己特定的含义, 尽量避免作为标识符。 语句MySQL语句是组成MySQL脚本的基本单位, 每条语句能完成特定的操作, 他是由 SQL 标准语句 + MySQL 扩展语句组成。 函数MySQL函数用来实现数据库操作的一些高级功能, 这些函数大致分为以下几类: 字符串函数、数学函数、日期时间函数、搜索函数、加密函数、信息函数。 MySQL中的数据类型MySQL有三大类数据类型, 分别为数字、日期\\时间、字符串, 这三大类中又更细致的划分了许多子类型: 数字类型 整数: tinyint、smallint、mediumint、int、bigint 浮点数: float、double、real、decimal 日期和时间: date、time、datetime、timestamp、year 字符串类型 字符串: char、varchar 文本: tinytext、text、mediumtext、longtext 二进制(可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob 这里不能详细对这些类型进行介绍了, 篇幅可能会很长, 详细介绍参见: 《MySQL数据类型》 : http://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html 使用MySQL数据库登录到MySQL当 MySQL 服务已经运行时, 我们可以通过MySQL自带的客户端工具登录到MySQL数据库中, 首先打开命令提示符, 输入以下格式的命名: 1mysql -h 主机名 -u 用户名 -p -h : 该命令用于指定客户端所要登录的MySQL主机名, 登录当前机器该参数可以省略; -u : 所要登录的用户名; -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 以登录刚刚安装在本机的MySQL数据库为例, 在命令行下输入 mysql -u root -p 按回车确认, 如果安装正确且MySQL正在运行, 会得到以下响应: Enter password: 若密码存在, 输入密码登录, 不存在则直接按回车登录, 按照本文中的安装方法, 默认 root 账号是无密码的。登录成功后你将会看到 Welecome to the MySQL monitor… 的提示语。 然后命令提示符会一直以 mysql&gt; 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。 创建一个新的数据库使用 create database 语句可完成对数据库的创建, 创建命令的格式如下: 1create database 数据库名 [其他选项]; 例如我们需要创建一个名为 samp_db 的数据库, 在命令行下执行以下命令: 1create database samp_db character set gbk; 为了便于在命令提示符下显示中文, 在创建时通过 character set gbk 将数据库字符编码指定为 gbk。创建成功时会得到 Query OK, 1 row affected(0.02 sec) 的响应。 注意: MySQL语句以分号(;)作为语句的结束, 若在语句结尾不添加分号时, 命令提示符会以 -&gt; 提示你继续输入(有个别特例, 但加分号是一定不会错的); 提示: 可以使用 show databases; 命令查看已经创建了哪些数据库。 选择所要操作的数据库要对一个数据库进行操作, 必须先选择该数据库, 否则会提示错误: ERROR 1046(3D000): No database selected 两种方式对数据库进行使用的选择: 一: 在登录数据库时指定, 命令: mysql -D 所选择的数据库名 -h 主机名 -u 用户名 -p 例如登录时选择刚刚创建的数据库: mysql -D samp_db -u root -p 二: 在登录后使用 use 语句指定, 命令: use 数据库名; use 语句可以不加分号, 执行 use samp_db 来选择刚刚创建的数据库, 选择成功后会提示: Database changed 创建数据库表使用 create table 语句可完成对表的创建, create table 的常见形式: 1create table 表名称(列声明); 以创建 students 表为例, 表中将存放 学号(id)、姓名(name)、性别(sex)、年龄(age)、联系电话(tel) 这些内容:12345678create table students （ id int unsigned not null auto_increment primary key, name char(8) not null, sex char(4) not null, age tinyint unsigned not null, tel char(13) null default &quot;-&quot; ); 对于一些较长的语句在命令提示符下可能容易输错, 因此我们可以通过任何文本编辑器将语句输入好后保存为 createtable.sql 的文件中, 通过命令提示符下的文件重定向执行执行该脚本。 打开命令提示符, 输入: mysql -D samp_db -u root -p &lt; createtable.sql (提示: 1.如果连接远程主机请加上 -h 指令; 2. createtable.sql 文件若不在当前工作目录下需指定文件的完整路径。) 语句解说:create table tablename(columns) 为创建数据库表的命令, 列的名称以及该列的数据类型将在括号内完成; 括号内声明了5列内容, id、name、sex、age、tel为每列的名称, 后面跟的是数据类型描述, 列与列的描述之间用逗号(,)隔开; 以 “id int unsigned not null auto_increment primary key” 行进行介绍: &quot;id&quot; 为列的名称; &quot;int&quot; 指定该列的类型为 int(取值范围为 -8388608到8388607), 在后面我们又用 &quot;unsigned&quot; 加以修饰, 表示该类型为无符号型, 此时该列的取值范围为 0到16777215; &quot;not null&quot; 说明该列的值不能为空, 必须要填, 如果不指定该属性, 默认可为空; &quot;auto_increment&quot; 需在整数列中使用, 其作用是在插入数据时若该列为 NULL, MySQL将自动产生一个比现存值更大的唯一标识符值。在每张表中仅能有一个这样的值且所在列必须为索引列。 &quot;primary key&quot; 表示该列是表的主键, 本列的值必须唯一, MySQL将自动索引该列。 下面的 char(8) 表示存储的字符长度为8, tinyint的取值范围为 -127到128, default 属性指定当该列值为空时的默认值。 更多的数据类型请参阅 《MySQL数据类型》 : http://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html 提示: 1. 使用 show tables; 命令可查看已创建了表的名称; 2. 使用 describe 表名; 命令可查看已创建的表的详细信息。 操作MySQL数据库向表中插入数据insert 语句可以用来将一行或多行数据插到数据库表中, 使用的一般形式如下: 1insert [into] 表名 [(列名1, 列名2, 列名3, ...)] values (值1, 值2, 值3, ...); 其中 [] 内的内容是可选的, 例如, 要给 samp_db 数据库中的 students 表插入一条记录, 执行语句: 1insert into students values(NULL, &quot;王刚&quot;, &quot;男&quot;, 20, &quot;13811371377&quot;); 按回车键确认后若提示 Query Ok, 1 row affected (0.05 sec) 表示数据插入成功。 若插入失败请检查是否已选择需要操作的数据库。有时我们只需要插入部分数据, 或者不按照列的顺序进行插入, 可以使用这样的形式进行插入: 1insert into students (name, sex, age) values(&quot;孙丽华&quot;, &quot;女&quot;, 21); 查询表中的数据insert 语句可以用来将一行或多行数据插到数据库表中, 使用的一般形式如下: insert [into] 表名 [(列名1, 列名2, 列名3, …)] values (值1, 值2, 值3, …); 其中 [] 内的内容是可选的, 例如, 要给 samp_db 数据库中的 students 表插入一条记录, 执行语句: insert into students values(NULL, “王刚”, “男”, 20, “13811371377”); 按回车键确认后若提示 Query Ok, 1 row affected (0.05 sec) 表示数据插入成功。 若插入失败请检查是否已选择需要操作的数据库。 有时我们只需要插入部分数据, 或者不按照列的顺序进行插入, 可以使用这样的形式进行插入: insert into students (name, sex, age) values(“孙丽华”, “女”, 21); 查询表中的数据select 语句常用来根据一定的查询规则到数据库中获取数据, 其基本的用法为:1select 列名称 from 表名称 [查询条件]; 例如要查询 students 表中所有学生的名字和年龄, 输入语句 select name, age from students; 执行结果如下: mysql&gt; select name, age from students; +--------+-----+ | name | age | +--------+-----+ | 王刚 | 20 | | 孙丽华 | 21 | | 王永恒 | 23 | | 郑俊杰 | 19 | | 陈芳 | 22 | | 张伟朋 | 21 | +--------+-----+ 6 rows in set (0.00 sec) mysql&gt; 也可以使用通配符 查询表中所有的内容, 语句: select from students; 按特定条件查询:where 关键词用于指定查询条件, 用法形式为: 1select 列名称 from 表名称 where 条件; 以查询所有性别为女的信息为例, 输入查询语句: select * from students where sex=”女”; where 子句不仅仅支持 “where 列名 = 值” 这种名等于值的查询形式, 对一般的比较运算的运算符都是支持的, 例如 =、&gt;、&lt;、&gt;=、&lt;、!= 以及一些扩展运算符 is [not] null、in、like 等等。 还可以对查询条件使用 or 和 and 进行组合查询, 以后还会学到更加高级的条件查询方式, 这里不再多做介绍。 示例:查询年龄在21岁以上的所有人信息: select * from students where age &gt; 21; 查询名字中带有 “王” 字的所有人信息: select * from students where name like “%王%”; 查询id小于5且年龄大于20的所有人信息: select * from students where id20; 更新表中的数据update 语句可用来修改表中的数据, 基本的使用形式为: 1update 表名称 set 列名称=新值 where 更新条件; 使用示例:将id为5的手机号改为默认的”-“: update students set tel=default where id=5; 将所有人的年龄增加1: update students set age=age+1; 将手机号为 13288097888 的姓名改为 “张伟鹏”, 年龄改为 19: update students set name=”张伟鹏”, age=19 where tel=”13288097888”; 删除表中的数据delete 语句用于删除表中的数据, 基本用法为: 1delete from 表名称 where 删除条件; 使用示例: 删除id为2的行: delete from students where id=2; 删除所有年龄小于21岁的数据: delete from students where age&lt;20; 删除表中的所有数据: delete from students; 创建后表的修改alter table 语句用于创建后对表的修改, 基础用法如下: 添加列基本形式: alter table 表名 add 列名 列数据类型 [after 插入位置]; 示例:在表的最后追加列 address: alter table students add address char(60); 在名为 age 的列后插入列 birthday: alter table students add birthday date after age; 修改列基本形式: alter table 表名 change 列名称 列新名称 新数据类型; 示例:将表 tel 列改名为 telphone: alter table students change tel telphone char(13) default “-“; 将 name 列的数据类型改为 char(16): alter table students change name name char(16) not null;删除列 基本形式: alter table 表名 drop 列名称;示例:删除 birthday 列: alter table students drop birthday; 重命名表基本形式: alter table 表名 rename 新表名; 示例:重命名 students 表为 workmates: alter table students rename workmates; 删除整张表基本形式: drop table 表名; 示例:删除 workmates 表: drop table workmates; 删除整个数据库基本形式: drop database 数据库名; 示例:删除 samp_db 数据库: drop database samp_db; 附录修改 root 用户密码按照本文的安装方式, root 用户默认是没有密码的, 重设 root 密码的方式也较多, 这里仅介绍一种较常用的方式。 使用 mysqladmin 方式:打开命令提示符界面, 执行命令: mysqladmin -u root -p password 新密码 执行后提示输入旧密码完成密码修改, 当旧密码为空时直接按回车键确认即可。 可视化管理工具 MySQL Workbench尽管我们可以在命令提示符下通过一行行的输入或者通过重定向文件来执行mysql语句, 但该方式效率较低, 由于没有执行前的语法自动检查, 输入失误造成的一些错误的可能性会大大增加, 这时不妨试试一些可视化的MySQL数据库管理工具, MySQL Workbench 就是 MySQL 官方 为 MySQL 提供的一款可视化管理工具, 你可以在里面通过可视化的方式直接管理数据库中的内容, 并且 MySQL Workbench 的 SQL 脚本编辑器支持语法高亮以及输入时的语法检查, 当然, 它的功能强大, 绝不仅限于这两点。 MySQL Workbench官方介绍: http://www.mysql.com/products/workbench/ MySQL Workbench 下载页: http://dev.mysql.com/downloads/tools/workbench/","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell.github.io/tags/笔记/"},{"name":"MySQL","slug":"MySQL","permalink":"http://londbell.github.io/tags/MySQL/"},{"name":"收藏","slug":"收藏","permalink":"http://londbell.github.io/tags/收藏/"},{"name":"转载","slug":"转载","permalink":"http://londbell.github.io/tags/转载/"}]},{"title":"Counting Bits","date":"2016-03-27T02:03:00.000Z","path":"2016/03/27/leetcode-338-Counting-Bits/","text":"题目描述大意就是实现求给出比num小的所有数的二进制位中1的位数，隐藏提示是使用动态规划。 Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.Example: For num = 5 you should return [0,1,1,2,1,2].Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?Space complexity should be O(n).Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. 原题地址 逗逼解法12345678910public class Solution &#123; public int trailingZeroes(int n) &#123; int count = 0; while(n != 0) &#123; n /= 5; count += n; &#125; return count; &#125;&#125; 动态规划需要注意到的是，每隔2^n的大小，就会刚好多出一位，也就是说构造出动态规划的叠加数组，在以前计算过的基础上加1，即可得到后面数的“1”位数。 12345678910111213141516public class Solution &#123; public static int[] countBits(int num) &#123; if(num == 0) return new int[]&#123;0&#125;; int[] result = new int[num + 1]; int len, count = 0; while(true)&#123; len = count + 1; for(int i = 0; i &lt; len; i++)&#123; ++count; result[count] = result[i] + 1; if(count &gt;= num) return result; &#125; &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell.github.io/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://londbell.github.io/tags/动态规划/"},{"name":"位操作","slug":"位操作","permalink":"http://londbell.github.io/tags/位操作/"}]},{"title":"Valid Number","date":"2016-03-23T01:21:00.000Z","path":"2016/03/23/leetcode-65-valid-number/","text":"题目描述检查给定字符串是否为合法的数字。 Validate if a given string is numeric. 123456Some examples:&quot;0&quot; =&gt; true&quot; 0.1 &quot; =&gt; true&quot;abc&quot; =&gt; false&quot;1 a&quot; =&gt; false&quot;2e10&quot; =&gt; true Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. 解题步骤：先Trim去空格（原题用例前后有空格，是合法的。）然后检查第一位的“+”， “-”。接着分割。可以出现科学计算法的e，然后可以出现小数点，但是都只能出现一次。先以e分割，注意e前后都必须是整数，由于小数点可以出现在e前，所以应该对e后端进行数字校验。同理对小数点操作。小数点允许前后两段至多有一段不为0。原题地址 我的做法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public static boolean isNumber(String s) &#123; s = s.trim(); if(s.length() == 0) &#123; return false; &#125; if(s.charAt(0) == '+' || s.charAt(0) == '-')&#123; s = s.substring(1); &#125; int loc = s.indexOf('e') &gt;= 0 ? s.indexOf('e') : s.indexOf('E'); if(loc &gt; 0) &#123; String sTemp = s.substring(loc + 1); if(sTemp.length() == 0) &#123; return false; &#125; if(sTemp.charAt(0) == '+' || sTemp.charAt(0) == '-') &#123; sTemp = sTemp.substring(1); &#125; if(!isPureDigit(sTemp)) &#123; return false; &#125; s = s.substring(0, loc); &#125;else if(loc == 0) &#123; return false; &#125; int locDot = s.indexOf('.'); if(locDot &gt;= 0) &#123; String preDot = s.substring(0, locDot); String postDot = s.substring(locDot + 1); if(preDot.isEmpty()) &#123; return isPureDigit(postDot); &#125; if(postDot.isEmpty()) &#123; return isPureDigit(preDot); &#125; return isPureDigit(preDot) &amp;&amp; isPureDigit(postDot); &#125; return isPureDigit(s); &#125; public static boolean isPureDigit(String s) &#123; if (s.isEmpty()) return false; for(int i = 0; i &lt; s.length(); ++i) &#123; if (!Character.isDigit(s.charAt(i))) &#123; return false; &#125; &#125; return true; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell.github.io/tags/LeetCode/"}]},{"title":"android.view.InflateException: Binary XML file line 错误","date":"2016-01-27T02:03:00.000Z","path":"2016/01/27/android-01-android-view-InflateException/","text":"问题描述自定义的View，在XML中调用出现android.view.InflateException: Binary XML file line 错误。 解决方法12345View(Context context) //Simple constructor to use when creating a view from codeView(Context context, AttributeSet attrs) //Constructor that is called when inflating a view from XMLView(Context context, AttributeSet attrs, int defStyle) //Perform inflation from XML and apply a class-specific base style 第二个和第三个构造函数对于XML这种引用方式是必须实现的，这三个构造函数应该是在不同的应用场合来实例化一个View对象。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"android","slug":"android","permalink":"http://londbell.github.io/tags/android/"},{"name":"坑","slug":"坑","permalink":"http://londbell.github.io/tags/坑/"}]},{"title":"search a 2dmatrix","date":"2015-09-01T07:21:00.000Z","path":"2015/09/01/leetcode-74-search-a-2d-matrix/","text":"题目描述给定一个矩阵，求特定的数是否在矩阵中。矩阵每一行从小到大排列。每一行的最小元素比上一行最大元素大。 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. For example, Consider the following matrix: 我的做法：写起来简单，性能很辣鸡。123456789101112131415161718public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix.length == 0 || matrix == null) &#123; return false; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int[] e : matrix) &#123; for(int q : e) &#123; list.add(q); &#125; &#125; if(list.contains(target)) &#123; return true; &#125; return false; &#125;&#125; 效率高的做法:12345678910111213141516public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int i = 0, j = matrix[0].length - 1; while (i &lt; matrix.length &amp;&amp; j &gt;= 0) &#123; if (matrix[i][j] == target) &#123; return true; &#125; else if (matrix[i][j] &gt; target) &#123; j--; &#125; else &#123; i++; &#125; &#125; return false; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell.github.io/tags/LeetCode/"},{"name":"矩阵","slug":"矩阵","permalink":"http://londbell.github.io/tags/矩阵/"}]},{"title":"Roman to Integer","date":"2014-12-03T09:32:00.000Z","path":"2014/12/03/leetcode-13-Roman-to-Integer/","text":"题目描述给出一个罗马数字字符串，将其计算为阿拉伯数字。 Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 背景知识罗马数字是阿拉伯数字传入之前使用的一种数码。罗马数字采用七个罗马字母作数字、即Ⅰ（1）、X（10）、C（100）、M（1000）、V（5）、L（50）、D（500）。记数的方法： 1.相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3； 2.小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12； 3.小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9； 4.在一个数的上面画一条横线，表示这个数增值 1,000 倍，如=5000。 原题地址123456789101112131415161718192021222324252627public class Solution &#123; public int romanToInt(String s) &#123; Map map = new HashMap(); map.put('I', 1);//Key是Char就用单引号，是String就用双引号 map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int result = 0; for(int i = s.length() - 1; i &gt;= 0; --i) &#123; if(i == s.length() - 1) &#123; result = (Integer)map.get(s.charAt(i)); continue; &#125; if(((Integer)map.get(s.charAt(i))) &gt;= ((Integer)map.get(s.charAt(i + 1)))) &#123; result += (Integer) map.get(s.charAt(i)); &#125;else &#123; result -= (Integer) map.get(s.charAt(i)); &#125; &#125; return result; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell.github.io/tags/LeetCode/"}]},{"title":"Add Two Numbers","date":"2014-07-03T02:11:00.000Z","path":"2014/07/03/leetcode-02-Add-Two-Numbers/","text":"题目描述给定两个由个位数组成的非空链表，按位置相加，进位累加到下一个元素上，每个元素只留个位，两个链表长度可能不等。 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 原题地址 我的做法：1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode temp = head; int count = 0; head.val = l1.val + l2.val; if(head.val &gt;= 10) &#123; count = 1; head.val %= 10; &#125; while(l1.next != null || l2.next !=null || count == 1) &#123; if(l1.next == null &amp;&amp; l2.next == null) &#123; temp.next = new ListNode(count); &#125; else if(l1.next == null) &#123; temp.next = new ListNode(l2.next.val + count); l2 = l2.next; &#125;else if(l2.next == null) &#123; temp.next = new ListNode(l1.next.val + count); l1 = l1.next; &#125;else if(l1.next != null &amp;&amp; l2.next != null) &#123; temp.next = new ListNode(l1.next.val + l2.next.val + count); l1 = l1.next; l2 = l2.next; &#125; if(temp.next.val &gt;= 10) &#123; count = 1; temp.next.val %= 10; &#125;else &#123; count = 0; &#125; temp = temp.next; &#125; return head; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"http://londbell.github.io/tags/链表/"}]},{"title":"Two Sum","date":"2014-07-01T13:52:00.000Z","path":"2014/07/01/leetcode-01-Two-Sum/","text":"题目描述给定一个整形元素组成的数组，给出一个数，求数组中是否存在两个数之和与给定数相等。不能使用同一个元素两次，同时一定只会有一个解。 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 原题地址 逗逼解法：12345678910111213141516171819202122232425262728293031323334353637package com.company;public class Main &#123; public static void main(String[] args) &#123; // write your code here int nums3[] = &#123;3, 2, 4&#125;; int target3 = 6; int nums4[] = &#123;2,7,11,15&#125;; int target4 = 9; int twoSum[] = Solution.twoSum(nums3, target3); System.out.print(twoSum[0] + \" \" + twoSum[1]); System.out.println(\" finish\"); &#125;&#125;class Solution &#123; public static int[] twoSum(int[] nums, int target) &#123; int flag = 0; int array[] = &#123;0,0&#125;; for(int i = 0; i &lt; nums.length; i++) &#123; if(flag == 1) &#123; break; &#125; for(int j = i + 1; j &lt; nums.length; j++) &#123; if((nums[i] + nums[j] == target)) &#123; array[0] = i; array[1] = j; flag = 1; break; &#125; &#125; &#125; return array; &#125;&#125; 改进方法1234567891011121314151617181920212223242526272829303132package com.company;public class Main &#123; public static void main(String[] args) &#123; // write your code here int nums3[] = &#123;3, 2, 4&#125;; int target3 = 6; int nums4[] = &#123;2,7,11,15&#125;; int target4 = 9; int twoSum[] = Solution.twoSum(nums3, target3); System.out.print(twoSum[0] + \" \" + twoSum[1]); System.out.println(\" finish\"); &#125;&#125;class Solution &#123; public static int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int result[] = new int[2]; for (int i = 0; i &lt; nums.length; i++)&#123; int num = target - nums[i]; if(map.containsKey(num))&#123; result[0] = map.get(num); result[1] = i; return result; &#125; map.put(nums[i], i); &#125; return result; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell.github.io/tags/LeetCode/"}]}]