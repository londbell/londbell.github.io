[{"title":"王垠:怎样写一个解释器","date":"2020-01-20T12:00:58.000Z","path":"2020/01/20/interpreter/","text":"王垠:怎样写一个解释器原文来自于王垠的怎样写一个解释器,由于原文中的源码与图片已经无法访问，所以搜索全网找到这些资源后，在自己的blog上做一个备份，以方便以后阅读。 怎样写一个解释器写一个解释器，通常是设计和实现程序语言的第一步。解释器是简单却又深奥的东西，以至于好多人都不会写，所以我决定写一篇这方面的入门读物。 虽然我试图从最基本的原理讲起，尽量不依赖于其它知识，但这并不是一本编程入门教材。我假设你已经理解 Scheme 语言，以及基本的编程技巧（比如递归）。如果你完全不了解这些，那我建议你读一下 SICP的第一，二章，或者 HtDP 的前几章，习题可以不做。注意不要读太多书，否则你就回不来了 ;-) 当然你也可以直接读这篇文章，有不懂的地方再去查资料。 实现语言容易犯的一个错误，就是一开头就试图去实现很复杂的语言（比如 JavaScript 或者 Python）。这样你很快就会因为这些语言的复杂性，以及各种历史遗留的设计问题而受到挫折，最后不了了之。学习实现语言，最好是从最简单，最干净的语言开始，迅速写出一个可用的解释器。之后再逐步往里面添加特性，同时保持正确。这样你才能有条不紊地构造出复杂的解释器。 因为这个原因，这篇文章只针对一个很简单的语言，名叫“R2”。它可以作为一个简单的计算器用，还具有变量定义，函数定义和调用等功能。 我们的工具：Racket本文的解释器是用 Scheme 语言实现的。Scheme 有很多的“实现”，这里我用的实现叫做 Racket，它可以在这里免费下载。为了让程序简洁，我用了一点点 Racket 的模式匹配（pattern matching）功能。我对 Scheme 的实现没有特别的偏好，但 Racket 方便易用，适合教学。如果你用其它的 Scheme 实现，可能得自己做一些调整。 Racket 具有宏（macro），所以它其实可以变成很多种语言。如果你之前用过 DrRacket，那它的“语言设置”可能被你改成了 R5RS 之类的。所以如果下面的程序不能运行，你可能需要检查一下 DrRacket 的“语言设置”，把 Language 设置成 “Racket”。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell,github.io/tags/笔记/"},{"name":"转载","slug":"转载","permalink":"http://londbell,github.io/tags/转载/"}]},{"title":"MySQL 索引","date":"2017-04-10T10:32:39.000Z","path":"2017/04/10/MySQL-索引/","text":"原地址：(http://blog.codinglabs.org/articles/theory-of-mysql-index.html)Markdown后加入收藏，方便阅读 摘要本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。 文章主要内容分为三个部分。 第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。 第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。 第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。 数据结构及算法基础索引的本质MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。 我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 看一个例子： 图1 图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在(O(log_2n))的复杂度内获取到相应数据。 虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。 B-Tree和B+Tree目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。 B-Tree为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构： d为大于1的一个正整数，称为B-Tree的度。 h为一个正整数，称为B-Tree的高度。 每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。 每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。 所有叶节点具有相同的深度，等于树高h。 key和指针互相间隔，节点两端是指针。 一个节点中的key从左到右非递减排列。 所有节点组成树结构。 每个指针要么为null，要么指向另外一个节点。 如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于(v(key_1))，其中(v(key_1))为node的第一个key的值。 如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于(v(key_m))，其中(v(key_m))为node的最后一个key的值。 如果某个指针在节点node的左右相邻key分别是(keyi)和(key{i+1})且不为null，则其指向节点的所有key小于(v(key_{i+1}))且大于(v(key_i))。 图2是一个d=2的B-Tree示意图。 图2 由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下： BTree_Search(node, key) { if(node == null) return null; foreach(node.key) { if(node.key[i] == key) return node.data[i]; if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node); } return BTree_Search(point[i+1]-&gt;node); } data = BTree_Search(root, my_key); 关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为\\(log_d((N+1)/2)\\)，检索一个key，其查找节点个数的渐进复杂度为\\(O(log_dN)\\)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。 另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。 ### B+Tree B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。 与B-Tree相比，B+Tree有以下不同点： 每个节点的指针上限为2d而不是2d+1。 内节点不存储data，只存储key；叶子节点不存储指针。 图3是一个简单的B+Tree示意。 ![](/imgs/mysql-index/3.png) 图3 由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。 一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。 ### 带有顺序访问指针的B+Tree 一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。 ![](/imgs/mysql-index/4.png) 图4 如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。 这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。 ## 为什么使用B-Tree（B+Tree） 上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。 ### 主存存取原理 目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。 ![](/imgs/mysql-index/5.png) 图5 从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。 主存的存取过程如下： 当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。 写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。 这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。 ### 磁盘存取原理 上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。 图6是磁盘的整体结构示意图。 ![](/imgs/mysql-index/6.png) 图6 一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。 图7是磁盘结构的示意图。 ![](/imgs/mysql-index/7.png) 图7 盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。 当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。 ### 局部性原理与磁盘预读 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： 当一个数据被用到时，其附近的数据也通常会马上被使用。 程序运行期间所需要的数据通常比较集中。 由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。 预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。 ### B-/+Tree索引的性能分析 到这里终于可以分析B-/+Tree索引的性能了。 上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧： 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。 B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为\\(O(h)=O(log_dN)\\)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。 综上所述，用B-Tree作为索引结构效率是非常高的。 而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。 上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小： \\(d_{max}=floor(pagesize / (keysize + datasize + pointsize))\\) floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。 这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。 # MySQL索引实现 在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。 ## MyISAM索引实现 MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图： ![](/imgs/mysql-index/8.png) 图8 这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示： ![](/imgs/mysql-index/9.png) 图9 同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。 MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。 ## InnoDB索引实现 虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。 第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 ![](/imgs/mysql-index/10.png) 图10 图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。 第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引： ![](/imgs/mysql-index/11.png) 图11 这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。 了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。 下一章将具体讨论这些与索引有关的优化策略。 # 索引使用策略及优化 MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。 ## 示例数据库 为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）： ![](/imgs/mysql-index/12.png) 图12 MySQL官方文档中关于此数据库的页面为[http://dev.mysql.com/doc/employee/en/employee.html](http://dev.mysql.com/doc/employee/en/employee.html \"http://dev.mysql.com/doc/employee/en/employee.html\")。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。 ## 最左前缀原理与相关优化 高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。 这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …, an&gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。 以employees.titles表为例，下面先查看其上都有哪些索引： SHOW INDEX FROM employees.titles; +--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type | +--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+ | titles | 0 | PRIMARY | 1 | emp_no | A | NULL | | BTREE | | titles | 0 | PRIMARY | 2 | title | A | NULL | | BTREE | | titles | 0 | PRIMARY | 3 | from_date | A | 443308 | | BTREE | | titles | 1 | emp_no | 1 | emp_no | A | 443308 | | BTREE | +--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+ 从结果中可以到titles表的主索引为&lt;emp_no, title, from_date&gt;，还有一个辅助索引&lt;emp_no&gt;。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉： ALTER TABLE employees.titles DROP INDEX emp_no; 这样就可以专心分析索引PRIMARY的行为了。 情况一：全列匹配。EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title='Senior Engineer' AND from_date='1986-06-26'; +----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+ | 1 | SIMPLE | titles | const | PRIMARY | PRIMARY | 59 | const,const,const | 1 | | +----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+ 很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒： EXPLAIN SELECT * FROM employees.titles WHERE from_date='1986-06-26' AND emp_no='10001' AND title='Senior Engineer'; +----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+ | 1 | SIMPLE | titles | const | PRIMARY | PRIMARY | 59 | const,const,const | 1 | | +----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+ 效果是一样的。 情况二：最左前缀匹配。EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001'; +----+-------------+--------+------+---------------+---------+---------+-------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+---------+---------+-------+------+-------+ | 1 | SIMPLE | titles | ref | PRIMARY | PRIMARY | 4 | const | 1 | | +----+-------------+--------+------+---------------+---------+---------+-------+------+-------+ 当查询条件精确匹配索引的左边连续一个或几个列时，如&lt;emp_no&gt;或&lt;emp_no, title&gt;，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。 情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND from_date='1986-06-26'; +----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+ | 1 | SIMPLE | titles | ref | PRIMARY | PRIMARY | 4 | const | 1 | Using where | +----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+ 此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no, from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。 首先我们看下title一共有几种不同的值： SELECT DISTINCT(title) FROM employees.titles; +--------------------+ | title | +--------------------+ | Senior Engineer | | Staff | | Engineer | | Senior Staff | | Assistant Engineer | | Technique Leader | | Manager | +--------------------+ 只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀： EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title IN ('Senior Engineer', 'Staff', 'Engineer', 'Senior Staff', 'Assistant Engineer', 'Technique Leader', 'Manager') AND from_date='1986-06-26'; +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ | 1 | SIMPLE | titles | range | PRIMARY | PRIMARY | 59 | NULL | 7 | Using where | +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ 这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较： SHOW PROFILES; +----------+------------+-------------------------------------------------------------------------------+ | Query_ID | Duration | Query | +----------+------------+-------------------------------------------------------------------------------+ | 10 | 0.00058000 | SELECT * FROM employees.titles WHERE emp_no='10001' AND from_date='1986-06-26'| | 11 | 0.00052500 | SELECT * FROM employees.titles WHERE emp_no='10001' AND title IN ... | +----------+------------+-------------------------------------------------------------------------------+ “填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。 情况四：查询条件没有指定索引第一列。EXPLAIN SELECT * FROM employees.titles WHERE from_date='1986-06-26'; +----+-------------+--------+------+---------------+------+---------+------+--------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+------+---------+------+--------+-------------+ | 1 | SIMPLE | titles | ALL | NULL | NULL | NULL | NULL | 443308 | Using where | +----+-------------+--------+------+---------------+------+---------+------+--------+-------------+ 由于不是最左前缀，索引这样的查询显然用不到索引。 情况五：匹配某列的前缀字符串。EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title LIKE 'Senior%'; +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ | 1 | SIMPLE | titles | range | PRIMARY | PRIMARY | 56 | NULL | 1 | Using where | +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ 此时可以用到索引，但是如果通配符不是只出现在末尾，则无法使用索引。（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀） 情况六：范围查询。EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; '10010' and title='Senior Engineer'; +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ | 1 | SIMPLE | titles | range | PRIMARY | PRIMARY | 4 | NULL | 16 | Using where | +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ 范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。 EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; '10010' AND title='Senior Engineer' AND from_date BETWEEN '1986-01-01' AND '1986-12-31'; +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ | 1 | SIMPLE | titles | range | PRIMARY | PRIMARY | 4 | NULL | 16 | Using where | +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ 可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询： EXPLAIN SELECT * FROM employees.titles WHERE emp_no BETWEEN '10001' AND '10010' AND title='Senior Engineer' AND from_date BETWEEN '1986-01-01' AND '1986-12-31'; +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ | 1 | SIMPLE | titles | range | PRIMARY | PRIMARY | 59 | NULL | 16 | Using where | +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+ 看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。 情况七：查询条件中含有函数或表达式。很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如： EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND left(title, 6)='Senior'; +----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+ | 1 | SIMPLE | titles | ref | PRIMARY | PRIMARY | 4 | const | 1 | Using where | +----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+ 虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如： EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1='10000'; +----+-------------+--------+------+---------------+------+---------+------+--------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------+------+---------------+------+---------+------+--------+-------------+ | 1 | SIMPLE | titles | ALL | NULL | NULL | NULL | NULL | 443308 | Using where | +----+-------------+--------+------+---------------+------+---------+------+--------+-------------+ 显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。 ## 索引选择性与前缀索引 既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。 第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。 另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值： Index Selectivity = Cardinality / #T 显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性： SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles; +-------------+ | Selectivity | +-------------+ | 0.0000 | +-------------+ title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。 有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。 从图12可以看到employees表只有一个索引&lt;emp_no&gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了： EXPLAIN SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido'; +----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+ | 1 | SIMPLE | employees | ALL | NULL | NULL | NULL | NULL | 300024 | Using where | +----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+ 如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建&lt;first_name&gt;或&lt;first_name, last_name&gt;，看下两个索引的选择性： SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees; +-------------+ | Selectivity | +-------------+ | 0.0042 | +-------------+ SELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees; +-------------+ | Selectivity | +-------------+ | 0.9313 | +-------------+ &lt;first_name&gt;显然选择性太低，&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性： SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees; +-------------+ | Selectivity | +-------------+ | 0.7879 | +-------------+ 选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4： SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees; +-------------+ | Selectivity | +-------------+ | 0.9007 | +-------------+ 这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上： ALTER TABLE employees.employees ADD INDEX `first_name_last_name4` (first_name, last_name(4)); 此时再执行一遍按名字查询，比较分析一下与建索引前的结果： SHOW PROFILES; +----------+------------+---------------------------------------------------------------------------------+ | Query_ID | Duration | Query | +----------+------------+---------------------------------------------------------------------------------+ | 87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido' | | 90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido' | +----------+------------+---------------------------------------------------------------------------------+ 性能的提升是显著的，查询速度提高了120多倍。 前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。 InnoDB的主键选择与插入优化在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。 经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。 上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示： 图13 这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置： 图14 此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。 因此，只要可以，请尽量在InnoDB上采用自增字段做主键。 后记这篇文章断断续续写了半个月，主要内容就是上面这些了。不可否认，这篇文章在一定程度上有纸上谈兵之嫌，因为我本人对MySQL的使用属于菜鸟级别，更没有太多数据库调优的经验，在这里大谈数据库索引调优有点大言不惭。就当是我个人的一篇学习笔记了。 其实数据库索引调优是一项技术活，不能仅仅靠理论，因为实际情况千变万化，而且MySQL本身存在很复杂的机制，如查询优化策略和各种引擎的实现差异等都会使情况变得更加复杂。但同时这些理论是索引调优的基础，只有在明白理论的基础上，才能对调优策略进行合理推断并了解其背后的机制，然后结合实践中不断的实验和摸索，从而真正达到高效使用MySQL索引的目的。 另外，MySQL索引及其优化涵盖范围非常广，本文只是涉及到其中一部分。如与排序（ORDER BY）相关的索引优化及覆盖索引（Covering index）的话题本文并未涉及，同时除B-Tree索引外MySQL还根据不同引擎支持的哈希索引、全文索引等等本文也并未涉及。如果有机会，希望再对本文未涉及的部分进行补充吧。 参考文献[1] Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010 [2] Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006 [3] 姜承尧 著；MySQL技术内幕-InnoDB存储引擎；机械工业出版社，2011 [4] D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979 [5] Codd, E. F. (1970). “A relational model of data for large shared data banks”. Communications of the ACM, , Vol. 13, No. 6, pp. 377-387 [6] MySQL5.1参考手册 - http://dev.mysql.com/doc/refman/5.1/zh/index.html","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell,github.io/tags/笔记/"},{"name":"MySQL","slug":"MySQL","permalink":"http://londbell,github.io/tags/MySQL/"},{"name":"收藏","slug":"收藏","permalink":"http://londbell,github.io/tags/收藏/"},{"name":"转载","slug":"转载","permalink":"http://londbell,github.io/tags/转载/"},{"name":"数据库","slug":"数据库","permalink":"http://londbell,github.io/tags/数据库/"},{"name":"数据结构","slug":"数据结构","permalink":"http://londbell,github.io/tags/数据结构/"}]},{"title":"阅读列表","date":"2017-04-10T07:49:11.000Z","path":"2017/04/10/阅读列表/","text":"https://exvim.github.io/docs-zh/intro/https://github.com/hehonghui/android-tech-frontier/blob/master/issue-36/Gradle%E5%B0%8F%E7%9F%A5%E8%AF%862.mdhttp://hukai.me/android-training-course-in-chinese/index.html","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell,github.io/tags/笔记/"}]},{"title":"在滚动列表中播放视频","date":"2017-04-10T02:35:00.000Z","path":"2017/04/10/在滚动列表中播放视频/","text":"原文链接 : Implementing video playback in a scrolled list (ListView &amp; RecyclerView) 原文作者 : Danylo Volokh 译文出自 : 开发技术前线 www.devtf.cn 本篇博文将会介绍如何实现在列表中播放视频，具体效果参见：Facebook，Instagram 或 Magiston： ###Facebook: ###Magisto: ###Instagram: 博文内容基于此Github 项目：VideoPlayerManager. 博文中涉及的所有代码和范例都在该项目中，所以本篇博文不会详细讲解每一个细节。如果有人真的想知道实现的机制，最好是下载源码，结合 IDE 边看源码边阅读本文。不过就算你不结合源码，光看我在这里说的内容，也能理解的七七八八了。 ##两个问题 为了实现这个功能，我们需要解决以下两个问题： 管理视频播放。在 Android 框架层中我们可以利用 MediaPlayer 和 SurfaceView 来播放视频，但这种实现方式有许多缺点。我们不能在列表中使用一般的 VideoView，因为 VideoView 是 SurfaceView 的子类，而 SurfaceView 不具有 UI 异步缓存。而这会导致我们无法在滚动时记录视频到底播放到哪个时间点。TextureView 具有 UI 异步缓存，但在 Android SDK 15 没有 VideoView 的实现方式是借助 TextureView 来完成的。因此，我们需要一个 TextureView 的子类与 MediaPlayer 协作完成视频播放的功能。当然了，MediaPlayer 中的所有方法（准备，开始，停止等等……）几乎都是调用与硬件交互的内核层代码。而硬件往往意味着复杂，如果我们需要完成的任何工作的耗时超过 16ms（一般都会），就会看到滞后的视频列表。这也是为什么需要在后台线程中调用它们的原因。 我们还需要知道滚动列表中的哪一个 View 要被激活（播放视频），所以我们还需要追踪用户的滚动行为并定义可见域最大的 View。 ##管理视频播放 我们希望提供以下功能： 假设某个视频正在播放，此时用户滚动了列表使得列表中某个子项目的可见域大于正在播放视频的子项目的可见域，这样我们就需要停止正在播放的视频，并开始播放新的视频（可见域更大的子项目对应的视频）。 ##VideoPlayerView 我们要做的第一件事就是以 TextureView 为父类实现 VideoView。而且我们在滚动列表中不能使用系统的 VideoView，因为用户在视频播放的过程中滚动列表的话，视频渲染就会乱掉。 我把这部分工作分为几个部分： 创建继承于 TextureView 的 ScalableTextureView，它能够调整 SurfaceTexture（正在播放视频的表面结构中）而且提供了一些类似于 ImageView 缩放类型的选项。 123public enum ScaleType &#123; CENTER_CROP, TOP, BOTTOM, FILL&#125; 创建 ScalableTextureView 的子类 VideoPlayerView，它包含所有与 MediaPlayer 相关的功能。即，这是一个封装了 MediaPlayer 并提供与 VideoView 几近一致的 API 的自定义 View。VideoPlayerView 具有所有直接调用 MediaPlayer 的方法：setDataSource，prepare, start, stop, pause, reset, release。 ##ViedioPlayer 管理器及消息控制机制 视频播放管理器与负责异步调用 MediaPlayer 方法的 MessageHandlerThread 协作。因为我们需要调用的方法，如：prepare(), start() 等等……与硬件直接相关，所以我们需要在一个独立的线程中完成这些调用。此外，当我们在 UI 线程中调用 MediaPlayer.reset() MediaPlayer 会发生一些奇怪的问题，使得该方法阻塞了将近 4 分钟！这也是我们不必须调用异步的 MediaPlayer.prepareAsync() 方法的原因，因为我们完全可以在另一个线程中调用 MediaPlayer.prepare() 方法，免得让这些奇怪的问题折腾自己。因此，我们将在一个独立的线程中异步完成所有任务。 在开始新的视频播放任务的事件流中，下面是一些与 MediaPlayer 相关的步骤： 停止前一个播放任务，通过调用 MediaPlayer.stop() 方法完成。 通过调用 MediaPlayer.reset 方法重置 MediaPlayer。之所以需要这样做是因为：在滚动列表中，View 可能会被重用，而我们想要释放所有的资源。 通过调用 MediaPlayer.release() 方法释放 MediaPlayer 占用的资源。 清除 MediaPlayer 的实例，当 View 执行新的播放任务时，创建新的 MediaPlayer 实例。 为新的可见域最大的 View 创建 MediaPlayer 实例。 调用 MediaPlayer.setDataSource(String url) 为新的 MediaPlayer 设置数据源。 调用 MediaPlayer.prepare() 方法而不是 MediaPlayer.prepareAsync()。 调用 MediaPlayer.start()。 等待播放开始。 以上所有行为都被包裹到 Message 中，交给一个独立的线程完成，例如这是一个 Stop 命令的 Message，它将调用 VideoPlayerView.stop()，实际上他调用的是 MediaPlayer.stop()。我们需要自定义 Message，因为我们可能需要设置当前状态，例如现在是正在停止，还是已经停止，或者是其他的状态……这有助于我们了解当前处理的 Message 是什么命令，如果我们需要用这个命令的话我们可以做什么，例如，开始一个新的播放任务。 1234567891011121314151617181920212223/** * This PlayerMessage calls &#123;@link MediaPlayer#stop()&#125; on the instance that is used inside &#123;@link VideoPlayerView&#125; */public class Stop extends PlayerMessage &#123; public Stop(VideoPlayerView videoView, VideoPlayerManagerCallback callback) &#123; super(videoView, callback); &#125; @Override protected void performAction(VideoPlayerView currentPlayer) &#123; currentPlayer.stop(); &#125; @Override protected PlayerMessageState stateBefore() &#123; return PlayerMessageState.STOPPING; &#125; @Override protected PlayerMessageState stateAfter() &#123; return PlayerMessageState.STOPPED; &#125;&#125; 如果我们需要开始一个新的播放任务，我们只需要调用 VideoPlayerManager 的一个方法，它就会添加下列 Message 到 MessagesHandlerThread 中： 12345678910111213141516// pause the queue processing and check current state// if current state is \"started\" then stop old playbackmPlayerHandler.addMessage(new Stop(mCurrentPlayer, this));mPlayerHandler.addMessage(new Reset(mCurrentPlayer, this));mPlayerHandler.addMessage(new Release(mCurrentPlayer, this));mPlayerHandler.addMessage(new ClearPlayerInstance(mCurrentPlayer, this));// set new video player viewmPlayerHandler.addMessage(new SetNewViewForPlayback(newVideoPlayerView, this));// start new playbackmPlayerHandler.addMessages(Arrays.asList( new CreateNewPlayerInstance(videoPlayerView, this), new SetAssetsDataSourceMessage(videoPlayerView, assetFileDescriptor, this), // I use local file for demo new Prepare(videoPlayerView, this), new Start(videoPlayerView, this)));// resume queue processing 这些 Message 都是异步处理的，因此我们能在任意时刻停止消息队列对消息的处理，并投递新的消息，例如： 当前一个影片处于准备状态（已经调用了 MediaPlayer.prepare() 方法，而且 MediaPlayer.start() 方法正在消息队列中等待被执行），此时用户滚动了列表，所以我们需要在一个新的 View 上开始新的播放任务。在这种情况下我们会： 停止正在执行的消息队列 移除所有等待执行的消息 投递 “Stop”, “Reset”, “Release”, “Clear Player instance” 这些消息给消息队列，它们将会在 Prepare 消息回调方法执行完成后立刻被执行。 投递 “Create new Media Player instance”, “Set Current Media Player”（将 MediaPlayer 对象绑定到当前需要播放视频的消息上），“Set data source”, “Prepare”, “Start”等消息。这样就会在新的 View 上播放相应的视频。 这样我们就能依照我们设想的那样执行播放任务：停止前一个播放任务，并开始新的播放任务。 下面是相关的依赖： 123dependencies &#123; compile &apos;com.github.danylovolokh:video-player-manager:0.2.0&apos;&#125; ##区分列表中可见域最大的 View——列表可见域判断工具 第一个问题是控制视频的播放，第二个问题则是判断哪一个 View 可见域最大，并切换该 View 对应的视频为新的播放视频。下面是调用 ListItemsVisibilityCalculator 的实体，它的具体实现 SingleListViewItemActiveCalculator 会完成对应的工作。 在 Adapter 中被使用的 Model 类必须实现 ListItem 接口，以计算 List 中子项目的可见域： 1234567891011121314151617181920212223242526272829303132333435/** * A general interface for list items. * This interface is used by &#123;@link ListItemsVisibilityCalculator&#125; * * @author danylo.volokh */public interface ListItem &#123; /** * When this method is called, the implementation should provide a * visibility percents in range 0 - 100 % * @param view the view which visibility percent should be * calculated. * Note: visibility doesn't have to depend on the visibility of a * full view. * It might be calculated by calculating the visibility of any * inner View * * @return percents of visibility */ int getVisibilityPercents(View view); /** * When view visibility become bigger than \"current active\" view * visibility then the new view becomes active. * This method is called */ void setActive(View newActiveView, int newActiveViewPosition); /** * There might be a case when not only new view becomes active, * but also when no view is active. * When view should stop being active this method is called */ void deactivate(View currentView, int position);&#125; ListItemsVisibilityCalculator 将追踪滚动方向，并在运行时计算子项目的可见域。子项目的可见域依赖于列表中的任意一个咨询项目，即取决于你实现 getVisibilityPercents() 方法的方式： 123456789101112131415161718192021222324/** * This method calculates visibility percentage of currentView. * This method works correctly when currentView is smaller then it's enclosure. * @param currentView - view which visibility should be calculated * @return currentView visibility percents */@Overridepublic int getVisibilityPercents(View currentView) &#123; int percents = 100; currentView.getLocalVisibleRect(mCurrentViewRect); int height = currentView.getHeight(); if(viewIsPartiallyHiddenTop())&#123; // view is partially hidden behind the top edge percents = (height - mCurrentViewRect.top) * 100 / height; &#125; else if(viewIsPartiallyHiddenBottom(height))&#123; percents = mCurrentViewRect.bottom * 100 / height; &#125; return percents;&#125; 因此，每一个 View 都需要知道计算其可见域的细节。当发生滚动时，SingleListViewItemActiveCalculator 会要求每一个 View 计算其可见域大小，这也意味其开销之重。 当任意一个子项目的可见域大小超过了当前播放视频项目的可见域大小，就会调用 setActive 方法切换播放任务。 下面是与 Adapter 功能类似的的 ItemsPositionGetter 的抽象逻辑，它将建立 ListItemsVisibilityCalculator 与 ListView/RecyclerView 交互的桥梁。这样的话 ListItemsVisibilityCalculator 不需要了解它需要操作的 View 到底是 ListView 还是 RecyclerView。只需要完成它自己的工作，但仍需要一些由 ItemsPositionGetter 提供的信息。 123456789101112131415161718192021222324/** * This class is an API for &#123;@link ListItemsVisibilityCalculator&#125; * Using this class is can access all the data from RecyclerView / * ListView * * There is two different implementations for ListView and for * RecyclerView. * RecyclerView introduced LayoutManager that's why some of data moved * there * * Created by danylo.volokh on 9/20/2015. */public interface ItemsPositionGetter &#123; View getChildAt(int position); int indexOfChild(View view); int getChildCount(); int getLastVisiblePosition(); int getFirstVisiblePosition();&#125; 这样的实现无疑会让 Model 类混入一些业务逻辑，违反了设计模式的部分原则。但通过一些简单的修改就能将它们解耦。不过现在这样它用起来也没多大的问题。 下面是预览图和依赖： 123dependencies &#123; compile &apos;com.github.danylovolokh:list-visibility-utils:0.2.0&apos;&#125; ##组合使用上面完成的工作 现在我们需要将上面的工具库结合起来使用以完成我们的功能，下面是使用 RecyclerView 实现的代码： 初始化 ListItemsVisibilityCalculator，并传递列表的引用 123456/** * Only the one (most visible) view should be active (and playing). * To calculate visibility of views we use &#123;@link SingleListViewItemActiveCalculator&#125; */private final ListItemsVisibilityCalculator mVideoVisibilityCalculator = new SingleListViewItemActiveCalculator(new DefaultSingleItemCalculatorCallback(), mList); 当被激活（播放视频）的 View 发生改变，DefaultSingleItemCalculatorCallback 只调用 ListItem.setActive 方法，但你可以重载该方法并按照你的需求实现相应逻辑： 12345678/** * Methods of this callback will be called when new active item is found &#123;@link Callback#activateNewCurrentItem(ListItem, View, int)&#125; * or when there is no active item &#123;@link Callback#deactivateCurrentItem(ListItem, View, int)&#125; - this might happen when user scrolls really fast */public interface Callback&lt;T extends ListItem&gt;&#123; void activateNewCurrentItem(T item, View view, int position); void deactivateCurrentItem(T item, View view, int position);&#125; 初始化 VideoPlayerManager 123456789/** * Here we use &#123;@link SingleVideoPlayerManager&#125;, which means that only one video playback is possible. */private final VideoPlayerManager&lt;MetaData&gt; mVideoPlayerManager = new SingleVideoPlayerManager(new PlayerItemChangeListener() &#123; @Override public void onPlayerItemChanged(MetaData metaData) &#123; &#125;&#125;); 为 RecyclerView 设置滚动监听，并传递滚动事件给列表可见工具库处理。 123456789101112131415161718192021222324@Overridepublic void onScrollStateChanged(RecyclerView view, int scrollState) &#123; mScrollState = scrollState; if(scrollState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mList.isEmpty())&#123; mVideoVisibilityCalculator.onScrollStateIdle( mItemsPositionGetter, mLayoutManager.findFirstVisibleItemPosition(), mLayoutManager.findLastVisibleItemPosition()); &#125; &#125;@Overridepublic void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; if(!mList.isEmpty())&#123; mVideoVisibilityCalculator.onScroll( mItemsPositionGetter, mLayoutManager.findFirstVisibleItemPosition(), mLayoutManager.findLastVisibleItemPosition() - mLayoutManager.findFirstVisibleItemPosition() + 1, mScrollState); &#125;&#125;&#125;); 创建 ItemsPositionGetter 12ItemsPositionGetter mItemsPositionGetter = new RecyclerViewItemPositionGetter(mLayoutManager, mRecyclerView); 在 onResume() 中调用方法以开始计算子项目的可见域，在我们显示出列表时选出可见域最大的子项目 12345678910111213141516171819@Overridepublic void onResume() &#123; super.onResume(); if(!mList.isEmpty())&#123; // need to call this method from list view handler in order to have filled list mRecyclerView.post(new Runnable() &#123; @Override public void run() &#123; mVideoVisibilityCalculator.onScrollStateIdle( mItemsPositionGetter, mLayoutManager.findFirstVisibleItemPosition(), mLayoutManager.findLastVisibleItemPosition()); &#125; &#125;); &#125;&#125; 然后就完成了，在滚动列表中播放许多视频： 这个项目关键部分的讲解基本上已经完成了，下面是具体的代码和范例： https://github.com/danylovolokh/VideoPlayerManager 感谢阅读 ;)","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell,github.io/tags/笔记/"},{"name":"收藏","slug":"收藏","permalink":"http://londbell,github.io/tags/收藏/"},{"name":"转载","slug":"转载","permalink":"http://londbell,github.io/tags/转载/"},{"name":"android","slug":"android","permalink":"http://londbell,github.io/tags/android/"},{"name":"java","slug":"java","permalink":"http://londbell,github.io/tags/java/"}]},{"title":"高性能ListViews","date":"2017-04-10T02:34:00.000Z","path":"2017/04/10/高性能ListViews/","text":"原文链接 : Performance ListViews 原文作者 : Brandon 译文出自 : 开发技术前线 www.devtf.cn。未经允许，不得转载! 列表展示功能几乎在所有app中都会被用到，使用列表可以很方便的展示一些列表项，比如菜谱、联系人，或者任意类型的类别。所以Android有一个内置的方式来展示此类型的数据，也是在情理之中的。RecyclerView是一种最新的展示列表数据的方式，它非常高效，因为它重用视图而不是每一行出现在屏幕上都重新创建。在RecyclerView出现之前，我们可以使用ListView，即使到了现在，ListView也是广泛的被开发者所使用。虽然ListView也是可以回收视图的，但它也一直都是Android中最容易被错误使用的一个控件。我们知道在此之前这个话题已经被写过无数遍了，但是今天我还是要在博客中提出来，因为我们仍然发现很多app在错误的使用它们。 关于ListView中ArrayAdapter的用法，标准的新手写法是这样子的： 1234567891011121314@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; LayoutInflater inflater = (LayoutInflater) context .getSystemService(Context.LAYOUT_INFLATER_SERVICE); View rowView = inflater.inflate(R.layout.view_test_row, parent, false); TextView testName = (TextView)rowView.findViewById(R.id.text_view_test_name); TextView testDesc = (TextView)rowView.findViewById(R.id.text_view_test_desc); //modify TextViews, in some arbitrary way return rowView;&#125; 当所有列表项都能够一次性在一屏中显示的时候，这种写法并没有什么问题，但这样你就创建了一个基本视图，并完全避免了ArrayAdapter的麻烦了吗？当ListView需要显示一个很大的列表集，而且列表子项是一个非常复杂的视图的时候，上面的方式会消耗大量的性能。当用户滑动屏幕的时候，每个视图都会被inflate并且调用findViewById()方法。当findViewById()方法被调用的时候，会遍历整个视图层级，直到找到正确的Id。每个子视图都要执行上述过程！并且用户滑动的越快，卡顿现象愈加明显。为了解决这个问题，我们可以使用一个静态类来绑定还没被使用的convertView。 123456789101112131415161718192021222324252627282930313233static class ViewHolder()&#123; TextView testName; TextView testDesc; &#125;@Override public View getView(int position, View convertView, ViewGroup parent) &#123; View rowView = convertView; //reference to one of the previous Views in the list that we can reuse. if(convertView == null) &#123; LayoutInflater inflater = (LayoutInflater) context .getSystemService(Context.LAYOUT_INFLATER_SERVICE); rowView = inflater.inflate(R.layout.view_test_row, parent, false); ViewHolder viewHolder = new ViewHolder(); viewHolder.testName = (TextView) rowView.findViewById(R.id.text_view_test_name); viewHolder.testDesc = (TextView) rowView.findViewById(R.id.text_view_test_desc); rowView.setTag(viewHolder); &#125; ViewHolder holder = (ViewHolder) rowView.getTag(); //in real code these strings should be in res holder.testName.setText(&quot;Test&quot;+position); holder.testDesc.setText(&quot;This is number &quot;+position); return rowView;&#125; 那convertView又是什么呢？它可以让ListView跳过一些显示一行内容所需要的设置。如果某一行的视图不在屏幕中显示，我们可以重复使用这个视图来显示一个新行。当ListView刚开始显示的时候，一切都是正常的。既然没有视图可以被用来复用，convertView为空。视图也像前面版本一样被inflate，但是TextViews会被找到且它的引用被保存在一个ViewHolder中。然后我们可以调用setTag()方法将ViewHolder存储在视图中。正如修订过后的getView()方法中后半段代码所示，我们可以在视图中存储后面我们需要用到的数据。 我们所做的更改可能看起来并没有太大的效果，但是随着布局越来越复杂并且数量也越来越多，效果将变得越来越明显。作为开发者，我最不想做的事就是开发一个用户体验很差的app。所以请记住，仅仅一个低水平的ListView都有可能让一个app死掉，我们一定得避免这种情况发生。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell,github.io/tags/笔记/"},{"name":"收藏","slug":"收藏","permalink":"http://londbell,github.io/tags/收藏/"},{"name":"转载","slug":"转载","permalink":"http://londbell,github.io/tags/转载/"},{"name":"android","slug":"android","permalink":"http://londbell,github.io/tags/android/"},{"name":"java","slug":"java","permalink":"http://londbell,github.io/tags/java/"}]},{"title":"55-Jump-Game","date":"2017-04-06T14:38:09.000Z","path":"2017/04/06/55-Jump-Game/","text":"题目描述Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example:A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. 给定一个数组，里面没有负数，都是正整数，每个元素存了最多可以走几步，现在问你能不能走到终点。 用贪心算法比较合适。[原题地址]https://leetcode.com/problems/jump-game/#/description) 我的解法：1234567891011121314151617181920212223class Solution &#123; public boolean canJump(int[] nums) &#123; if(nums.length == 1) &#123; return true; &#125; int max = 0; for(int i = 0; i &lt; nums.length; i ++) &#123; if(i &lt;= max) &#123; max = Math.max(i + nums[i], max); if(max &gt;= nums.length - 1) &#123; return true; &#125; &#125; &#125; if(max &lt; nums.length - 1) &#123; return false; &#125;else &#123; return true; &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"521-longest-Uncommon-Subsequence-I","date":"2017-04-06T12:12:48.000Z","path":"2017/04/06/521-longest-Uncommon-Subsequence-I/","text":"题目描述Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1. Example 1:12345Input: &quot;aba&quot;, &quot;cdc&quot;Output: 3Explanation: The longest uncommon subsequence is &quot;aba&quot; (or &quot;cdc&quot;), because &quot;aba&quot; is a subsequence of &quot;aba&quot;, but not a subsequence of any other strings in the group of two strings. Note: Both strings&apos; lengths will not exceed 100. Only letters from a ~ z will appear in input strings. 给定两个字符串，计算其“最长不公共子序列”。最长不公共子序列是指：两字符串中某一个的子序列，该子序列不是另一个字符串的子序列，并且长度最长。 子序列是指从一个序列中删除一些字符，剩余字符顺序保持不变得到的新序列。任何字符串都是其本身的子序列，空串不属于任意字符串的子序列。 返回最长不公共子序列，若不存在，返回-1。 原题地址若两字符串不相等，选择较长的字符串返回长度即可。 否则返回-1。（若两字符串相等，则任意字符串的子串均为另一个的子串） 我的解法：123456789class Solution &#123; public int findLUSlength(String a, String b) &#123; if(a.equals(b)) &#123; return -1; &#125;else &#123; return Math.max(a.length(), b.length()); &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"Windows-Hpyer-V-Fix","date":"2017-03-30T02:46:58.000Z","path":"2017/03/30/Windows-Hpyer-V-Fix/","text":"在Windows 10操作系统中，微软为其搭载了自家的服务器虚拟化技术 Hyper-V，只需要在功能中启动即可创建并运行需要的的虚拟机实现操作系统测试或服务器虚拟化的工作。 但有的时候除了 Hyper-V 之外，还需要运行 VMware 的虚拟机，但如果在系统中同时安装着两个虚拟机平台， VMware、VM VirtualBox虚拟机都不能运行，提示与Hyper-V不兼容。 所以可以这样解决：1231、运行 bcdedit /copy &#123;current&#125; /d “Windows 10 (关闭 Hyper-V)” 命令，随后会提示已经创建了另外一个启动菜单项，记下 &#123; &#125; 中的一串代码。 2、运行 bcdedit /set &#123;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&#125; hypervisorlaunchtype OFF 命令，将上面的代码替换掉这里的红色XXX代码即可 再次启动 Windows 10 即可手动选择是否要启用 Hyper-V，在“关闭 Hyper-V”的模式中，即可运行 Vmware 虚拟机，而另一个选项则可以运行 Hyper-V 虚拟机，这样就可以避免为了运行 VMware 虚拟机而卸载 Hyper-V 功能了。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell,github.io/tags/笔记/"}]},{"title":"Spiral Matrix","date":"2017-03-28T05:03:00.000Z","path":"2017/03/28/leetcode-54-spiral-matrix/","text":"题目描述给出一个M X N的矩阵，以螺旋方式给出其序列。Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example,Given the following matrix:12345[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] You should return [1,2,3,6,9,8,7,4,5]. 原题地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123; public static List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); boolean flagSub = true; if(matrix.length == 0) &#123; return list; &#125; do &#123; boolean [][]flag = new boolean[matrix.length][matrix[0].length]; for(int i = 0; i &lt; matrix[0].length; i++) &#123; list.add(matrix[0][i]); flag[0][i] = true; &#125; for (boolean[] e: flag) &#123; for (boolean q : e) &#123; q = false; &#125; &#125; for(int i = 1; i &lt; matrix.length; i++) &#123; if (!flag[i][matrix[0].length - 1]) &#123; list.add(matrix[i][matrix[0].length - 1]); flag[i][matrix[0].length - 1] = true; &#125; &#125; for(int i = matrix[0].length - 2; i &gt;= 0; i--) &#123;// i = 0的边界条件 if(!flag[matrix.length-1][i]) &#123; list.add(matrix[matrix.length - 1][i]); flag[matrix.length - 1][i] = true; &#125; &#125; for(int i = matrix.length - 2; i &gt; 0; i--) &#123; if(!flag[i][0]) &#123; list.add(matrix[i][0]); flag[i][0] = true; &#125; &#125; flagSub = matrix.length &gt;2 &amp;&amp; matrix[0].length &gt;2; if(flagSub) &#123; matrix = getSubMatrix(matrix); &#125; &#125;while(flagSub); return list; &#125; public static int[][] getSubMatrix(int[][] matrix) &#123; int[][] subMatrix = new int[matrix.length - 2][matrix[0].length -2]; for(int i = 1; i &lt; matrix.length - 1; i ++) &#123; for(int j = 1; j &lt; matrix[0].length - 1; j++) &#123; subMatrix[i - 1][j - 1] = matrix[i][j]; &#125; &#125; return subMatrix; &#125;&#125; 这种做法比较蠢，有大佬这样做，用方向矩阵的方式来做：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* Solution 3: 使用方向矩阵来求解 */ public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;(); if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return ret; &#125; int rows = matrix.length; int cols = matrix[0].length; int visitedRows = 0; int visitedCols = 0; // indicate the direction of x // 1: means we are visiting the row by the right direction. // -1: means we are visiting the row by the left direction. int[] x = &#123;1, 0, -1, 0&#125;; // 1: means we are visiting the colum by the down direction. // -1: means we are visiting the colum by the up direction. int[] y = &#123;0, 1, 0, -1&#125;; // 0: right, 1: down, 2: left, 3: up. int direct = 0; int startx = 0; int starty = 0; int candidateNum = 0; int step = 0; while (true) &#123; if (x[direct] == 0) &#123; // visit Y axis. candidateNum = rows - visitedRows; &#125; else &#123; // visit X axis candidateNum = cols - visitedCols; &#125; if (candidateNum &lt;= 0) &#123; break; &#125; ret.add(matrix[startx][starty]); step++; if (step == candidateNum) &#123; step = 0; visitedRows += x[direct] == 0 ? 0: 1; visitedCols += y[direct] == 0 ? 0: 1; // move forward the direction. direct ++; direct = direct%4; &#125; // 根据方向来移动横坐标和纵坐标。 startx += y[direct]; starty += x[direct]; &#125; return ret; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"},{"name":"矩阵","slug":"矩阵","permalink":"http://londbell,github.io/tags/矩阵/"}]},{"title":"Factorial Trailing Zeroes","date":"2017-03-28T02:03:00.000Z","path":"2017/03/28/leetcode-172-factorial-trailing-zeroes/","text":"题目描述给出一个整数N，求N阶乘中有几个0。 乘法得到0就是2*5，2的数量不知比5多到哪里去了，只要计算5的数量就行，那就一直除于5，计算即可。 Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 原题地址12345678910public class Solution &#123; public int trailingZeroes(int n) &#123; int count = 0; while(n != 0) &#123; n /= 5; count += n; &#125; return count; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"Edit Distance","date":"2017-03-27T13:42:00.000Z","path":"2017/03/27/leetcode-72-Edit-Distance/","text":"题目描述给出两个字符串，看S1最少需要几步可以变成S2？1.可以插入一个字符。2.可以删除一个字符。3.可以替换一个字符。 Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: a) Insert a characterb) Delete a characterc) Replace a character 解题思路：图中表示的是，将s1:Park变成s:Spake的最小操作步数,dp[i][j] 表示从s1的前i位，变到s2的前j位，最小需要多少改变 比如我们看矩阵的第一行，分别代表从” “(空字符)变到”s”, 变到”sp”，变到”spa”,变到”spak”，变到”spake” 需要多少次改变，因为每次只能选择往上添加一个字符，所以累加操作数分别为1,2,3,4,5 同理，矩阵的第一列分别代表从”p” 变到” “(空字符)，从”pa“变空，从”par“变空,从”park”变空需要多少次改变，因为每次只能选择删去一个字符，所以累加操作数分别为1,2,3,4 可以参考图中绿色字体的那个例子 下箭头： 我们现在已经知道了从” “ 到”s“的距离，那么从”p” 到’’s” 我们只要删去这个p就行了 （Delete） 右箭头： 我们现在已经知道了从”p“到” “的距离，那么从”p” 到”s” 我们只要插入这个s就行了 （Insert） 右下箭头： 我们现在已经知道了从” “到” “的距离，那么从”p” 到”s” 我们只需要把p替换成s就行了(Replace) 注意替换的时候，如果i所代表的的字符 == j所代表的字符，那么我们便不需要做任何多余的操作（No Operation） 原题地址1234567891011121314151617181920212223242526class Solution &#123; public int minDistance(String word1, String word2) &#123; int dp[][] = new int[word1.length() + 1][word2.length() + 1]; dp[1][0] = 0; for(int i = 1; i &lt;= word1.length(); i++) &#123; dp[i][0] = dp[i - 1][0] + 1; &#125; for(int i = 1; i &lt;= word2.length(); i++) &#123; dp[0][i] = dp[0][i - 1] + 1; &#125; for(int i = 1; i &lt;= word1.length(); i++) &#123; for(int j = 1; j &lt;= word2.length(); j++) &#123; if(word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1]; //状态转移，说明此时不需要任何操作 &#125;else &#123; dp[i][j] = 1 + Math.min(dp[i][j-1], Math.min(dp[i-1][j], dp[i-1][j-1])); &#125; &#125; &#125; return dp[word1.length()][word2.length()]; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://londbell,github.io/tags/动态规划/"},{"name":"字符串","slug":"字符串","permalink":"http://londbell,github.io/tags/字符串/"}]},{"title":"Interleaving String","date":"2017-03-27T12:42:00.000Z","path":"2017/03/27/leetcode-97-Interleaving-String/","text":"题目描述给出三个字符串，看S1和S2能否交叉取char字符组成S3 Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example,Given:s1 = “aabcc”,s2 = “dbbca”, When s3 = “aadbbcbcac”, return true.When s3 = “aadbbbaccc”, return false. 解题思路：DP[i][j]存的是取S1的i个字符，取S2的j个字符情况下，能否构成S3;由于存的是“个数”，所以对应到String操作上是i+1,要注意另外需要注意第二次运算交集时要并上本身（第一次运算说明本路径是有效的）。 原题地址123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public static boolean isInterleave(String s1, String s2, String s3) &#123; if(s1 == \"\" || s2 == \"\" || s3 == \"\") &#123; return false; &#125; if((s1.length() + s2.length()) != s3.length()) &#123; return false; &#125; boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1]; dp[0][0] = true; for(int m = 1; m &lt; s1.length() + 1; m++) &#123; if (s1.charAt(m - 1) == s3.charAt(m - 1)) &#123; dp[m][0] = true &amp;&amp; dp[m - 1][0]; &#125; else &#123; dp[m][0] = false; &#125; &#125; for(int m = 1; m &lt; s2.length() + 1; m++) &#123; if(s2.charAt(m - 1) == s3.charAt(m - 1)) &#123; dp[0][m] = true &amp;&amp; dp[0][m - 1]; &#125;else&#123; dp[0][m] = false; &#125; &#125; for(int m = 1; m &lt; s1.length() + 1; m++) &#123; for(int n = 1; n &lt; s2.length() + 1; n++) &#123; if(s1.charAt(m - 1) == s3.charAt(m + n - 1)) &#123; dp[m][n] = true &amp;&amp; dp[m-1][n]; &#125; if(s2.charAt(n - 1) == s3.charAt(m + n - 1)) &#123; dp[m][n] = (true &amp;&amp; dp[m][n-1]) || dp[m][n];//防止前面的true被交集运算后得到false &#125; &#125; &#125; for(int m = 0; m &lt; s1.length() + 1; m++) &#123; for(int n = 0; n &lt; s2.length() + 1; n++) &#123; //System.out.println(dp[m][n]); &#125; &#125; return dp[s1.length()][s2.length()]; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode - 动态规划 - 字符串","slug":"LeetCode-动态规划-字符串","permalink":"http://londbell,github.io/tags/LeetCode-动态规划-字符串/"}]},{"title":"Subsets","date":"2017-03-27T11:09:00.000Z","path":"2017/03/27/leetcode-78-Subsets/","text":"题目描述给出一个数组，每个元素均不同，给出所有他的子集 Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 原题地址12345678910111213141516class Solution &#123; public static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;(); int total = 2 &lt;&lt; (nums.length) - 1; for(int i = 0;i &lt; total; i ++) &#123; List&lt;Integer&gt; temp = new LinkedList&lt;&gt;(); for(int j = 0; j &lt; nums.length; j++) &#123; if((i &amp; (1 &lt;&lt; j)) != 0) &#123;//不能写==1，注意 temp.add(nums[j]); &#125; &#125; list.add(temp); &#125; return list; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"等价交换","date":"2017-03-26T16:34:00.000Z","path":"2017/03/27/diary-2017-0327-0034/","text":"人没有牺牲就什么都得不到，为了得到什么东西，就需要付出同等的代价。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://londbell,github.io/tags/随笔/"}]},{"title":"Java 快速参考教程","date":"2016-04-12T10:47:22.000Z","path":"2016/04/12/Java-快速参考教程/","text":"快速参考教程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367// 单行注释/*多行注释*//**JavaDoc（Java文档）注释是这样的。可以用来描述类和类的属性。*/// 导入 java.util中的 ArrayList 类import java.util.ArrayList;// 导入 java.security 包中的所有类import java.security.*;// 每个 .java 文件都包含一个public类，这个类的名字必须和这个文件名一致。public class LearnJava &#123; // 每个程序都需要有一个main函数作为入口 public static void main (String[] args) &#123; // 使用 System.out.println 来输出到标准输出 System.out.println(\"Hello World!\"); System.out.println( \"Integer: \" + 10 + \" Double: \" + 3.14 + \" Boolean: \" + true); // 如果要在输出后不自动换行，可以使用System.out.print方法。 System.out.print(\"Hello \"); System.out.print(\"World\"); /////////////////////////////////////// // 类型与变量 /////////////////////////////////////// // 用 &lt;type&gt; &lt;name&gt; 来声明变量 // 字节类型 - 8位补码表示 // (-128 &lt;= 字节 &lt;= 127) byte fooByte = 100; // 短整型 - 16位补码表示 // (-32,768 &lt;= 短整型 &lt;= 32,767) short fooShort = 10000; // 整型 - 32位补码表示 // (-2,147,483,648 &lt;= 整型 &lt;= 2,147,483,647) int fooInt = 1; // 长整型 - 64位补码表示 // (-9,223,372,036,854,775,808 &lt;= 长整型 &lt;= 9,223,372,036,854,775,807) long fooLong = 100000L; // L可以用来表示一个数字是长整型的。 // 其他的数字都默认为整型。 // 注意：Java中没有无符号类型 // 浮点型 - 即 IEEE 754 规定的32位单精度浮点类型 float fooFloat = 234.5f; // f用来表示一个数字是浮点型的。 // 否则会被默认当做是双精度浮点型。 // 双精度浮点型 - 即 IEEE 754 规定的64位双精度浮点类型 double fooDouble = 123.4; // 布尔类型 - true 与 false boolean fooBoolean = true; boolean barBoolean = false; // 字符类型 - 16位 Unicode编码字符 char fooChar = 'A'; // 用 final 可以使一个常量不可更改 final int HOURS_I_WORK_PER_WEEK = 9001; // 字符串 String fooString = \"My String Is Here!\"; // \\n 代表一个新的换行 String barString = \"Printing on a new line?\\nNo Problem!\"; // \\t 代表一个新的制表符 String bazString = \"Do you want to add a tab?\\tNo Problem!\"; System.out.println(fooString); System.out.println(barString); System.out.println(bazString); // 数组 // 数组在声明时大小必须已经确定 // 数组的声明格式: //&lt;数据类型&gt; [] &lt;变量名&gt; = new &lt;数据类型&gt;[&lt;数组大小&gt;]; int [] intArray = new int[10]; String [] stringArray = new String[1]; boolean [] booleanArray = new boolean[100]; // 声明并初始化数组也可以这样: int [] y = &#123;9000, 1000, 1337&#125;; // 随机访问数组中的元素 System.out.println(\"intArray @ 0: \" + intArray[0]); // 数组下标从0开始并且可以被更改 intArray[1] = 1; System.out.println(\"intArray @ 1: \" + intArray[1]); // =&gt; 1 // 其他数据类型 // ArrayLists - 类似于数组，但是功能更多，并且大小也可以改变 // LinkedLists // Maps // HashMaps /////////////////////////////////////// // 操作符 /////////////////////////////////////// System.out.println(\"\\n-&gt;Operators\"); int i1 = 1, i2 = 2; // 多重声明可以简化 // 算数运算 System.out.println(\"1+2 = \" + (i1 + i2)); // =&gt; 3 System.out.println(\"2-1 = \" + (i2 - i1)); // =&gt; 1 System.out.println(\"2*1 = \" + (i2 * i1)); // =&gt; 2 System.out.println(\"1/2 = \" + (i1 / i2)); // =&gt; 0 (0.5 truncated down) // 取余 System.out.println(\"11%3 = \"+(11 % 3)); // =&gt; 2 // 比较操作符 System.out.println(\"3 == 2? \" + (3 == 2)); // =&gt; false System.out.println(\"3 != 2? \" + (3 != 2)); // =&gt; true System.out.println(\"3 &gt; 2? \" + (3 &gt; 2)); // =&gt; true System.out.println(\"3 &lt; 2? \" + (3 &lt; 2)); // =&gt; false System.out.println(\"2 &lt;= 2? \" + (2 &lt;= 2)); // =&gt; true System.out.println(\"2 &gt;= 2? \" + (2 &gt;= 2)); // =&gt; true // 位运算操作符 /* ~ 取反，求反码 &lt;&lt; 带符号左移 &gt;&gt; 带符号右移 &gt;&gt;&gt; 无符号右移 &amp; 和 ^ 异或 | 相容或 */ // 自增 int i = 0; System.out.println(\"\\n-&gt;Inc/Dec-rementation\"); // ++ 和 -- 操作符使变量加或减1。放在变量前面或者后面的区别是整个表达 // 式的返回值。操作符在前面时，先加减，后取值。操作符在后面时，先取值 // 后加减。 System.out.println(i++); // 后自增 i = 1, 输出0 System.out.println(++i); // 前自增 i = 2, 输出2 System.out.println(i--); // 后自减 i = 1, 输出2 System.out.println(--i); // 前自减 i = 0, 输出0 /////////////////////////////////////// // 控制结构 /////////////////////////////////////// System.out.println(\"\\n-&gt;Control Structures\"); // If语句和C的类似 int j = 10; if (j == 10)&#123; System.out.println(\"I get printed\"); &#125; else if (j &gt; 10) &#123; System.out.println(\"I don't\"); &#125; else &#123; System.out.println(\"I also don't\"); &#125; // While循环 int fooWhile = 0; while(fooWhile &lt; 100) &#123; //System.out.println(fooWhile); //增加计数器 //遍历99次， fooWhile 0-&gt;99 fooWhile++; &#125; System.out.println(\"fooWhile Value: \" + fooWhile); // Do While循环 int fooDoWhile = 0; do &#123; //System.out.println(fooDoWhile); //增加计数器 //遍历99次, fooDoWhile 0-&gt;99 fooDoWhile++; &#125;while(fooDoWhile &lt; 100); System.out.println(\"fooDoWhile Value: \" + fooDoWhile); // For 循环 int fooFor; //for 循环结构 =&gt; for(&lt;起始语句&gt;; &lt;循环进行的条件&gt;; &lt;步长&gt;) for(fooFor=0; fooFor&lt;10; fooFor++)&#123; //System.out.println(fooFor); //遍历 10 次, fooFor 0-&gt;9 &#125; System.out.println(\"fooFor Value: \" + fooFor); // Switch Case 语句 // switch可以用来处理 byte, short, char, 和 int 数据类型 // 也可以用来处理枚举类型,字符串类,和原始数据类型的包装类： // Character, Byte, Short, 和 Integer int month = 3; String monthString; switch (month)&#123; case 1: monthString = \"January\"; break; case 2: monthString = \"February\"; break; case 3: monthString = \"March\"; break; default: monthString = \"Some other month\"; break; &#125; System.out.println(\"Switch Case Result: \" + monthString); /////////////////////////////////////// // 类型转换 /////////////////////////////////////// // 数据转换 // 将字符串转换为整型 Integer.parseInt(\"123\");//返回整数123 // 将整型转换为字符串 Integer.toString(123);//返回字符串\"123\" // 其他的数据也可以进行互相转换: // Double // Long // String // 类型转换 // 你也可以对java对象进行类型转换, 但其中会牵扯到很多概念 // 在这里可以查看更详细的信息: // http://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html /////////////////////////////////////// // 类与函数 /////////////////////////////////////// System.out.println(\"\\n-&gt;Classes &amp; Functions\"); // (Bicycle类定义如下) // 用new来实例化一个类 Bicycle trek = new Bicycle(); // 调用对象的方法 trek.speedUp(3); // 需用getter和setter方法 trek.setCadence(100); // toString 可以把对象转换为字符串 System.out.println(\"trek info: \" + trek.toString()); &#125; // main 方法结束&#125; // LearnJava 类结束// 你也可以把其他的非public类放入到.java文件中// 类定义的语法:// &lt;public/private/protected&gt; class &lt;类名&gt;&#123;// //成员变量, 构造函数, 函数// //Java中函数被称作方法// &#125;class Bicycle &#123; // Bicycle 类的成员变量和方法 public int cadence; // Public: 任意位置均可访问 private int speed; // Private: 只在同类中可以访问 protected int gear; // Protected: 可以在同类与子类中可以访问 String name; // default: 可以在包内中可以访问 // 构造函数是初始化一个对象的方式 // 以下是一个默认构造函数 public Bicycle() &#123; gear = 1; cadence = 50; speed = 5; name = \"Bontrager\"; &#125; // 一下是一个含有参数的构造函数 public Bicycle(int startCadence, int startSpeed, int startGear, String name) &#123; this.gear = startGear; this.cadence = startCadence; this.speed = startSpeed; this.name = name; &#125; // 函数语法: // &lt;public/private/protected&gt; &lt;返回值类型&gt; &lt;函数名称&gt;(&lt;参数列表&gt;) // Java类中经常会用getter和setter来对成员变量进行操作 // 方法声明的语法: // &lt;作用域&gt; &lt;返回值类型&gt; &lt;方法名&gt;(&lt;参数列表&gt;) public int getCadence() &#123; return cadence; &#125; // void返回值函数没有返回值 public void setCadence(int newValue) &#123; cadence = newValue; &#125; public void setGear(int newValue) &#123; gear = newValue; &#125; public void speedUp(int increment) &#123; speed += increment; &#125; public void slowDown(int decrement) &#123; speed -= decrement; &#125; public void setName(String newName) &#123; name = newName; &#125; public String getName() &#123; return name; &#125; //返回对象属性的方法 @Override public String toString() &#123; return \"gear: \" + gear + \" cadence: \" + cadence + \" speed: \" + speed + \" name: \" + name; &#125;&#125; // Bicycle 类结束// PennyFarthing 是 Bicycle 的子类class PennyFarthing extends Bicycle &#123; // (Penny Farthings 是前轮很大的 Bicycle， 并且没有齿轮) public PennyFarthing(int startCadence, int startSpeed)&#123; // 通过super调用父类的构造函数 super(startCadence, startSpeed, 0, \"PennyFarthing\"); &#125; // 你可以用@注释来表示需要重载的方法 // 了解更多的注释使用方法，可以访问下面的地址： // http://docs.oracle.com/javase/tutorial/java/annotations/ @Override public void setGear(int gear) &#123; gear = 0; &#125;&#125;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell,github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"}]},{"title":"21分钟 MySQL 入门教程","date":"2016-04-10T10:50:56.000Z","path":"2016/04/10/21分钟-MySQL-入门教程/","text":"MySQL的相关概念介绍MySQL 为关系型数据库(Relational Database Management System), 这种所谓的”关系型”可以理解为”表格”的概念, 一个关系型数据库由一个或数个表格组成, 如图所示的一个表格: 表头(header): 每一列的名称; 列(row): 具有相同数据类型的数据的集合; 行(col): 每一行用来描述某个人/物的具体信息; 值(value): 行的具体信息, 每个值必须与该列的数据类型相同; 键(key): 表中用来识别某个特定的人\\物的方法, 键的值在当前列中具有唯一性。 Windows下MySQL的配置以 MySQL 5.1 免安装版为例, 下载 mysql-noinstall-5.1.69-win32.zip(官方下载页: http://dev.mysql.com/downloads/mysql/5.1.html#downloads) 配置步骤: 将下载的 mysql-noinstall-5.1.69-win32.zip 解压至需要安装的位置, 如: C:\\Program Files; 在安装文件夹下找到 my-small.ini 配置文件, 将其重命名为 my.ini , 打开进行编辑, 在 [client] 与 [mysqld] 下均添加一行: default-character-set = gbk 打开 Windows 环境变量设置, 新建变量名 MYSQL_HOME , 变量值为 MySQL 安装目录路径, 这里为 C:\\Program Files\\mysql-5.1.69-win32 在 环境变量 的 Path 变量中添加 ;%MYSQL_HOME%\\bin; 安装 MySQL 服务, 打开Windows命令提示符, 执行命令: mysqld –install MySQL –defaults-file=”my.ini” 提示”Service successfully installed.”表示成功; MySQL服务的启动、停止与卸载 在 Windows 命令提示符下运行: 启动: net start MySQL 停止: net stop MySQL 卸载: sc delete MySQL MySQL脚本的基本组成与常规的脚本语言类似, MySQL 也具有一套对字符、单词以及特殊符号的使用规定, MySQL 通过执行 SQL 脚本来完成对数据库的操作, 该脚本由一条或多条MySQL语句(SQL语句 + 扩展语句)组成, 保存时脚本文件后缀名一般为 .sql。在控制台下, MySQL 客户端也可以对语句进行单句的执行而不用保存为.sql文件。 标识符标识符用来命名一些对象, 如数据库、表、列、变量等, 以便在脚本中的其他地方引用。MySQL标识符命名规则稍微有点繁琐, 这里我们使用万能命名规则: 标识符由字母、数字或下划线(_)组成, 且第一个字符必须是字母或下划线。 对于标识符是否区分大小写取决于当前的操作系统, Windows下是不敏感的, 但对于大多数 linux\\unix 系统来说, 这些标识符大小写是敏感的。 关键字MySQL的关键字众多, 这里不一一列出, 在学习中学习。 这些关键字有自己特定的含义, 尽量避免作为标识符。 语句MySQL语句是组成MySQL脚本的基本单位, 每条语句能完成特定的操作, 他是由 SQL 标准语句 + MySQL 扩展语句组成。 函数MySQL函数用来实现数据库操作的一些高级功能, 这些函数大致分为以下几类: 字符串函数、数学函数、日期时间函数、搜索函数、加密函数、信息函数。 MySQL中的数据类型MySQL有三大类数据类型, 分别为数字、日期\\时间、字符串, 这三大类中又更细致的划分了许多子类型: 数字类型 整数: tinyint、smallint、mediumint、int、bigint 浮点数: float、double、real、decimal 日期和时间: date、time、datetime、timestamp、year 字符串类型 字符串: char、varchar 文本: tinytext、text、mediumtext、longtext 二进制(可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob 这里不能详细对这些类型进行介绍了, 篇幅可能会很长, 详细介绍参见: 《MySQL数据类型》 : http://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html 使用MySQL数据库登录到MySQL当 MySQL 服务已经运行时, 我们可以通过MySQL自带的客户端工具登录到MySQL数据库中, 首先打开命令提示符, 输入以下格式的命名: 1mysql -h 主机名 -u 用户名 -p -h : 该命令用于指定客户端所要登录的MySQL主机名, 登录当前机器该参数可以省略; -u : 所要登录的用户名; -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 以登录刚刚安装在本机的MySQL数据库为例, 在命令行下输入 mysql -u root -p 按回车确认, 如果安装正确且MySQL正在运行, 会得到以下响应: Enter password: 若密码存在, 输入密码登录, 不存在则直接按回车登录, 按照本文中的安装方法, 默认 root 账号是无密码的。登录成功后你将会看到 Welecome to the MySQL monitor… 的提示语。 然后命令提示符会一直以 mysql&gt; 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。 创建一个新的数据库使用 create database 语句可完成对数据库的创建, 创建命令的格式如下: 1create database 数据库名 [其他选项]; 例如我们需要创建一个名为 samp_db 的数据库, 在命令行下执行以下命令: 1create database samp_db character set gbk; 为了便于在命令提示符下显示中文, 在创建时通过 character set gbk 将数据库字符编码指定为 gbk。创建成功时会得到 Query OK, 1 row affected(0.02 sec) 的响应。 注意: MySQL语句以分号(;)作为语句的结束, 若在语句结尾不添加分号时, 命令提示符会以 -&gt; 提示你继续输入(有个别特例, 但加分号是一定不会错的); 提示: 可以使用 show databases; 命令查看已经创建了哪些数据库。 选择所要操作的数据库要对一个数据库进行操作, 必须先选择该数据库, 否则会提示错误: ERROR 1046(3D000): No database selected 两种方式对数据库进行使用的选择: 一: 在登录数据库时指定, 命令: mysql -D 所选择的数据库名 -h 主机名 -u 用户名 -p 例如登录时选择刚刚创建的数据库: mysql -D samp_db -u root -p 二: 在登录后使用 use 语句指定, 命令: use 数据库名; use 语句可以不加分号, 执行 use samp_db 来选择刚刚创建的数据库, 选择成功后会提示: Database changed 创建数据库表使用 create table 语句可完成对表的创建, create table 的常见形式: 1create table 表名称(列声明); 以创建 students 表为例, 表中将存放 学号(id)、姓名(name)、性别(sex)、年龄(age)、联系电话(tel) 这些内容:12345678create table students （ id int unsigned not null auto_increment primary key, name char(8) not null, sex char(4) not null, age tinyint unsigned not null, tel char(13) null default &quot;-&quot; ); 对于一些较长的语句在命令提示符下可能容易输错, 因此我们可以通过任何文本编辑器将语句输入好后保存为 createtable.sql 的文件中, 通过命令提示符下的文件重定向执行执行该脚本。 打开命令提示符, 输入: mysql -D samp_db -u root -p &lt; createtable.sql (提示: 1.如果连接远程主机请加上 -h 指令; 2. createtable.sql 文件若不在当前工作目录下需指定文件的完整路径。) 语句解说:create table tablename(columns) 为创建数据库表的命令, 列的名称以及该列的数据类型将在括号内完成; 括号内声明了5列内容, id、name、sex、age、tel为每列的名称, 后面跟的是数据类型描述, 列与列的描述之间用逗号(,)隔开; 以 “id int unsigned not null auto_increment primary key” 行进行介绍: &quot;id&quot; 为列的名称; &quot;int&quot; 指定该列的类型为 int(取值范围为 -8388608到8388607), 在后面我们又用 &quot;unsigned&quot; 加以修饰, 表示该类型为无符号型, 此时该列的取值范围为 0到16777215; &quot;not null&quot; 说明该列的值不能为空, 必须要填, 如果不指定该属性, 默认可为空; &quot;auto_increment&quot; 需在整数列中使用, 其作用是在插入数据时若该列为 NULL, MySQL将自动产生一个比现存值更大的唯一标识符值。在每张表中仅能有一个这样的值且所在列必须为索引列。 &quot;primary key&quot; 表示该列是表的主键, 本列的值必须唯一, MySQL将自动索引该列。 下面的 char(8) 表示存储的字符长度为8, tinyint的取值范围为 -127到128, default 属性指定当该列值为空时的默认值。 更多的数据类型请参阅 《MySQL数据类型》 : http://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html 提示: 1. 使用 show tables; 命令可查看已创建了表的名称; 2. 使用 describe 表名; 命令可查看已创建的表的详细信息。 操作MySQL数据库向表中插入数据insert 语句可以用来将一行或多行数据插到数据库表中, 使用的一般形式如下: 1insert [into] 表名 [(列名1, 列名2, 列名3, ...)] values (值1, 值2, 值3, ...); 其中 [] 内的内容是可选的, 例如, 要给 samp_db 数据库中的 students 表插入一条记录, 执行语句: 1insert into students values(NULL, &quot;王刚&quot;, &quot;男&quot;, 20, &quot;13811371377&quot;); 按回车键确认后若提示 Query Ok, 1 row affected (0.05 sec) 表示数据插入成功。 若插入失败请检查是否已选择需要操作的数据库。有时我们只需要插入部分数据, 或者不按照列的顺序进行插入, 可以使用这样的形式进行插入: 1insert into students (name, sex, age) values(&quot;孙丽华&quot;, &quot;女&quot;, 21); 查询表中的数据insert 语句可以用来将一行或多行数据插到数据库表中, 使用的一般形式如下: insert [into] 表名 [(列名1, 列名2, 列名3, …)] values (值1, 值2, 值3, …); 其中 [] 内的内容是可选的, 例如, 要给 samp_db 数据库中的 students 表插入一条记录, 执行语句: insert into students values(NULL, “王刚”, “男”, 20, “13811371377”); 按回车键确认后若提示 Query Ok, 1 row affected (0.05 sec) 表示数据插入成功。 若插入失败请检查是否已选择需要操作的数据库。 有时我们只需要插入部分数据, 或者不按照列的顺序进行插入, 可以使用这样的形式进行插入: insert into students (name, sex, age) values(“孙丽华”, “女”, 21); 查询表中的数据select 语句常用来根据一定的查询规则到数据库中获取数据, 其基本的用法为:1select 列名称 from 表名称 [查询条件]; 例如要查询 students 表中所有学生的名字和年龄, 输入语句 select name, age from students; 执行结果如下: mysql&gt; select name, age from students; +--------+-----+ | name | age | +--------+-----+ | 王刚 | 20 | | 孙丽华 | 21 | | 王永恒 | 23 | | 郑俊杰 | 19 | | 陈芳 | 22 | | 张伟朋 | 21 | +--------+-----+ 6 rows in set (0.00 sec) mysql&gt; 也可以使用通配符 查询表中所有的内容, 语句: select from students; 按特定条件查询:where 关键词用于指定查询条件, 用法形式为: 1select 列名称 from 表名称 where 条件; 以查询所有性别为女的信息为例, 输入查询语句: select * from students where sex=”女”; where 子句不仅仅支持 “where 列名 = 值” 这种名等于值的查询形式, 对一般的比较运算的运算符都是支持的, 例如 =、&gt;、&lt;、&gt;=、&lt;、!= 以及一些扩展运算符 is [not] null、in、like 等等。 还可以对查询条件使用 or 和 and 进行组合查询, 以后还会学到更加高级的条件查询方式, 这里不再多做介绍。 示例:查询年龄在21岁以上的所有人信息: select * from students where age &gt; 21; 查询名字中带有 “王” 字的所有人信息: select * from students where name like “%王%”; 查询id小于5且年龄大于20的所有人信息: select * from students where id20; 更新表中的数据update 语句可用来修改表中的数据, 基本的使用形式为: 1update 表名称 set 列名称=新值 where 更新条件; 使用示例:将id为5的手机号改为默认的”-“: update students set tel=default where id=5; 将所有人的年龄增加1: update students set age=age+1; 将手机号为 13288097888 的姓名改为 “张伟鹏”, 年龄改为 19: update students set name=”张伟鹏”, age=19 where tel=”13288097888”; 删除表中的数据delete 语句用于删除表中的数据, 基本用法为: 1delete from 表名称 where 删除条件; 使用示例: 删除id为2的行: delete from students where id=2; 删除所有年龄小于21岁的数据: delete from students where age&lt;20; 删除表中的所有数据: delete from students; 创建后表的修改alter table 语句用于创建后对表的修改, 基础用法如下: 添加列基本形式: alter table 表名 add 列名 列数据类型 [after 插入位置]; 示例:在表的最后追加列 address: alter table students add address char(60); 在名为 age 的列后插入列 birthday: alter table students add birthday date after age; 修改列基本形式: alter table 表名 change 列名称 列新名称 新数据类型; 示例:将表 tel 列改名为 telphone: alter table students change tel telphone char(13) default “-“; 将 name 列的数据类型改为 char(16): alter table students change name name char(16) not null;删除列 基本形式: alter table 表名 drop 列名称;示例:删除 birthday 列: alter table students drop birthday; 重命名表基本形式: alter table 表名 rename 新表名; 示例:重命名 students 表为 workmates: alter table students rename workmates; 删除整张表基本形式: drop table 表名; 示例:删除 workmates 表: drop table workmates; 删除整个数据库基本形式: drop database 数据库名; 示例:删除 samp_db 数据库: drop database samp_db; 附录修改 root 用户密码按照本文的安装方式, root 用户默认是没有密码的, 重设 root 密码的方式也较多, 这里仅介绍一种较常用的方式。 使用 mysqladmin 方式:打开命令提示符界面, 执行命令: mysqladmin -u root -p password 新密码 执行后提示输入旧密码完成密码修改, 当旧密码为空时直接按回车键确认即可。 可视化管理工具 MySQL Workbench尽管我们可以在命令提示符下通过一行行的输入或者通过重定向文件来执行mysql语句, 但该方式效率较低, 由于没有执行前的语法自动检查, 输入失误造成的一些错误的可能性会大大增加, 这时不妨试试一些可视化的MySQL数据库管理工具, MySQL Workbench 就是 MySQL 官方 为 MySQL 提供的一款可视化管理工具, 你可以在里面通过可视化的方式直接管理数据库中的内容, 并且 MySQL Workbench 的 SQL 脚本编辑器支持语法高亮以及输入时的语法检查, 当然, 它的功能强大, 绝不仅限于这两点。 MySQL Workbench官方介绍: http://www.mysql.com/products/workbench/ MySQL Workbench 下载页: http://dev.mysql.com/downloads/tools/workbench/","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell,github.io/tags/笔记/"},{"name":"MySQL","slug":"MySQL","permalink":"http://londbell,github.io/tags/MySQL/"},{"name":"收藏","slug":"收藏","permalink":"http://londbell,github.io/tags/收藏/"},{"name":"转载","slug":"转载","permalink":"http://londbell,github.io/tags/转载/"}]},{"title":"Counting Bits","date":"2016-03-27T02:03:00.000Z","path":"2016/03/27/leetcode-338-Counting-Bits/","text":"题目描述大意就是实现求给出比num小的所有数的二进制位中1的位数，隐藏提示是使用动态规划。 Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.Example: For num = 5 you should return [0,1,1,2,1,2].Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?Space complexity should be O(n).Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. 原题地址 逗逼解法12345678910public class Solution &#123; public int trailingZeroes(int n) &#123; int count = 0; while(n != 0) &#123; n /= 5; count += n; &#125; return count; &#125;&#125; 动态规划需要注意到的是，每隔2^n的大小，就会刚好多出一位，也就是说构造出动态规划的叠加数组，在以前计算过的基础上加1，即可得到后面数的“1”位数。 12345678910111213141516public class Solution &#123; public static int[] countBits(int num) &#123; if(num == 0) return new int[]&#123;0&#125;; int[] result = new int[num + 1]; int len, count = 0; while(true)&#123; len = count + 1; for(int i = 0; i &lt; len; i++)&#123; ++count; result[count] = result[i] + 1; if(count &gt;= num) return result; &#125; &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://londbell,github.io/tags/动态规划/"},{"name":"位操作","slug":"位操作","permalink":"http://londbell,github.io/tags/位操作/"}]},{"title":"Valid Number","date":"2016-03-23T01:21:00.000Z","path":"2016/03/23/leetcode-65-valid-number/","text":"题目描述检查给定字符串是否为合法的数字。 Validate if a given string is numeric. 123456Some examples:&quot;0&quot; =&gt; true&quot; 0.1 &quot; =&gt; true&quot;abc&quot; =&gt; false&quot;1 a&quot; =&gt; false&quot;2e10&quot; =&gt; true Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. 解题步骤：先Trim去空格（原题用例前后有空格，是合法的。）然后检查第一位的“+”， “-”。接着分割。可以出现科学计算法的e，然后可以出现小数点，但是都只能出现一次。先以e分割，注意e前后都必须是整数，由于小数点可以出现在e前，所以应该对e后端进行数字校验。同理对小数点操作。小数点允许前后两段至多有一段不为0。原题地址 我的做法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public static boolean isNumber(String s) &#123; s = s.trim(); if(s.length() == 0) &#123; return false; &#125; if(s.charAt(0) == '+' || s.charAt(0) == '-')&#123; s = s.substring(1); &#125; int loc = s.indexOf('e') &gt;= 0 ? s.indexOf('e') : s.indexOf('E'); if(loc &gt; 0) &#123; String sTemp = s.substring(loc + 1); if(sTemp.length() == 0) &#123; return false; &#125; if(sTemp.charAt(0) == '+' || sTemp.charAt(0) == '-') &#123; sTemp = sTemp.substring(1); &#125; if(!isPureDigit(sTemp)) &#123; return false; &#125; s = s.substring(0, loc); &#125;else if(loc == 0) &#123; return false; &#125; int locDot = s.indexOf('.'); if(locDot &gt;= 0) &#123; String preDot = s.substring(0, locDot); String postDot = s.substring(locDot + 1); if(preDot.isEmpty()) &#123; return isPureDigit(postDot); &#125; if(postDot.isEmpty()) &#123; return isPureDigit(preDot); &#125; return isPureDigit(preDot) &amp;&amp; isPureDigit(postDot); &#125; return isPureDigit(s); &#125; public static boolean isPureDigit(String s) &#123; if (s.isEmpty()) return false; for(int i = 0; i &lt; s.length(); ++i) &#123; if (!Character.isDigit(s.charAt(i))) &#123; return false; &#125; &#125; return true; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"android.view.InflateException: Binary XML file line 错误","date":"2016-01-27T02:03:00.000Z","path":"2016/01/27/android-01-android-view-InflateException/","text":"问题描述自定义的View，在XML中调用出现android.view.InflateException: Binary XML file line 错误。 解决方法12345View(Context context) //Simple constructor to use when creating a view from codeView(Context context, AttributeSet attrs) //Constructor that is called when inflating a view from XMLView(Context context, AttributeSet attrs, int defStyle) //Perform inflation from XML and apply a class-specific base style 第二个和第三个构造函数对于XML这种引用方式是必须实现的，这三个构造函数应该是在不同的应用场合来实例化一个View对象。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell,github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"坑","slug":"坑","permalink":"http://londbell,github.io/tags/坑/"},{"name":"android","slug":"android","permalink":"http://londbell,github.io/tags/android/"}]},{"title":"search a 2dmatrix","date":"2015-09-01T07:21:00.000Z","path":"2015/09/01/leetcode-74-search-a-2d-matrix/","text":"题目描述给定一个矩阵，求特定的数是否在矩阵中。矩阵每一行从小到大排列。每一行的最小元素比上一行最大元素大。 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. For example, Consider the following matrix: 我的做法：写起来简单，性能很辣鸡。123456789101112131415161718public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix.length == 0 || matrix == null) &#123; return false; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int[] e : matrix) &#123; for(int q : e) &#123; list.add(q); &#125; &#125; if(list.contains(target)) &#123; return true; &#125; return false; &#125;&#125; 效率高的做法:12345678910111213141516public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int i = 0, j = matrix[0].length - 1; while (i &lt; matrix.length &amp;&amp; j &gt;= 0) &#123; if (matrix[i][j] == target) &#123; return true; &#125; else if (matrix[i][j] &gt; target) &#123; j--; &#125; else &#123; i++; &#125; &#125; return false; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"},{"name":"矩阵","slug":"矩阵","permalink":"http://londbell,github.io/tags/矩阵/"}]},{"title":"Roman to Integer","date":"2014-12-03T09:32:00.000Z","path":"2014/12/03/leetcode-13-Roman-to-Integer/","text":"题目描述给出一个罗马数字字符串，将其计算为阿拉伯数字。 Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 背景知识罗马数字是阿拉伯数字传入之前使用的一种数码。罗马数字采用七个罗马字母作数字、即Ⅰ（1）、X（10）、C（100）、M（1000）、V（5）、L（50）、D（500）。记数的方法： 1.相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3； 2.小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12； 3.小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9； 4.在一个数的上面画一条横线，表示这个数增值 1,000 倍，如=5000。 原题地址123456789101112131415161718192021222324252627public class Solution &#123; public int romanToInt(String s) &#123; Map map = new HashMap(); map.put('I', 1);//Key是Char就用单引号，是String就用双引号 map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int result = 0; for(int i = s.length() - 1; i &gt;= 0; --i) &#123; if(i == s.length() - 1) &#123; result = (Integer)map.get(s.charAt(i)); continue; &#125; if(((Integer)map.get(s.charAt(i))) &gt;= ((Integer)map.get(s.charAt(i + 1)))) &#123; result += (Integer) map.get(s.charAt(i)); &#125;else &#123; result -= (Integer) map.get(s.charAt(i)); &#125; &#125; return result; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"Add Two Numbers","date":"2014-07-03T02:11:00.000Z","path":"2014/07/03/leetcode-02-Add-Two-Numbers/","text":"题目描述给定两个由个位数组成的非空链表，按位置相加，进位累加到下一个元素上，每个元素只留个位，两个链表长度可能不等。 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 原题地址 我的做法：1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode temp = head; int count = 0; head.val = l1.val + l2.val; if(head.val &gt;= 10) &#123; count = 1; head.val %= 10; &#125; while(l1.next != null || l2.next !=null || count == 1) &#123; if(l1.next == null &amp;&amp; l2.next == null) &#123; temp.next = new ListNode(count); &#125; else if(l1.next == null) &#123; temp.next = new ListNode(l2.next.val + count); l2 = l2.next; &#125;else if(l2.next == null) &#123; temp.next = new ListNode(l1.next.val + count); l1 = l1.next; &#125;else if(l1.next != null &amp;&amp; l2.next != null) &#123; temp.next = new ListNode(l1.next.val + l2.next.val + count); l1 = l1.next; l2 = l2.next; &#125; if(temp.next.val &gt;= 10) &#123; count = 1; temp.next.val %= 10; &#125;else &#123; count = 0; &#125; temp = temp.next; &#125; return head; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"http://londbell,github.io/tags/链表/"}]},{"title":"Two Sum","date":"2014-07-01T13:52:00.000Z","path":"2014/07/01/leetcode-01-Two-Sum/","text":"题目描述给定一个整形元素组成的数组，给出一个数，求数组中是否存在两个数之和与给定数相等。不能使用同一个元素两次，同时一定只会有一个解。 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 原题地址 逗逼解法：12345678910111213141516171819202122232425262728293031323334353637package com.company;public class Main &#123; public static void main(String[] args) &#123; // write your code here int nums3[] = &#123;3, 2, 4&#125;; int target3 = 6; int nums4[] = &#123;2,7,11,15&#125;; int target4 = 9; int twoSum[] = Solution.twoSum(nums3, target3); System.out.print(twoSum[0] + \" \" + twoSum[1]); System.out.println(\" finish\"); &#125;&#125;class Solution &#123; public static int[] twoSum(int[] nums, int target) &#123; int flag = 0; int array[] = &#123;0,0&#125;; for(int i = 0; i &lt; nums.length; i++) &#123; if(flag == 1) &#123; break; &#125; for(int j = i + 1; j &lt; nums.length; j++) &#123; if((nums[i] + nums[j] == target)) &#123; array[0] = i; array[1] = j; flag = 1; break; &#125; &#125; &#125; return array; &#125;&#125; 改进方法1234567891011121314151617181920212223242526272829303132package com.company;public class Main &#123; public static void main(String[] args) &#123; // write your code here int nums3[] = &#123;3, 2, 4&#125;; int target3 = 6; int nums4[] = &#123;2,7,11,15&#125;; int target4 = 9; int twoSum[] = Solution.twoSum(nums3, target3); System.out.print(twoSum[0] + \" \" + twoSum[1]); System.out.println(\" finish\"); &#125;&#125;class Solution &#123; public static int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int result[] = new int[2]; for (int i = 0; i &lt; nums.length; i++)&#123; int num = target - nums[i]; if(map.containsKey(num))&#123; result[0] = map.get(num); result[1] = i; return result; &#125; map.put(nums[i], i); &#125; return result; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"傻瓜函数式编程","date":"2006-06-18T16:34:00.000Z","path":"2006/06/19/FunctionalProgrammingForTheRestOfUs-cn/","text":"开篇我们这些码农做事都是很拖拉的。每天例行报到后，先来点咖啡，看看邮件还有RSS订阅的文章。然后翻翻新闻还有那些技术网站上的更新，再过一遍编程论坛口水区里那些无聊的论战。最后从头把这些再看一次以免错过什么精彩的内容。然后就可以吃午饭了。饭饱过后，回来盯着IDE发一会呆，再看看邮箱，再去搞杯咖啡。光阴似箭，可以回家了……（在被众人鄙视之前）我唯一想说的是，在这些拖拉的日子里总会时不时读到一些不明觉厉的文章。如果没有打开不应该打开的网站，每隔几天你都可以看到至少一篇这样的东西。它们的共性：难懂，耗时，于是这些文章就慢慢的堆积成山了。很快你就会发现自己已经累积了一堆的收藏链接还有数不清的PDF文件，此时你只希望隐入一个杳无人烟的深山老林里什么也不做，用一年半载好好的消化这些私藏宝贝。当然，我是说最好每天还是能有人来给送吃的顺带帮忙打扫卫生倒垃圾，哇哈哈。 我不知道你都收藏了些什么，我的阅读清单里面相当大部分都是函数式编程相关的东东：基本上是最难啃的。这些文章充斥着无比枯燥的教科书语言，我想就连那些在华尔街浸淫10年以上的大牛都无法搞懂这些函数式编程（简称FP）文章到底在说什么。你可以去花旗集团或者德意志银行找个项目经理来问问1：你们为什么要选JMS而不用Erlang？答案基本上是：我认为这个学术用的语言还无法胜任实际应用。可是，现有的一些系统不仅非常复杂还需要满足十分严苛的需求，它们就都是用函数式编程的方法来实现的。这，就说不过去了。关于FP的文章确实比较难懂，但我不认为一定要搞得那么晦涩。有一些历史原因造成了这种知识断层，可是FP概念本身并不难理解。我希望这篇文章可以成为一个“FP入门指南”，帮助你从指令式编程走向函数式编程。先来点咖啡，然后继续读下去。很快你对FP的理解就会让同事们刮目相看了。 什么是函数式编程（Functional Programming，FP）？它从何而来？可以吃吗？倘若它真的像那些鼓吹FP的人说的那么好，为什么实际应用中那么少见？为什么只有那些在读博士的家伙想要用它？而最重要的是，它母亲的怎么就那么难学？那些所谓的closure、continuation，currying，lazy evaluation还有no side effects都是什么东东（译者：本着保留专用术语的原则，此处及下文类似情形均不译）？如果没有那些大学教授的帮忙怎样把它应用到实际工程里去？为什么它和我们熟悉的万能而神圣的指令式编程那么的不一样？我们很快就会解开这些谜团。刚才我说过实际工程和学术界之间的知识断层是有其历史原因的，那么就先让我来解释一下这个问题。答案，就在接下来的一次公园漫步中： 公园漫步时间机器启动……我们来到公元前380年，也就是2000多年前的雅典城外。这是一个阳光明媚的久违的春天，柏拉图和一个帅气的小男仆走在一片橄榄树荫下。他们正准备前往一个学院。天气很好，吃得很饱，渐渐的，两人的谈话转向了哲学。 “你看那两个学生，哪一个更高一些？”，柏拉图小心的选择用字，以便让这个问题更好的引导眼前的这个小男孩。小男仆望向水池旁边的两个男生，“他们差不多一样高。”。“‘差不多一样高’是什么意思？”柏拉图问。“嗯……从这里看来他们是一样高的，但是如果走近一点我肯定能看出差别来。”柏拉图笑了。他知道这个小孩已经朝他引导的方向走了。“这么说来你的意思是世界上没有什么东西是完全相同的咯？”思考了一会，小男孩回答：“是的。万物之间都至少有一丁点差别，哪怕我们无法分辨出来。”说到点子上了！“那你说，如果世界上没有什么东西是完全相等的，你怎么理解‘完全相等’这个概念？”小男仆看起来很困惑。“这我就不知道了。” 这是人类第一次试图了解数学的本质。柏拉图认为我们所在的世界中，万事万物都是完美模型的一个近似。他同时意识到虽然我们不能感受到完美的模型，但这丝毫不会阻止我们了解完美模型的概念。柏拉图进而得出结论：完美的数学模型只存在于另外一个世界，而因为某种原因我们却可以通过联系着这两个世界的一个纽带来认识这些模型。一个简单的例子就是完美的圆形。没有人见过这样的一个圆，但是我们知道怎样的圆是完美的圆，而且可以用公式把它描述出来。 如此说来，什么是数学呢？为什么可以用数学法则来描述我们的这个宇宙？我们所处的这个世界中万事万物都可以用数学来描述吗？2数理哲学是一门很复杂的学科。它和其他多数哲学一样，更着重于提出问题而不是给出答案。数学就像拼图一样，很多结论都是这样推导出来的：先是确立一些互不冲突的基础原理，以及一些操作这些原理的规则，然后就可以把这些原理以及规则拼凑起来形成新的更加复杂的规则或是定理了。数学家把这种方法称为“形式系统”或是“演算”。如果你想做的话，可以用形式系统描述俄罗斯方块这个游戏。而事实上，俄罗斯方块这个游戏的实现，只要它正确运行，就是一个形式系统。只不过它以一种不常见的形式表现出来罢了。 如果半人马阿尔法上有文明存在的话，那里的生物可能无法解读我们的俄罗斯方块形式系统甚至是简单的圆形的形式系统，因为它们感知世界的唯一器官可能只有鼻子（译者：偶的妈你咋知道？）也许它们是无法得知俄罗斯方块的形式系统了，但是它们很有可能知道圆形。它们的圆形我们可能没法解读，因为我们的鼻子没有它们那么灵敏（译者：那狗可以么？）可是只要越过形式系统的表示方式（比如通过使用“超级鼻子”之类的工具来感知这些用味道表示的形式系统，然后使用标准的解码技术把它们翻译成人类能理解的语言），那么任何有足够智力的文明都可以理解这些形式系统的本质。有意思的是，哪怕宇宙中完全不存在任何文明，类似俄罗斯方块还有圆形这样的形式系统依旧是成立的：只不过没有智慧生物去发现它们而已。这个时候如果忽然一个文明诞生了，那么这些具有智慧的生物就很有可能发现各种各样的形式系统，并且用它们发现的系统去描述各种宇宙法则。不过它们可能不会发现俄罗斯方块这样的形式系统，因为在它们的世界里没有俄罗斯方块这种东西嘛。有很多像俄罗斯方块这样的形式系统是与客观世界无关的，比如说自然数，很难说所有的自然数都与客观世界有关，随便举一个超级大的数，这个数可能就和世界上任何事物无关，因为这个世界可能不是无穷大的。 历史回眸3再次启动时间机……这次到达的是20世纪30年代，离今天近了很多。无论新旧大陆，经济大萧条都造成了巨大的破坏。社会各阶层几乎每一个家庭都深受其害。只有极其少数的几个地方能让人们免于遭受穷困之苦。几乎没有人能够幸运的在这些避难所里度过危机，注意，我说的是几乎没有，还真的有这么些幸运儿，比如说当时普林斯顿大学的数学家们。 新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿，他们将组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。一个名叫阿隆佐·邱奇(Alonzo Church)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有艾伦·图灵、约翰·冯·诺伊曼、库尔特·哥德尔。这四个人都对形式系统感兴趣。相对于现实世界，他们更关心如何解决抽象的数学问题。而他们的问题都有这么一个共同点：都在尝试解答关于计算的问题。诸如：如果有一台拥有无穷计算能力的超级机器，可以用来解决什么问题？它可以自动的解决这些问题吗？是不是还是有些问题解决不了，如果有的话，是为什么？如果这样的机器采用不同的设计，它们的计算能力相同吗？在与这些人的合作下，阿隆佐设计了一个名为lambda演算的形式系统。这个系统实质上是为其中一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。这种函数用希腊字母lambda（λ），这种系统因此得名4。有了这种形式系统，阿隆佐终于可以分析前面的那些问题并且能够给出答案了。除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。 如果二战没有发生，这个故事到这里就应该结束了，我的这篇小文没什么好说的了，你们也可以去看看有什么其他好看的文章。可是二战还是爆发了，整个世界陷于火海之中。那时的美军空前的大量使用炮兵。为了提高轰炸的精度，军方聘请了大批数学家夜以继日的求解各种差分方程用于计算各种火炮发射数据表。后来他们发现单纯手工计算这些方程太耗时了，为了解决这个问题，各种各样的计算设备应运而生。IBM制造的Mark一号就是用来计算这些发射数据表的第一台机器。Mark一号重5吨，由75万个零部件构成，每一秒可以完成3次运算。战后，人们为提高计算能力而做出的努力并没有停止。1949年第一台电子离散变量自动计算机诞生并取得了巨大的成功。它是冯·诺伊曼设计架构的第一个实例，也是一台现实世界中实现的图灵机。相比他的这些同事，那个时候阿隆佐的运气就没那么好了。到了50年代末，一个叫John McCarthy的MIT教授（他也是普林斯顿的硕士）对阿隆佐的成果产生了兴趣。1958年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！很多计算机科学家都认识到了Lisp强大的能力。1973年在MIT人工智能实验室的一些程序员研发出一种机器，并把它叫做Lisp机。于是阿隆佐的lambda演算也有自己的硬件实现了！ 函数式编程函数式编程是阿隆佐思想的在现实世界中的实现。不过不是全部的lambda演算思想都可以运用到实际中，因lambda演算在设计的时候就不是为了在各种现实世界中的限制下工作的。所以，就像面向对象的编程思想一样，函数式编程只是一系列想法，而不是一套严苛的规定。有很多支持函数式编程的程序语言，它们之间的具体设计都不完全一样。在这里我将用Java写的例子介绍那些被广泛应用的函数式编程思想（没错，如果你是受虐狂你可以用Java写出函数式程序）。在下面的章节中我会在Java语言的基础上，做一些修改让它变成实际可用的函数式编程语言。那么现在就开始吧。 Lambda演算在最初设计的时候就是为了研究计算相关的问题。所以函数式编程主要解决的也是计算问题，而出乎意料的是，是用函数来解决的！（译者：请理解原作者的苦心，我想他是希望加入一点调皮的风格以免读者在中途睡着或是转台……）。函数就是函数式编程中的基础元素，可以完成几乎所有的操作，哪怕最简单的计算，也是用函数完成的。我们通常理解的变量在函数式编程中也被函数代替了：在函数式编程中变量仅仅代表某个表达式（这样我们就不用把所有的代码都写在同一行里了）。所以我们这里所说的‘变量’是不能被修改的。所有的变量只能被赋一次初值。在Java中就意味着每一个变量都将被声明为final（如果你用C++，就是const）。在FP中，没有非final的变量。 12final int i = 5;final int j = i + 3; 既然FP中所有的变量都是final的，可以引出两个规定：一是变量前面就没有必要再加上final这个关键字了，二是变量就不能再叫做‘变量’了……于是现在开始对Java做两个改动：所有Java中声明的变量默认为final，而且我们把所谓的‘变量’称为‘符号’。到现在可能会有人有疑问：这个新创造出来的语言可以用来写什么有用的复杂一些的程序吗？毕竟，如果每个符号的值都是不能修改的，那么我们就什么东西都不能改变了！别紧张，这样的说法不完全正确。阿隆佐在设计lambda演算的时候他并不想要保留状态的值以便稍后修改这些值。他更关心的是基于数据之上的操作（也就是更容易理解的“计算”）。而且，lambda演算和图灵机已经被证明了是具有同样能力的系统，因此指令式编程能做到的函数式编程也同样可以做到。那么，怎样才能做到呢？事实上函数式程序是可以保存状态的，只不过它们用的不是变量，而是函数。状态保存在函数的参数中，也就是说在栈上。如果你需要保存一个状态一段时间并且时不时的修改它，那么你可以编写一个递归函数。举个例子，试着写一个函数，用来反转一个Java的字符串。记住咯，这个程序里的变量都是默认为final的5。 12345678String reverse(String arg) &#123; if(arg.length == 0) &#123; return arg; &#125; else &#123; return reverse(arg.substring(1, arg.length)) + arg.substring(0, 1); &#125;&#125; 这个方程运行起来会相对慢一些，因为它重复调用自己6。同时它也会大量的消耗内存，因为它会不断的分配创建内存对象。无论如何，它是用函数式编程思想写出来的。这时候可能有人要问了，为什么要用这种奇怪的方式编写程序呢？嘿，我正准备告诉你。 FP之优点你大概已经在想：上面这种怪胎函数怎么也不合理嘛。在我刚开始学习FP的时候我也这样想的。不过后来我知道我是错的。使用这种方式编程有很多好处。其中一些是主观的。比如说有人认为函数式程序更容易理解。这个我就不说了，哪怕街上随便找个小孩都知道‘容易理解’是多么主观的事情。幸运的是，客观方面的好处还有很多。 单元测试因为FP中的每个符号都是final的，于是没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用（在指令式编程中可以用类成员或是全局变量做到）。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。这正是单元测试工程师梦寐以求的啊。现在测试程序中的函数时只需要关注它的参数就可以了。完全不需要担心函数调用的顺序，也不用费心设置外部某些状态值。唯一需要做的就是传递一些可以代表边界条件的参数给这些函数。相对于指令式编程，如果FP程序中的每一个函数都能通过单元测试，那么我们对这个软件的质量必将信心百倍。反观Java或者C++，仅仅检查函数的返回值是不够的：代码可能修改外部状态值，因此我们还需要验证这些外部的状态值的正确性。在FP语言中呢，就完全不需要。 调试查错如果一段FP程序没有按照预期设计那样运行，调试的工作几乎不费吹灰之力。这些错误是百分之一百可以重现的，因为FP程序中的错误不依赖于之前运行过的不相关的代码。而在一个指令式程序中，一个bug可能有时能重现而有些时候又不能。因为这些函数的运行依赖于某些外部状态， 而这些外部状态又需要由某些与这个bug完全不相关的代码通过某个特别的执行流程才能修改。在FP中这种情况完全不存在：如果一个函数的返回值出错了，它一直都会出错，无论你之前运行了什么代码。一旦问题可以重现，解决它就变得非常简单，几乎就是一段愉悦的旅程。中断程序的运行，检查一下栈，就可以看到每一个函数调用时使用的每一个参数，这一点和指令式代码一样。不同的是指令式程序中这些数据还不足够，因为函数的运行还可能依赖于成员变量，全局变量，还有其他类的状态（而这些状态又依赖于类似的变量）。FP中的函数只依赖于传给它的参数，而这些参数就在眼前！还有，对指令式程序中函数返回值的检查并不能保证这个函数是正确运行的。还要逐一检查若干作用域以外的对象以确保这个函数没有对这些牵连的对象做出什么越轨的行为（译者：好吧，翻译到这里我自己已经有点激动了）。对于一个FP程序，你要做的仅仅是看一下函数的返回值。把栈上的数据过一遍就可以得知有哪些参数传给了什么函数，这些函数又返回了什么值。当一个返回值看起来不对头的那一刻，跳进这个函数看看里面发生了什么。一直重复跟进下去就可以找到bug的源头！ 并发执行不需要任何改动，所有FP程序都是可以并发执行的。由于根本不需要采用锁机制，因此完全不需要担心死锁或是并发竞争的发生。在FP程序中没有哪个线程可以修改任何数据，更不用说多线程之间了。这使得我们可以轻松的添加线程，至于那些祸害并发程序的老问题，想都不用想！既然是这样，为什么没有人在那些高度并行的那些应用程序中采用FP编程呢？事实上，这样的例子并不少见。爱立信开发了一种FP语言，名叫Erlang，并应用在他们的电信交换机上，而这些交换机不仅容错度高而且拓展性强。许多人看到了Erlang的这些优势也纷纷开始使用这一语言。在这里提到的电信交换控制系统远远要比华尔街上使用的系统具有更好的扩展性也更可靠。事实上，用Erlang搭建的系统并不具备可扩展性和可靠性，而Java可以提供这些特性。Erlang只是像岩石一样结实不容易出错而已。FP关于并行的优势不仅于此。就算某个FP程序本身只是单线程的，编译器也可以将其优化成可以在多CPU上运行的并发程序。以下面的程序为例： 123String s1 = somewhatLongOperation1();String s2 = somewhatLongOperation2();String s3 = concatenate(s1, s2); 如果是函数式程序，编译器就可以对代码进行分析，然后可能分析出生成字符串s1和s2的两个函数可能会比较耗时，进而安排它们并行运行。这在指令式编程中是无法做到的，因为每一个函数都有可能修改其外部状态，然后接下来的函数又可能依赖于这些状态的值。在函数式编程中，自动分析代码并找到适合并行执行的函数十分简单，和分析C的内联函数没什么两样。从这个角度来说用FP风格编写的程序是“永不过时”的（虽然我一般不喜欢说大话空话，不过这次就算个例外吧）。硬件厂商已经没办法让CPU运行得再快了。他们只能靠增加CPU核的数量然后用并行来提高运算的速度。这些厂商故意忽略一个事实：只有可以并行的软件才能让你花大价钱买来的这些硬件物有所值。指令式的软件中只有很小一部分能做到跨核运行，而所有的函数式软件都能实现这一目标，因为FP的程序从一开始就是可以并行运行的。 热部署在Windows早期，如果要更新系统那可是要重启电脑的，而且还要重启很多次。哪怕只是安装一个新版本的播放器。到了XP的时代这种情况得到比较大的改善，尽管还是不理想（我工作的时候用的就是Windows，就在现在，我的系统托盘上就有个讨厌的图标，我不重启机子就不消失）。这一方面Unix好一些，曾经。只需要暂停一些相关的部件而不是整个操作系统，就可以安装更新了。虽然是要好一些了，对很多服务器应用来说这也还是不能接受的。电信系统要求的是100%的在线率，如果一个救急电话因为系统升级而无法拨通，成千上万的人就会因此丧命。同样的，华尔街的那些公司怎么也不能说要安装软件而在整个周末停止他们系统的服务。最理想的情况是更新相关的代码而不用暂停系统的其他部件。对指令性程序来说是不可能的。想想看，试着在系统运行时卸载掉一个Java的类然后再载入这个类的新的实现，这样做的话系统中所有该类的实例都会立刻不能运行，因为该类的相关状态已经丢失了。这种情况下可能需绞尽脑汁设计复杂的版本控制代码，需要将所有这种类正在运行的实例序列化，逐一销毁它们，然后创建新类的实例，将现有数据也序列化后装载到这些新的实例中，最后希望负责装载的程序可以正确的把这些数据移植到新实例中并正常的工作。这种事很麻烦，每次有新的改动都需要手工编写装载程序来完成更新，而且这些装载程序还要很小心，以免破坏了现有对象之间的联系。理论上是没问题，可是实际上完全行不通。FP的程序中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。其它的事情有FP的语言工具自动完成！如果还有人认为这只存在于科幻小说中，他需要再想想：多年来Erlang工程师已经使用这种技术对它们的系统进行升级而完全不用暂停运行了。 机器辅助优化及证明FP语言有一个特性很有意思，那就是它们是可以用数学方法来分析的。FP语言本身就是形式系统的实现，只要是能在纸上写出来的数学运算就可以用这种语言表述出来。于是只要能够用数学方法证明两段代码是一致的，编译器就可以把某段代码解析成在数学上等同的但效率又更高的另外一段代码7。 关系数据库已经用这种方法进行优化很多年了。没有理由在常规的软件行业就不能应用这种技术。另外，还可以用这种方法来证明代码的正确性，甚至可以设计出能够自动分析代码并为单元测试自动生成边缘测试用例的工具出来！对于那些对缺陷零容忍的系统来说，这一功能简直就是无价之宝。例如心脏起搏器，例如飞行管控系统，这几乎就是必须满足的需求。哪怕你正在开发的程序不是为了完成什么重要核心任务，这些工具也可以帮助你写出更健壮的程序，直接甩竞争对手n条大街。 高阶函数我还记得在了解到FP以上的各种好处后想到：“这些优势都很吸引人，可是，如果必须非要用这种所有变量都是final的蹩脚语言，估计还是不怎么实用吧”。其实这样的想法是不对的。对于Java这样的指令式语言来说，如果所有的变量都是必须是final的，那么确实很束手束脚。然而对函数式语言来说，情况就不一样了。函数式语言提供了一种特别的抽象工具，这种工具将帮助使用者编写FP代码，让他们甚至都没想到要修改变量的值。高阶函数就是这种工具之一。FP语言中的函数有别于Java或是C。可以说这种函数是一个全集：Java函数可以做到的它都能做，同时它还有更多的能力。首先，像在C里写程序那样创建一个函数： 123int add(int i, int j) &#123; return i + j;&#125; 看起来和C程序没什么区别，但是很快你就可以看出区别来。接下来我们扩展Java的编译器以便支持这种代码，也就是说，当我们写下以上的程序编译器会把它转化成下面的Java程序（别忘了，所有的变量都是final的）： 1234567class add_function_t &#123; int add(int i, int j) &#123; return i + j; &#125;&#125;add_function_t add = new add_function_t(); 在这里，符号add并不是一个函数，它是只有一个函数作为其成员的简单的类。这样做有很多好处，可以在程序中把add当成参数传给其他的函数，也可以把add赋给另外一个符号，还可以在运行时创建add_function_t的实例然后在不再需要这些实例的时候由系统回收机制处理掉。这样做使得函数成为和integer或是string这样的第一类对象。对其他函数进行操作（比如说把这些函数当成参数）的函数，就是所谓的高阶函数。别让这个看似高深的名字吓倒你（译者：好死不死起个这个名字，初一看还准备搬出已经尘封的高数教材……），它和Java中操作其他类（也就是把一个类实例传给另外的类）的类没有什么区别。可以称这样的类为“高阶类”，但是没人会在意，因为Java圈里就没有什么很强的学术社团。（译者：这是高级黑吗？）那么什么时候该用高阶函数，又怎样用呢？我很高兴有人问这个问题。设想一下，你写了一大堆程序而不考虑什么类结构设计，然后发现有一部分代码重复了几次，于是你就会把这部分代码独立出来作为一个函数以便多次调用（所幸学校里至少会教这个）。如果你发现这个函数里有一部分逻辑需要在不同的情况下实现不同的行为，那么你可以把这部分逻辑独立出来作为一个高阶函数。搞晕了？下面来看看我工作中的一个真实的例子。 假设有一段Java的客户端程序用来接收消息，用各种方式对消息做转换，然后发给一个服务器。 1234567891011class MessageHandler &#123; void handleMessage(Message msg) &#123; // ... msg.setClientCode(\"ABCD_123\"); // ... sendMessage(msg); &#125; // ...&#125; 再进一步假设，整个系统改变了，现在需要发给两个服务器而不再是一个了。系统其他部分都不变，唯独客户端的代码需要改变：额外的那个服务器需要用另外一种格式发送消息。应该如何处理这种情况呢？我们可以先检查一下消息要发送到哪里，然后选择相应的格式把这个消息发出去： 123456789101112131415class MessageHandler &#123; void handleMessage(Message msg) &#123; // ... if(msg.getDestination().equals(\"server1\") &#123; msg.setClientCode(\"ABCD_123\"); &#125; else &#123; msg.setClientCode(\"123_ABC\"); &#125; // ... sendMessage(msg); &#125; // ...&#125; 可是这样的实现是不具备扩展性的。如果将来需要增加更多的服务器，上面函数的大小将呈线性增长，使得维护这个函数最终变成一场噩梦。面向对象的编程方法告诉我们，可以把MessageHandler变成一个基类，然后将针对不同格式的消息编写相应的子类。 12345678910111213141516171819202122232425abstract class MessageHandler &#123; void handleMessage(Message msg) &#123; // ... msg.setClientCode(getClientCode()); // ... sendMessage(msg); &#125; abstract String getClientCode(); // ...&#125;class MessageHandlerOne extends MessageHandler &#123; String getClientCode() &#123; return \"ABCD_123\"; &#125;&#125;class MessageHandlerTwo extends MessageHandler &#123; String getClientCode() &#123; return \"123_ABCD\"; &#125;&#125; 这样一来就可以为每一个接收消息的服务器生成一个相应的类对象，添加服务器就变得更加容易维护了。可是，这一个简单的改动引出了很多的代码。仅仅是为了支持不同的客户端行为代码，就要定义两种新的类型！现在来试试用我们刚才改造的语言来做同样的事情，注意，这种语言支持高阶函数： 12345678910111213141516171819202122class MessageHandler &#123; void handleMessage(Message msg, Function getClientCode) &#123; // ... Message msg1 = msg.setClientCode(getClientCode()); // ... sendMessage(msg1); &#125; // ...&#125;String getClientCodeOne() &#123; return \"ABCD_123\";&#125;String getClientCodeTwo() &#123; return \"123_ABCD\";&#125;MessageHandler handler = new MessageHandler();handler.handleMessage(someMsg, getClientCodeOne); 在上面的程序里，我们没有创建任何新的类型或是多层类的结构。仅仅是把相应的函数作为参数进行传递，就做到了和用面向对象编程一样的事情，而且还有额外的好处：一是不再受限于多层类的结构。这样做可以做运行时传递新的函数，可以在任何时候改变这些函数，而且这些改变不仅更加精准而且触碰的代码更少。这种情况下编译器其实就是在替我们编写面向对象的“粘合”代码（译者：又称胶水代码，粘接代码）！除此之外我们还可以享用FP编程的其他所有优势。函数式编程能提供的抽象服务还远不止于此。高阶函数只不过是个开始。 Currying我遇见的大多数码农都读过“四人帮”的那本《设计模式》。任何稍有自尊心的码农都会说这本书和语言无关，因此无论你用什么编程语言，当中提到的那些模式大体上适用于所有软件工程。听起来很厉害，然而事实却不是这样。函数式语言的表达能力很强。用这种语言编程的时候基本不需要设计模式，因为这种语言层次已经足够高，使得使用者可以以概念编程，从而完全不需要设计模式了。以适配器模式为例（有人知道这个模式和外观模式有什么区别吗？怎么觉得有人为了出版合同的要求而硬生生凑页数？）（译者：您不愧是高级黑啊）。对于一个支持currying技术的语言来说，这个模式就是多余的。在Java中最有名的适配器模式就是在其“默认”抽象单元中的应用：类。在函数式语言中这种模式其实就是函数。在这个模式中，一个接口被转换成另外一个接口，让不同的用户代码调用。接下来就有一个适配器模式的例子： 12345int pow(int i, int j);int square(int i)&#123; return pow(i, 2);&#125; 上面的代码中square函数计算一个整数的平方，这个函数的接口被转换成计算一个整数的任意整数次幂。在学术圈里这种简单的技术就被叫做currying（因为逻辑学家哈斯凯尔·加里用其数学技巧将这种技术描述出来，于是就以他的名字来命名了）。在一个FP语言中函数（而不是类）被作为参数进行传递，currying常常用于转化一个函数的接口以便于其他代码调用。函数的接口就是它的参数，于是currying通常用于减少函数参数的数量（见前例）。函数式语言生来就支持这一技术，于是没有必要为某个函数手工创建另外一个函数去包装并转换它的接口，这些函数式语言已经为你做好了。我们继续拓展Java来支持这一功能。 1square = int pow(int i, 2); 上面的语句实现了一个平方计算函数，它只需要一个参数。它会继而调用pow函数并且把第二个参数置为2。编译过后将生成以下Java代码： 123456class square_function_t &#123; int square(int i) &#123; return pow(i, 2); &#125;&#125;square_function_t square = new square_function_t(); 从上面的例子可以看到，很简单的，函数pow的封装函数就创建出来了。在FP语言中currying就这么简单：一种可以快速且简单的实现函数封装的捷径。我们可以更专注于自己的设计，编译器则会为你编写正确的代码！什么时候使用currying呢？很简单，当你想要用适配器模式（或是封装函数）的时候，就是用currying的时候。 惰性求值惰性求值（或是延迟求值）是一种有趣的技术，而当我们投入函数式编程的怀抱后这种技术就有了得以实现的可能。前面介绍并发执行的时候已经提到过如下代码： 123String s1 = somewhatLongOperation1();String s2 = somewhatLongOperation2();String s3 = concatenate(s1, s2); 在指令式语言中以上代码执行的顺序是显而易见的。由于每个函数都有可能改动或者依赖于其外部的状态，因此必须顺序执行。先是计算somewhatLongOperation1，然后到somewhatLongOperation2，最后执行concatenate。函数式语言就不一样了。在前面讨论过，somewhatLongOperation1和somewhatLongOperation2是可以并发执行的，因为函数式语言保证了一点：没有函数会影响或者依赖于全局状态。可是万一我们不想要这两个函数并发执行呢？这种情况下是不是也还是要顺序执行这些函数？答案是否定的。只有到了执行需要s1、s2作为参数的函数的时候，才真正需要执行这两个函数。于是在concatenate这个函数没有执行之前，都没有需要去执行这两个函数：这些函数的执行可以一直推迟到concatenate()中需要用到s1和s2的时候。假如把concatenate换成另外一个函数，这个函数中有条件判断语句而且实际上只会需要两个参数中的其中一个，那么就完全没有必要执行计算另外一个参数的函数了！Haskell语言就是一个支持惰性求值的例子。Haskell不能保证任何语句会顺序执行（甚至完全不会执行到），因为Haskell的代码只有在需要的时候才会被执行到。除了这些优点，惰性求值也有缺点。这里介绍了它的优点，我们将在下一章节介绍这些缺点以及如何克服它们。 代码优化惰性求值使得代码具备了巨大的优化潜能。支持惰性求值的编译器会像数学家看待代数表达式那样看待函数式程序：抵消相同项从而避免执行无谓的代码，安排代码执行顺序从而实现更高的执行效率甚至是减少错误。在此基础上优化是不会破坏代码正常运行的。严格使用形式系统的基本元素进行编程带来的最大的好处，是可以用数学方法分析处理代码，因为这样的程序是完全符合数学法则的。 抽象化控制结构惰性求值技术提供了更高阶的抽象能力，这提供了实现程序设计独特的方法。比如说下面的控制结构： 123unless(stock.isEuropean()) &#123; sendToSEC(stock);&#125; 程序中只有在stock为European的时候才执行sendToSEC。如何实现例子中的unless？如果没有惰性求值就需要求助于某种形式的宏（译者：用if不行么？），不过在像Haskell这样的语言中就不需要那么麻烦了。直接实现一个unless函数就可以！ 1234void unless(boolean condition, List code) &#123; if(!condition) code;&#125; 请注意，如果condition值为真，那就不会计算code。在其他严格语言（见严格求值）中这种行为是做不到的，因为在进入unless这个函数之前，作为参数的code已经被计算过了。 无穷数据结构惰性求值技术允许定义无穷数据结构，这要在严格语言中实现将非常复杂。例如一个储存Fibonacci数列数字的列表。很明显这样一个列表是无法在有限的时间内计算出这个无穷的数列并存储在内存中的。在像Java这样的严格语言中，可以定义一个Fibonacci函数，返回这个序列中的某个数。而在Haskell或是类似的语言中，可以把这个函数进一步抽象化并定义一个Fibonacci数列的无穷列表结构。由于语言本身支持惰性求值，这个列表中只有真正会被用到的数才会被计算出来。这让我们可以把很多问题抽象化，然后在更高的层面上解决它们（比如可以在一个列表处理函数中处理无穷多数据的列表）。 不足之处俗话说天下没有免费的午餐™。惰性求值当然也有其缺点。其中最大的一个就是，嗯，惰性。现实世界中很多问题还是需要严格求值的。比如说下面的例子： 12System.out.println(\"Please enter your name: \");System.in.readLine(); 在惰性语言中没人能保证第一行会中第二行之前执行！这也就意味着我们不能处理IO，不能调用系统函数做任何有用的事情（这些函数需要按照顺序执行，因为它们依赖于外部状态），也就是说不能和外界交互了！如果在代码中引入支持顺序执行的代码原语，那么我们就失去了用数学方式分析处理代码的优势（而这也意味着失去了函数式编程的所有优势）。幸运的是我们还不算一无所有。数学家们研究了不同的方法用以保证代码按一定的顺序执行（in a functional setting?）。这一来我们就可以同时利用到函数式和指令式编程的优点了！这些方法有continuations，monads以及uniqueness typing。这篇文章仅仅介绍了continuations，以后再讨论monads和uniqueness typing。有意思的是呢，coutinuations处理强制代码以特定顺序执行之外还有其他很多出处，这些我们在后面也会提及。 Continuationcontinuation对于编程，就像是达芬奇密码对于人类历史一样：它揭开了人类有史以来最大的谜团。好吧，也许没有那么夸张，不过它们的影响至少和当年发现负数有平方根不相上下。 我们对函数的理解只有一半是正确的，因为这样的理解基于一个错误的假设：函数一定要把其返回值返回给调用者。按照这样的理解，continuation就是更加广义的函数。这里的函数不一定要把返回值传回给调用者，相反，它可以把返回值传给程序中的任意代码。continuation就是一种特别的参数，把这种参数传到函数中，函数就能够根据continuation将返回值传递到程序中的某段代码中。说得很高深，实际上没那么复杂。直接来看看下面的例子好了： 12int i = add(5, 10);int j = square(i); add这个函数将返回15然后这个值会赋给i，这也是add被调用的地方。接下来i的值又会被用于调用square。请注意支持惰性求值的编译器是不能打乱这段代码执行顺序的，因为第二个函数的执行依赖于第一个函数成功执行并返回结果。这段代码可以用Continuation Pass Style（CPS）技术重写，这样一来add的返回值就不是传给其调用者，而是直接传到square里去了。 1int j = add(5, 10, square); 在上例中，add多了一个参数：一个函数，add必须在完成自己的计算后，调用这个函数并把结果传给它。这时square就是add的一个continuation。上面两段程序中j的值都是225。 这样，我们学习到了强制惰性语言顺序执行两个表达式的第一个技巧。再来看看下面IO程序（是不是有点眼熟？）： 12System.out.println(\"Please enter your name: \");System.in.readLine(); 这两行代码彼此之间没有依赖关系，因此编译器可以随意的重新安排它们的执行顺序。可是只要用CPS重写它，编译器就必须顺序执行了，因为重写后的代码存在依赖关系了。 1System.out.println(\"Please enter your name: \", System.in.readLine); 这段新的代码中println需要结合其计算结果调用readLine，然后再返回readLine的返回值。这使得两个函数得以保证按顺序执行而且readLine总被执行（这是由于整个运算需要它的返回值作为最终结果）。Java的println是没有返回值的，但是如果它可以返回一个能被readnLine接受的抽象值，问题就解决了！（译者：别忘了，这里作者一开始就在Java的基础上修改搭建自己的语言）当然，如果一直把函数按照这种方法串下去，代码很快就变得不可读了，可是没有人要求你一定要这样做。可以通过在语言中添加语法糖的方式来解决这个问题，这样程序员只要按照顺序写代码，编译器负责自动把它们串起来就好了。于是就可以任意安排代码的执行顺序而不用担心会失去FP带来的好处了（包括可以用数学方法来分析我们的程序）！如果到这里还有人感到困惑，可以这样理解，函数只是有唯一成员的类的实例而已。试着重写上面两行程序，让println和readLine编程这种类的实例，所有问题就都搞清楚了。到这里本章基本可以结束了，而我们仅仅了解到continuation的一点皮毛，对它的用途也知之甚少。我们可以用CPS完成整个程序，程序里所有的函数都有一个额外的continuation作为参数接受其他函数的返回值。还可以把任何程序转换为CPS的，需要做的只是把当中的函数看作是特殊的continuation（总是将返回值传给调用者的continuation）就可以了，简单到完全可以由工具自动完成（史上很多编译器就是这样做的）。 一旦将程序转为CPS的风格，有些事情就变得显而易见了：每一条指令都会有一些continuation，都会将它的计算结果传给某一个函数并调用它，在一个普通的程序中这个函数就是该指令被调用并且返回的地方。随便找个之前提到过的代码，比如说add(5,10)好了。如果add属于一个用CPS风格写出的程序，add的continuation很明显就是当它执行结束后要调用的那个函数。可是在一个非CPS的程序中，add的continuation又是什么呢？当然我们还是可以把这段程序转成CPS的，可是有必要这样做吗？事实上没有必要。注意观察整个CPS转换过程，如果有人尝试要为CPS程序写编译器并且认真思考过就会发现：CPS的程序是不需要栈的！在这里完全没有函数需要做传统意义上的“返回”操作，函数执行完后仅需要接着调用另外一个函数就可以了。于是就不需要在每次调用函数的时候把参数压栈再将它们从中取出，只要把这些参数存放在一片内存中然后使用跳转指令就解决问题了。也完全不需要保留原来的参数：因为这种程序里的函数都不返回，所以它们不会被用第二次！简单点说呢，用CPS风格写出来的程序不需要栈，但是每次调用函数的时候都会要多加一个参数。非CPS风格的程序不需要额外的参数但又需要栈才能运行。栈里面存的是什么？仅仅是参数还有一个供函数运行结束后返回的程序指针而已。这个时候你是不是已经恍然大悟了？对啊，栈里面的数据实际上就是continuation的信息！栈上的程序返回指针实质上就是CPS程序中需要调用的下一个函数！想要知道add(5, 10)的continuation是什么？只要看它运行时栈的内容就可以了。接下来就简单多了。continuation和栈上指示函数返回地址的指针其实是同一样东西，只是continuation是显式的传递该地址并且因此代码就不局限于只能返回到函数被调用的地方了。前面说过，continuation就是函数，而在我们特制的语言中函数就是类的实例，那么可以得知栈上指向函数返回地址的指针和continuation的参数是一样的，因为我们所谓的函数（就像类的一个实例）其实就是指针。这也意味着在程序运行的任何时候，你都可以得到当前的continuation（就是栈上的信息）。 好了，我们已经搞清楚当前的continuation是什么了。接下来要弄明白它的存在有什么意义。只要得到了当前的continuation并将它保存起来，就相当于保存了程序的当前状态：在时间轴上把它冻结起来了。这有点像操作系统进入休眠状态。continuation对象保存了足够的信息随时可以从指定的某个状态继续运行程序。在切换线程的时候操作系统也是这样做的。唯一的区别在于它保留了所有的控制权利。当请求某个continuation对象时（在Scheme语言中是通过调用call-with-current-continuation函数实现的）得到的是一个存有当前continuation的对象，也就是栈对象（在CPS中也就是下一个要执行的函数）。可以把这个对象保存做一个变量中（或者是存在磁盘上）。当以该continuation对象“重启”该程序时，程序的状态就会立即“转换”为该对象中保存的状态。这一点和切换回一个被暂停的线程或是从系统休眠中唤醒很相像，唯一不同的是continuatoin对象可以反复的这样使用。当系统唤醒后，休眠前保存的信息就会销毁，否则你也可以反复的从该点唤醒系统，就像乘时光机回到过去一样。有了continuation你就可以做到这一点！ 那么continuation在什么情况下有用呢？有一些应用程序天生就没有状态，如果要在这样的系统中模拟出状态以简化工作的时候，就可以用到continuation。最合适的应用场合之一就是网页应用程序。微软的ASP.NET为了让程序员更轻松的编写应用程序，花了大量的精力去模拟各种状态。假如C#支持continuation的话，那么ASP.NET的复杂度将减半：因为只要把某一时刻的continuation保存起来，下次用户再次发起同样请求的时候，重新载入这个continuation即可。对于网络应用的程序员来说就再也没有中断了：轻轻松松程序就从下一行开始继续运行了！对于一些实际问题来说，continuation是一种非常有用的抽象工具。如今大量的传统胖客户端（见瘦客户端）正纷纷走进网络，continuation在未来将扮演越来越重要的角色。 模式匹配模式匹配并不是什么新功能。而事实上它和函数式编程也没有什么太大的关系。它之所以常常被认为是FP的一个特性，是因为在函数式语言已经支持模式匹配很长一段时间后的今天，指令式语言是还没有这个功能。 还是直接用例子来看看什么是模式匹配吧，这是一个用Java写的Fibonacci函数： 123456 int fib(int n) &#123; if(n == 0) return 1; if(n == 1) return 1; return fib(n - 2) + fib(n - 1);&#125; 再看看用我们基于Java修改过的新语言写出来的Fibonacci函数，这种新语言就支持模式匹配： 123456789 int fib(0) &#123; return 1;&#125;int fib(1) &#123; return 1;&#125;int fib(int n) &#123; return fib(n - 2) + fib(n - 1);&#125; 区别在哪里呢？在于后者的编译器替我们实现了程序的分支。这有什么了不起的？确实也没什么。只是有人注意到很多函数中有非常复杂的switch结构（对于函数式程序而言更是如此），于是想到如果能把这层结构也抽象化就更好了。然后就把这个复杂的函数拆分成若干新的函数，并在这些函数的某些参数中应用模式（这和重载有点类似）。这样依赖当这个函数被调用的时候，编译器会在运行时将调用者传入的参数与各个新函数的参数定义进行比较，找出合适的那个函数来执行。合适的函数往往是参数定义上最具体最接近传入参数的那个函数。在这个例子中，当n为1时，可以用函数int fib(int n)，不过真正调用的是int fib(1)因为这个函数更具体更接近调用者的要求。模式匹配一般来说要比这里举的例子更加复杂。比如说，高级模式匹配系统可以支持下面的操作： 12int f(int n &lt; 10) &#123; ... &#125;int f(int n) &#123; ... &#125; 那么什么情况下模式匹配会有用呢？在需要处理一大堆程序分支的时候！每当需要实现复杂的嵌套if语句的时候，模式匹配可以帮助你用更少的代码更好的完成任务。我所知道的一个这样的函数是标准的WndProc函数，该函数是所有Win32应用程序必须具备的（尽管它经常会被抽象化）。模式匹配系统一般都可以像匹配简单数值一样匹配数据集合。举个例子，对于一个接受数组作为参数的函数，可以通过模式匹配数组中第一个数字为1并且第三个数字大于3的输入。模式匹配的另外一个好处是每当需要添加或者修改程序分支时，再也不用面对那个庞大臃肿的函数了。只要添加（或者修改）相关的函数定义即可。有了模式匹配就不再需要四人帮的很多设计模式了。程序分支越多越复杂，模式匹配就越有用。而在习惯使用这一技术之后，你可能会怀疑没有它你一天都过不下去了。 Closure目前为止关于函数式编程各种功能的讨论都只局限在“纯”函数式语言范围内：这些语言都是lambda演算的实现并且都没有那些和阿隆佐形式系统相冲突的特性。然而，很多函数式语言的特性哪怕是在lambda演算框架之外都是很有用的。确实，如果一个公理系统的实现可以用数学思维来看待程序，那么这个实现还是很有用的，但这样的实现却不一定可以付诸实践。很多现实中的语言都选择吸收函数式编程的一些元素，却又不完全受限于函数式教条的束缚。很多这样的语言（比如Common Lisp）都不要求所有的变量必须为final，可以修改他们的值。也不要求函数只能依赖于它们的参数，而是可以读写函数外部的状态。同时这些语言又包含了FP的特性，如高阶函数。与在lambda演算限制下将函数作为参数传递不同，在指令式语言中要做到同样的事情需要支持一个有趣的特性，人们常把它称为lexical closure。还是来看看例子。要注意的是，这个例子中变量不是final，而且函数也可以读写其外部的变量： 12345678910 Function makePowerFn(int power) &#123; int powerFn(int base) &#123; return pow(base, power); &#125; return powerFn;&#125;Function square = makePowerFn(2);square(3); // returns 9 makePowerFn函数返回另一个函数，这个新的函数需要一个整数参数然后返回它的平方值。执行square(3)的时候具体发生了什么事呢？变量power并不在powerFn的域内，因为makePowerFn早就运行结束返回了，所以它的栈也已经不存在了。那么square又是怎么正常工作的呢？这个时候需要语言通过某种方式支持继续存储power的值，以便square后面继续使用。那么如果再定义一个函数，cube，用来计算立方，又应该怎么做呢？那么运行中的程序就必须存储两份power的值，提供给makePowerFn生成的两个函数分别使用。这种保存变量值的方法就叫做closure。closure不仅仅保存宿主函数的参数值，还可以用在下例的用法中： 1234567891011121314151617Function makeIncrementer() &#123; int n = 0; int increment() &#123; return ++n; &#125;&#125;Function inc1 = makeIncrementer();Function inc2 = makeIncrementer();inc1(); // returns 1;inc1(); // returns 2;inc1(); // returns 3;inc2(); // returns 1;inc2(); // returns 2;inc2(); // returns 3; 运行中的程序负责存储n的值，以便incrementer稍后可以访问它。与此同时，程序还会保存多份n的拷贝，虽然这些值应该在makeIncrementer返回后就消失，但在这个情况下却继续保留下来给每一个incrementer对象使用。这样的代码编译之后会是什么样子？closure幕后的真正工作机理又是什么？这次运气不错，我们有一个后台通行证，可以一窥究竟。一点小常识往往可以帮大忙。乍一看这些本地变量已经不再受限于基本的域限制并拥有无限的生命周期了。于是可以得出一个很明显的结论：它们已经不是存在栈上，而是堆上了8。这么说来closure的实现和前面讨论过的函数差不多，只不过closure多了一个额外的引用指向其外部的变量而已： 12345 class some_function_t &#123; SymbolTable parentScope; // ...&#125; 当closure需要访问不在它本地域的变量时，就可以通过这个引用到更外一层的父域中寻找该变量。谜底揭开了！closure将函数编程与面向对象的方法结合了起来。下一次为了保存并传递某些状态而创建类的时候，想想closure。它能在运行时从相应的域中获得变量，从而可以把该变量当初“成员变量”来访问，也因为这样，就不再需要去创建一个成员变量了。 路在何方？这篇文章仅仅涉及到函数式编程的一些皮毛。考虑到有时候星星之火可以燎原，所以如果它能给你一些帮助那就再好不过了。接下来我计划就范畴论、monads、函数式编程数据结构、函数式语言中的类型系统、并行函数式编程、数据库的函数式编程以及更多的话题写些类似的文章。如果我可以写出（在我学习的同时）以上清单的一半，我的人生就完整了。于此同时，Google将是我们的良师益友。 ###欢迎联系如果您有任何问题，评价或者建议，请发邮件到coffeemug@gmail.com（译者：如果翻译方面的问题／建议请发到yang.huang@ymail.com:)）。期待您的回复。 注：1当我在2005年求职时的的确确经常问别人这个问题。看着那些茫然的面孔实在是很好玩的事情。你们这些年薪30万美金的家伙，至少应该对自己可以利用的工具有个起码的理解嘛。2这是个有争议的问题。物理学家和数学家不得不承认目前还无法确定宇宙万物是不是都遵从可以用数学方法描述的各种法则。3我一直一来都很讨厌在历史课上罗列一堆枯燥无味的时间、人名、事件。对我来说历史就是关于那些改变世界的人们活生生的故事，是他们行为背后的个人动机，是那些他们用以影响芸芸众生的方法和工具。从这个角度来说，接下来的这堂历史课是不完整的，很遗憾。只有那些非常相关的人和事会被提及。4在我学习函数式编程的时候，“lambda”这个术语搞得我很烦，因为我不知道它到底是什么意思。在这里lambda就是一个函数，在数学符号中用这个希腊字母只是因为它更容易写。所以以后在谈及函数式编程的时候只要你听到lambda，把它在脑中翻译为“函数”就可以了。5有意思的是不论如何Java中的字符串总是不可修改的。讨论这种背叛Java的设计背后的原因会很有意思，可惜这样会让我们跑题的。6大部分函数式语言的编译器都会尽量将迭代函数转换为对等的循环语句。这种做法叫做尾调用优化。7反之则不一定成立。尽管有时候可以证明两段代码是等价的，但不是在所有的情况下都可以得出这样的结论。8实际上这样做并不比栈上存储要慢，因为在引入垃圾回收机制)后，内存分配操作的时间代价仅为O(1)。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://londbell,github.io/tags/笔记/"},{"name":"收藏","slug":"收藏","permalink":"http://londbell,github.io/tags/收藏/"},{"name":"转载","slug":"转载","permalink":"http://londbell,github.io/tags/转载/"}]}]