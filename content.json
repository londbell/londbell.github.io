[{"title":"Factorial Trailing Zeroes","date":"2017-03-28T02:03:00.000Z","path":"2017/03/28/leetcode-172-factorial-trailing-zeroes/","text":"题目描述给出一个整数N，求N阶乘中有几个0。 乘法得到0就是2*5，2的数量不知比5多到哪里去了，只要计算5的数量就行，那就一直除于5，计算即可。 Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 原题地址12345678910public class Solution &#123; public int trailingZeroes(int n) &#123; int count = 0; while(n != 0) &#123; n /= 5; count += n; &#125; return count; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"Edit Distance","date":"2017-03-27T13:42:00.000Z","path":"2017/03/27/leetcode-72-Edit-Distance/","text":"题目描述给出两个字符串，看S1最少需要几步可以变成S2？1.可以插入一个字符。2.可以删除一个字符。3.可以替换一个字符。 Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: a) Insert a characterb) Delete a characterc) Replace a character 解题思路：图中表示的是，将s1:Park变成s:Spake的最小操作步数,dp[i][j] 表示从s1的前i位，变到s2的前j位，最小需要多少改变 比如我们看矩阵的第一行，分别代表从” “(空字符)变到”s”, 变到”sp”，变到”spa”,变到”spak”，变到”spake” 需要多少次改变，因为每次只能选择往上添加一个字符，所以累加操作数分别为1,2,3,4,5 同理，矩阵的第一列分别代表从”p” 变到” “(空字符)，从”pa“变空，从”par“变空,从”park”变空需要多少次改变，因为每次只能选择删去一个字符，所以累加操作数分别为1,2,3,4 可以参考图中绿色字体的那个例子 下箭头： 我们现在已经知道了从” “ 到”s“的距离，那么从”p” 到’’s” 我们只要删去这个p就行了 （Delete） 右箭头： 我们现在已经知道了从”p“到” “的距离，那么从”p” 到”s” 我们只要插入这个s就行了 （Insert） 右下箭头： 我们现在已经知道了从” “到” “的距离，那么从”p” 到”s” 我们只需要把p替换成s就行了(Replace) 注意替换的时候，如果i所代表的的字符 == j所代表的字符，那么我们便不需要做任何多余的操作（No Operation） 原题地址1234567891011121314151617181920212223242526class Solution &#123; public int minDistance(String word1, String word2) &#123; int dp[][] = new int[word1.length() + 1][word2.length() + 1]; dp[1][0] = 0; for(int i = 1; i &lt;= word1.length(); i++) &#123; dp[i][0] = dp[i - 1][0] + 1; &#125; for(int i = 1; i &lt;= word2.length(); i++) &#123; dp[0][i] = dp[0][i - 1] + 1; &#125; for(int i = 1; i &lt;= word1.length(); i++) &#123; for(int j = 1; j &lt;= word2.length(); j++) &#123; if(word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1]; //状态转移，说明此时不需要任何操作 &#125;else &#123; dp[i][j] = 1 + Math.min(dp[i][j-1], Math.min(dp[i-1][j], dp[i-1][j-1])); &#125; &#125; &#125; return dp[word1.length()][word2.length()]; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"Interleaving String","date":"2017-03-27T12:42:00.000Z","path":"2017/03/27/leetcode-97-Interleaving-String/","text":"题目描述给出三个字符串，看S1和S2能否交叉取char字符组成S3 Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example,Given:s1 = “aabcc”,s2 = “dbbca”, When s3 = “aadbbcbcac”, return true.When s3 = “aadbbbaccc”, return false. 解题思路：DP[i][j]存的是取S1的i个字符，取S2的j个字符情况下，能否构成S3;由于存的是“个数”，所以对应到String操作上是i+1,要注意另外需要注意第二次运算交集时要并上本身（第一次运算说明本路径是有效的）。 原题地址123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public static boolean isInterleave(String s1, String s2, String s3) &#123; if(s1 == \"\" || s2 == \"\" || s3 == \"\") &#123; return false; &#125; if((s1.length() + s2.length()) != s3.length()) &#123; return false; &#125; boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1]; dp[0][0] = true; for(int m = 1; m &lt; s1.length() + 1; m++) &#123; if (s1.charAt(m - 1) == s3.charAt(m - 1)) &#123; dp[m][0] = true &amp;&amp; dp[m - 1][0]; &#125; else &#123; dp[m][0] = false; &#125; &#125; for(int m = 1; m &lt; s2.length() + 1; m++) &#123; if(s2.charAt(m - 1) == s3.charAt(m - 1)) &#123; dp[0][m] = true &amp;&amp; dp[0][m - 1]; &#125;else&#123; dp[0][m] = false; &#125; &#125; for(int m = 1; m &lt; s1.length() + 1; m++) &#123; for(int n = 1; n &lt; s2.length() + 1; n++) &#123; if(s1.charAt(m - 1) == s3.charAt(m + n - 1)) &#123; dp[m][n] = true &amp;&amp; dp[m-1][n]; &#125; if(s2.charAt(n - 1) == s3.charAt(m + n - 1)) &#123; dp[m][n] = (true &amp;&amp; dp[m][n-1]) || dp[m][n];//防止前面的true被交集运算后得到false &#125; &#125; &#125; for(int m = 0; m &lt; s1.length() + 1; m++) &#123; for(int n = 0; n &lt; s2.length() + 1; n++) &#123; //System.out.println(dp[m][n]); &#125; &#125; return dp[s1.length()][s2.length()]; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"Subsets","date":"2017-03-27T11:09:00.000Z","path":"2017/03/27/leetcode-78-Subsets/","text":"题目描述给出一个数组，每个元素均不同，给出所有他的子集 Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 原题地址12345678910111213141516class Solution &#123; public static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;(); int total = 2 &lt;&lt; (nums.length) - 1; for(int i = 0;i &lt; total; i ++) &#123; List&lt;Integer&gt; temp = new LinkedList&lt;&gt;(); for(int j = 0; j &lt; nums.length; j++) &#123; if((i &amp; (1 &lt;&lt; j)) != 0) &#123;//不能写==1，注意 temp.add(nums[j]); &#125; &#125; list.add(temp); &#125; return list; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"等价交换","date":"2017-03-26T16:34:00.000Z","path":"2017/03/27/diary-2017-0327-0034/","text":"人没有牺牲就什么都得不到，为了得到什么东西，就需要付出同等的代价。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://londbell,github.io/tags/随笔/"}]},{"title":"Roman to Integer","date":"2014-12-03T09:32:00.000Z","path":"2014/12/03/leetcode-13-Roman-to-Integer/","text":"题目描述给出一个罗马数字字符串，将其计算为阿拉伯数字。 Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 背景知识罗马数字是阿拉伯数字传入之前使用的一种数码。罗马数字采用七个罗马字母作数字、即Ⅰ（1）、X（10）、C（100）、M（1000）、V（5）、L（50）、D（500）。记数的方法： 1.相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3； 2.小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12； 3.小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9； 4.在一个数的上面画一条横线，表示这个数增值 1,000 倍，如=5000。 原题地址123456789101112131415161718192021222324252627public class Solution &#123; public int romanToInt(String s) &#123; Map map = new HashMap(); map.put('I', 1);//Key是Char就用单引号，是String就用双引号 map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int result = 0; for(int i = s.length() - 1; i &gt;= 0; --i) &#123; if(i == s.length() - 1) &#123; result = (Integer)map.get(s.charAt(i)); continue; &#125; if(((Integer)map.get(s.charAt(i))) &gt;= ((Integer)map.get(s.charAt(i + 1)))) &#123; result += (Integer) map.get(s.charAt(i)); &#125;else &#123; result -= (Integer) map.get(s.charAt(i)); &#125; &#125; return result; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"Add Two Numbers","date":"2014-07-03T02:11:00.000Z","path":"2014/07/03/leetcode-02-Add-Two-Numbers/","text":"题目描述给定两个由个位数组成的非空链表，按位置相加，进位累加到下一个元素上，每个元素只留个位，两个链表长度可能不等。 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 原题地址 我的做法：1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode temp = head; int count = 0; head.val = l1.val + l2.val; if(head.val &gt;= 10) &#123; count = 1; head.val %= 10; &#125; while(l1.next != null || l2.next !=null || count == 1) &#123; if(l1.next == null &amp;&amp; l2.next == null) &#123; temp.next = new ListNode(count); &#125; else if(l1.next == null) &#123; temp.next = new ListNode(l2.next.val + count); l2 = l2.next; &#125;else if(l2.next == null) &#123; temp.next = new ListNode(l1.next.val + count); l1 = l1.next; &#125;else if(l1.next != null &amp;&amp; l2.next != null) &#123; temp.next = new ListNode(l1.next.val + l2.next.val + count); l1 = l1.next; l2 = l2.next; &#125; if(temp.next.val &gt;= 10) &#123; count = 1; temp.next.val %= 10; &#125;else &#123; count = 0; &#125; temp = temp.next; &#125; return head; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"Two Sum","date":"2014-07-01T13:52:00.000Z","path":"2014/07/01/leetcode-01-Two-Sum/","text":"题目描述给定一个整形元素组成的数组，给出一个数，求数组中是否存在两个数之和与给定数相等。不能使用同一个元素两次，同时一定只会有一个解。 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 原题地址 逗逼解法：12345678910111213141516171819202122232425262728293031323334353637package com.company;public class Main &#123; public static void main(String[] args) &#123; // write your code here int nums3[] = &#123;3, 2, 4&#125;; int target3 = 6; int nums4[] = &#123;2,7,11,15&#125;; int target4 = 9; int twoSum[] = Solution.twoSum(nums3, target3); System.out.print(twoSum[0] + \" \" + twoSum[1]); System.out.println(\" finish\"); &#125;&#125;class Solution &#123; public static int[] twoSum(int[] nums, int target) &#123; int flag = 0; int array[] = &#123;0,0&#125;; for(int i = 0; i &lt; nums.length; i++) &#123; if(flag == 1) &#123; break; &#125; for(int j = i + 1; j &lt; nums.length; j++) &#123; if((nums[i] + nums[j] == target)) &#123; array[0] = i; array[1] = j; flag = 1; break; &#125; &#125; &#125; return array; &#125;&#125; 改进方法1234567891011121314151617181920212223242526272829303132package com.company;public class Main &#123; public static void main(String[] args) &#123; // write your code here int nums3[] = &#123;3, 2, 4&#125;; int target3 = 6; int nums4[] = &#123;2,7,11,15&#125;; int target4 = 9; int twoSum[] = Solution.twoSum(nums3, target3); System.out.print(twoSum[0] + \" \" + twoSum[1]); System.out.println(\" finish\"); &#125;&#125;class Solution &#123; public static int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int result[] = new int[2]; for (int i = 0; i &lt; nums.length; i++)&#123; int num = target - nums[i]; if(map.containsKey(num))&#123; result[0] = map.get(num); result[1] = i; return result; &#125; map.put(nums[i], i); &#125; return result; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]}]