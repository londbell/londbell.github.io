[{"title":"Spiral Matrix","date":"2017-03-28T05:03:00.000Z","path":"2017/03/28/leetcode-54-spiral-matrix/","text":"题目描述给出一个M X N的矩阵，以螺旋方式给出其序列。Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example,Given the following matrix:12345[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] You should return [1,2,3,6,9,8,7,4,5]. 原题地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123; public static List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); boolean flagSub = true; if(matrix.length == 0) &#123; return list; &#125; do &#123; boolean [][]flag = new boolean[matrix.length][matrix[0].length]; for(int i = 0; i &lt; matrix[0].length; i++) &#123; list.add(matrix[0][i]); flag[0][i] = true; &#125; for (boolean[] e: flag) &#123; for (boolean q : e) &#123; q = false; &#125; &#125; for(int i = 1; i &lt; matrix.length; i++) &#123; if (!flag[i][matrix[0].length - 1]) &#123; list.add(matrix[i][matrix[0].length - 1]); flag[i][matrix[0].length - 1] = true; &#125; &#125; for(int i = matrix[0].length - 2; i &gt;= 0; i--) &#123;// i = 0的边界条件 if(!flag[matrix.length-1][i]) &#123; list.add(matrix[matrix.length - 1][i]); flag[matrix.length - 1][i] = true; &#125; &#125; for(int i = matrix.length - 2; i &gt; 0; i--) &#123; if(!flag[i][0]) &#123; list.add(matrix[i][0]); flag[i][0] = true; &#125; &#125; flagSub = matrix.length &gt;2 &amp;&amp; matrix[0].length &gt;2; if(flagSub) &#123; matrix = getSubMatrix(matrix); &#125; &#125;while(flagSub); return list; &#125; public static int[][] getSubMatrix(int[][] matrix) &#123; int[][] subMatrix = new int[matrix.length - 2][matrix[0].length -2]; for(int i = 1; i &lt; matrix.length - 1; i ++) &#123; for(int j = 1; j &lt; matrix[0].length - 1; j++) &#123; subMatrix[i - 1][j - 1] = matrix[i][j]; &#125; &#125; return subMatrix; &#125;&#125; 这种做法比较蠢，有大佬这样做，用方向矩阵的方式来做：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* Solution 3: 使用方向矩阵来求解 */ public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;(); if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return ret; &#125; int rows = matrix.length; int cols = matrix[0].length; int visitedRows = 0; int visitedCols = 0; // indicate the direction of x // 1: means we are visiting the row by the right direction. // -1: means we are visiting the row by the left direction. int[] x = &#123;1, 0, -1, 0&#125;; // 1: means we are visiting the colum by the down direction. // -1: means we are visiting the colum by the up direction. int[] y = &#123;0, 1, 0, -1&#125;; // 0: right, 1: down, 2: left, 3: up. int direct = 0; int startx = 0; int starty = 0; int candidateNum = 0; int step = 0; while (true) &#123; if (x[direct] == 0) &#123; // visit Y axis. candidateNum = rows - visitedRows; &#125; else &#123; // visit X axis candidateNum = cols - visitedCols; &#125; if (candidateNum &lt;= 0) &#123; break; &#125; ret.add(matrix[startx][starty]); step++; if (step == candidateNum) &#123; step = 0; visitedRows += x[direct] == 0 ? 0: 1; visitedCols += y[direct] == 0 ? 0: 1; // move forward the direction. direct ++; direct = direct%4; &#125; // 根据方向来移动横坐标和纵坐标。 startx += y[direct]; starty += x[direct]; &#125; return ret; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"},{"name":"矩阵","slug":"矩阵","permalink":"http://londbell,github.io/tags/矩阵/"}]},{"title":"Factorial Trailing Zeroes","date":"2017-03-28T02:03:00.000Z","path":"2017/03/28/leetcode-172-factorial-trailing-zeroes - 副本/","text":"题目描述给出一个整数N，求N阶乘中有几个0。 乘法得到0就是2*5，2的数量不知比5多到哪里去了，只要计算5的数量就行，那就一直除于5，计算即可。 Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 原题地址12345678910public class Solution &#123; public int trailingZeroes(int n) &#123; int count = 0; while(n != 0) &#123; n /= 5; count += n; &#125; return count; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"Edit Distance","date":"2017-03-27T13:42:00.000Z","path":"2017/03/27/leetcode-72-Edit-Distance/","text":"题目描述给出两个字符串，看S1最少需要几步可以变成S2？1.可以插入一个字符。2.可以删除一个字符。3.可以替换一个字符。 Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: a) Insert a characterb) Delete a characterc) Replace a character 解题思路：图中表示的是，将s1:Park变成s:Spake的最小操作步数,dp[i][j] 表示从s1的前i位，变到s2的前j位，最小需要多少改变 比如我们看矩阵的第一行，分别代表从” “(空字符)变到”s”, 变到”sp”，变到”spa”,变到”spak”，变到”spake” 需要多少次改变，因为每次只能选择往上添加一个字符，所以累加操作数分别为1,2,3,4,5 同理，矩阵的第一列分别代表从”p” 变到” “(空字符)，从”pa“变空，从”par“变空,从”park”变空需要多少次改变，因为每次只能选择删去一个字符，所以累加操作数分别为1,2,3,4 可以参考图中绿色字体的那个例子 下箭头： 我们现在已经知道了从” “ 到”s“的距离，那么从”p” 到’’s” 我们只要删去这个p就行了 （Delete） 右箭头： 我们现在已经知道了从”p“到” “的距离，那么从”p” 到”s” 我们只要插入这个s就行了 （Insert） 右下箭头： 我们现在已经知道了从” “到” “的距离，那么从”p” 到”s” 我们只需要把p替换成s就行了(Replace) 注意替换的时候，如果i所代表的的字符 == j所代表的字符，那么我们便不需要做任何多余的操作（No Operation） 原题地址1234567891011121314151617181920212223242526class Solution &#123; public int minDistance(String word1, String word2) &#123; int dp[][] = new int[word1.length() + 1][word2.length() + 1]; dp[1][0] = 0; for(int i = 1; i &lt;= word1.length(); i++) &#123; dp[i][0] = dp[i - 1][0] + 1; &#125; for(int i = 1; i &lt;= word2.length(); i++) &#123; dp[0][i] = dp[0][i - 1] + 1; &#125; for(int i = 1; i &lt;= word1.length(); i++) &#123; for(int j = 1; j &lt;= word2.length(); j++) &#123; if(word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1]; //状态转移，说明此时不需要任何操作 &#125;else &#123; dp[i][j] = 1 + Math.min(dp[i][j-1], Math.min(dp[i-1][j], dp[i-1][j-1])); &#125; &#125; &#125; return dp[word1.length()][word2.length()]; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://londbell,github.io/tags/动态规划/"},{"name":"字符串","slug":"字符串","permalink":"http://londbell,github.io/tags/字符串/"}]},{"title":"Interleaving String","date":"2017-03-27T12:42:00.000Z","path":"2017/03/27/leetcode-97-Interleaving-String/","text":"题目描述给出三个字符串，看S1和S2能否交叉取char字符组成S3 Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example,Given:s1 = “aabcc”,s2 = “dbbca”, When s3 = “aadbbcbcac”, return true.When s3 = “aadbbbaccc”, return false. 解题思路：DP[i][j]存的是取S1的i个字符，取S2的j个字符情况下，能否构成S3;由于存的是“个数”，所以对应到String操作上是i+1,要注意另外需要注意第二次运算交集时要并上本身（第一次运算说明本路径是有效的）。 原题地址123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public static boolean isInterleave(String s1, String s2, String s3) &#123; if(s1 == \"\" || s2 == \"\" || s3 == \"\") &#123; return false; &#125; if((s1.length() + s2.length()) != s3.length()) &#123; return false; &#125; boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1]; dp[0][0] = true; for(int m = 1; m &lt; s1.length() + 1; m++) &#123; if (s1.charAt(m - 1) == s3.charAt(m - 1)) &#123; dp[m][0] = true &amp;&amp; dp[m - 1][0]; &#125; else &#123; dp[m][0] = false; &#125; &#125; for(int m = 1; m &lt; s2.length() + 1; m++) &#123; if(s2.charAt(m - 1) == s3.charAt(m - 1)) &#123; dp[0][m] = true &amp;&amp; dp[0][m - 1]; &#125;else&#123; dp[0][m] = false; &#125; &#125; for(int m = 1; m &lt; s1.length() + 1; m++) &#123; for(int n = 1; n &lt; s2.length() + 1; n++) &#123; if(s1.charAt(m - 1) == s3.charAt(m + n - 1)) &#123; dp[m][n] = true &amp;&amp; dp[m-1][n]; &#125; if(s2.charAt(n - 1) == s3.charAt(m + n - 1)) &#123; dp[m][n] = (true &amp;&amp; dp[m][n-1]) || dp[m][n];//防止前面的true被交集运算后得到false &#125; &#125; &#125; for(int m = 0; m &lt; s1.length() + 1; m++) &#123; for(int n = 0; n &lt; s2.length() + 1; n++) &#123; //System.out.println(dp[m][n]); &#125; &#125; return dp[s1.length()][s2.length()]; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode - 动态规划 - 字符串","slug":"LeetCode-动态规划-字符串","permalink":"http://londbell,github.io/tags/LeetCode-动态规划-字符串/"}]},{"title":"Subsets","date":"2017-03-27T11:09:00.000Z","path":"2017/03/27/leetcode-78-Subsets/","text":"题目描述给出一个数组，每个元素均不同，给出所有他的子集 Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 原题地址12345678910111213141516class Solution &#123; public static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;(); int total = 2 &lt;&lt; (nums.length) - 1; for(int i = 0;i &lt; total; i ++) &#123; List&lt;Integer&gt; temp = new LinkedList&lt;&gt;(); for(int j = 0; j &lt; nums.length; j++) &#123; if((i &amp; (1 &lt;&lt; j)) != 0) &#123;//不能写==1，注意 temp.add(nums[j]); &#125; &#125; list.add(temp); &#125; return list; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"等价交换","date":"2017-03-26T16:34:00.000Z","path":"2017/03/27/diary-2017-0327-0034/","text":"人没有牺牲就什么都得不到，为了得到什么东西，就需要付出同等的代价。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://londbell,github.io/tags/随笔/"}]},{"title":"Factorial Trailing Zeroes","date":"2016-03-27T02:03:00.000Z","path":"2016/03/27/leetcode-338-Counting Bits /","text":"题目描述大意就是实现求给出比num小的所有数的二进制位中1的位数，隐藏提示是使用动态规划。 Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.Example: For num = 5 you should return [0,1,1,2,1,2].Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?Space complexity should be O(n).Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. 原题地址 逗逼解法12345678910public class Solution &#123; public int trailingZeroes(int n) &#123; int count = 0; while(n != 0) &#123; n /= 5; count += n; &#125; return count; &#125;&#125; 动态规划需要注意到的是，每隔2^n的大小，就会刚好多出一位，也就是说构造出动态规划的叠加数组，在以前计算过的基础上加1，即可得到后面数的“1”位数。 12345678910111213141516public class Solution &#123; public static int[] countBits(int num) &#123; if(num == 0) return new int[]&#123;0&#125;; int[] result = new int[num + 1]; int len, count = 0; while(true)&#123; len = count + 1; for(int i = 0; i &lt; len; i++)&#123; ++count; result[count] = result[i] + 1; if(count &gt;= num) return result; &#125; &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://londbell,github.io/tags/动态规划/"},{"name":"位操作","slug":"位操作","permalink":"http://londbell,github.io/tags/位操作/"}]},{"title":"Valid Number","date":"2016-03-23T01:21:00.000Z","path":"2016/03/23/leetcode-65-valid-number/","text":"题目描述检查给定字符串是否为合法的数字。 Validate if a given string is numeric. 123456Some examples:&quot;0&quot; =&gt; true&quot; 0.1 &quot; =&gt; true&quot;abc&quot; =&gt; false&quot;1 a&quot; =&gt; false&quot;2e10&quot; =&gt; true Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. 解题步骤：先Trim去空格（原题用例前后有空格，是合法的。）然后检查第一位的“+”， “-”。接着分割。可以出现科学计算法的e，然后可以出现小数点，但是都只能出现一次。先以e分割，注意e前后都必须是整数，由于小数点可以出现在e前，所以应该对e后端进行数字校验。同理对小数点操作。小数点允许前后两段至多有一段不为0。原题地址 我的做法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public static boolean isNumber(String s) &#123; s = s.trim(); if(s.length() == 0) &#123; return false; &#125; if(s.charAt(0) == '+' || s.charAt(0) == '-')&#123; s = s.substring(1); &#125; int loc = s.indexOf('e') &gt;= 0 ? s.indexOf('e') : s.indexOf('E'); if(loc &gt; 0) &#123; String sTemp = s.substring(loc + 1); if(sTemp.length() == 0) &#123; return false; &#125; if(sTemp.charAt(0) == '+' || sTemp.charAt(0) == '-') &#123; sTemp = sTemp.substring(1); &#125; if(!isPureDigit(sTemp)) &#123; return false; &#125; s = s.substring(0, loc); &#125;else if(loc == 0) &#123; return false; &#125; int locDot = s.indexOf('.'); if(locDot &gt;= 0) &#123; String preDot = s.substring(0, locDot); String postDot = s.substring(locDot + 1); if(preDot.isEmpty()) &#123; return isPureDigit(postDot); &#125; if(postDot.isEmpty()) &#123; return isPureDigit(preDot); &#125; return isPureDigit(preDot) &amp;&amp; isPureDigit(postDot); &#125; return isPureDigit(s); &#125; public static boolean isPureDigit(String s) &#123; if (s.isEmpty()) return false; for(int i = 0; i &lt; s.length(); ++i) &#123; if (!Character.isDigit(s.charAt(i))) &#123; return false; &#125; &#125; return true; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"search a 2dmatrix","date":"2015-09-01T07:21:00.000Z","path":"2015/09/01/leetcode-74-search-a-2d-matrix/","text":"题目描述给定一个矩阵，求特定的数是否在矩阵中。矩阵每一行从小到大排列。每一行的最小元素比上一行最大元素大。 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. For example, Consider the following matrix: 我的做法：写起来简单，性能很辣鸡。123456789101112131415161718public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix.length == 0 || matrix == null) &#123; return false; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int[] e : matrix) &#123; for(int q : e) &#123; list.add(q); &#125; &#125; if(list.contains(target)) &#123; return true; &#125; return false; &#125;&#125; 效率高的做法:12345678910111213141516public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int i = 0, j = matrix[0].length - 1; while (i &lt; matrix.length &amp;&amp; j &gt;= 0) &#123; if (matrix[i][j] == target) &#123; return true; &#125; else if (matrix[i][j] &gt; target) &#123; j--; &#125; else &#123; i++; &#125; &#125; return false; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"},{"name":"矩阵","slug":"矩阵","permalink":"http://londbell,github.io/tags/矩阵/"}]},{"title":"Roman to Integer","date":"2014-12-03T09:32:00.000Z","path":"2014/12/03/leetcode-13-Roman-to-Integer/","text":"题目描述给出一个罗马数字字符串，将其计算为阿拉伯数字。 Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 背景知识罗马数字是阿拉伯数字传入之前使用的一种数码。罗马数字采用七个罗马字母作数字、即Ⅰ（1）、X（10）、C（100）、M（1000）、V（5）、L（50）、D（500）。记数的方法： 1.相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3； 2.小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12； 3.小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9； 4.在一个数的上面画一条横线，表示这个数增值 1,000 倍，如=5000。 原题地址123456789101112131415161718192021222324252627public class Solution &#123; public int romanToInt(String s) &#123; Map map = new HashMap(); map.put('I', 1);//Key是Char就用单引号，是String就用双引号 map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int result = 0; for(int i = s.length() - 1; i &gt;= 0; --i) &#123; if(i == s.length() - 1) &#123; result = (Integer)map.get(s.charAt(i)); continue; &#125; if(((Integer)map.get(s.charAt(i))) &gt;= ((Integer)map.get(s.charAt(i + 1)))) &#123; result += (Integer) map.get(s.charAt(i)); &#125;else &#123; result -= (Integer) map.get(s.charAt(i)); &#125; &#125; return result; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"Add Two Numbers","date":"2014-07-03T02:11:00.000Z","path":"2014/07/03/leetcode-02-Add-Two-Numbers/","text":"题目描述给定两个由个位数组成的非空链表，按位置相加，进位累加到下一个元素上，每个元素只留个位，两个链表长度可能不等。 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 原题地址 我的做法：1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode temp = head; int count = 0; head.val = l1.val + l2.val; if(head.val &gt;= 10) &#123; count = 1; head.val %= 10; &#125; while(l1.next != null || l2.next !=null || count == 1) &#123; if(l1.next == null &amp;&amp; l2.next == null) &#123; temp.next = new ListNode(count); &#125; else if(l1.next == null) &#123; temp.next = new ListNode(l2.next.val + count); l2 = l2.next; &#125;else if(l2.next == null) &#123; temp.next = new ListNode(l1.next.val + count); l1 = l1.next; &#125;else if(l1.next != null &amp;&amp; l2.next != null) &#123; temp.next = new ListNode(l1.next.val + l2.next.val + count); l1 = l1.next; l2 = l2.next; &#125; if(temp.next.val &gt;= 10) &#123; count = 1; temp.next.val %= 10; &#125;else &#123; count = 0; &#125; temp = temp.next; &#125; return head; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"http://londbell,github.io/tags/链表/"}]},{"title":"Two Sum","date":"2014-07-01T13:52:00.000Z","path":"2014/07/01/leetcode-01-Two-Sum/","text":"题目描述给定一个整形元素组成的数组，给出一个数，求数组中是否存在两个数之和与给定数相等。不能使用同一个元素两次，同时一定只会有一个解。 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 原题地址 逗逼解法：12345678910111213141516171819202122232425262728293031323334353637package com.company;public class Main &#123; public static void main(String[] args) &#123; // write your code here int nums3[] = &#123;3, 2, 4&#125;; int target3 = 6; int nums4[] = &#123;2,7,11,15&#125;; int target4 = 9; int twoSum[] = Solution.twoSum(nums3, target3); System.out.print(twoSum[0] + \" \" + twoSum[1]); System.out.println(\" finish\"); &#125;&#125;class Solution &#123; public static int[] twoSum(int[] nums, int target) &#123; int flag = 0; int array[] = &#123;0,0&#125;; for(int i = 0; i &lt; nums.length; i++) &#123; if(flag == 1) &#123; break; &#125; for(int j = i + 1; j &lt; nums.length; j++) &#123; if((nums[i] + nums[j] == target)) &#123; array[0] = i; array[1] = j; flag = 1; break; &#125; &#125; &#125; return array; &#125;&#125; 改进方法1234567891011121314151617181920212223242526272829303132package com.company;public class Main &#123; public static void main(String[] args) &#123; // write your code here int nums3[] = &#123;3, 2, 4&#125;; int target3 = 6; int nums4[] = &#123;2,7,11,15&#125;; int target4 = 9; int twoSum[] = Solution.twoSum(nums3, target3); System.out.print(twoSum[0] + \" \" + twoSum[1]); System.out.println(\" finish\"); &#125;&#125;class Solution &#123; public static int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int result[] = new int[2]; for (int i = 0; i &lt; nums.length; i++)&#123; int num = target - nums[i]; if(map.containsKey(num))&#123; result[0] = map.get(num); result[1] = i; return result; &#125; map.put(nums[i], i); &#125; return result; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]}]