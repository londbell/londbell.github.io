[{"title":"Subsets","date":"2017-03-27T11:09:00.000Z","path":"2017/03/27/leetcode-78-Subsets/","text":"题目描述给出一个数组，每个元素均不同，给出所有他的子集 Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 原题地址12345678910111213141516class Solution &#123; public static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;(); int total = 2 &lt;&lt; (nums.length) - 1; for(int i = 0;i &lt; total; i ++) &#123; List&lt;Integer&gt; temp = new LinkedList&lt;&gt;(); for(int j = 0; j &lt; nums.length; j++) &#123; if((i &amp; (1 &lt;&lt; j)) != 0) &#123;//不能写==1，注意 temp.add(nums[j]); &#125; &#125; list.add(temp); &#125; return list; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"等价交换","date":"2017-03-26T16:34:00.000Z","path":"2017/03/27/diary-2017-0327-0034/","text":"人没有牺牲就什么都得不到，为了得到什么东西，就需要付出同等的代价。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://londbell,github.io/tags/随笔/"}]},{"title":"Roman to Integer","date":"2014-12-03T09:32:00.000Z","path":"2014/12/03/leetcode-13-Roman-to-Integer/","text":"题目描述给出一个罗马数字字符串，将其计算为阿拉伯数字。 Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 背景知识罗马数字是阿拉伯数字传入之前使用的一种数码。罗马数字采用七个罗马字母作数字、即Ⅰ（1）、X（10）、C（100）、M（1000）、V（5）、L（50）、D（500）。记数的方法： 1.相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3； 2.小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12； 3.小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9； 4.在一个数的上面画一条横线，表示这个数增值 1,000 倍，如=5000。 原题地址123456789101112131415161718192021222324252627public class Solution &#123; public int romanToInt(String s) &#123; Map map = new HashMap(); map.put('I', 1);//Key是Char就用单引号，是String就用双引号 map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int result = 0; for(int i = s.length() - 1; i &gt;= 0; --i) &#123; if(i == s.length() - 1) &#123; result = (Integer)map.get(s.charAt(i)); continue; &#125; if(((Integer)map.get(s.charAt(i))) &gt;= ((Integer)map.get(s.charAt(i + 1)))) &#123; result += (Integer) map.get(s.charAt(i)); &#125;else &#123; result -= (Integer) map.get(s.charAt(i)); &#125; &#125; return result; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]},{"title":"Two Sum","date":"2014-07-01T13:52:00.000Z","path":"2014/07/01/leetcode-01-Two-Sum/","text":"题目描述给定一个整形元素组成的数组，给出一个数，求数组中是否存在两个数之和与给定数相等。不能使用同一个元素两次，同时一定只会有一个解。 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 原题地址 逗逼解法：12345678910111213141516171819202122232425262728293031323334353637package com.company;public class Main &#123; public static void main(String[] args) &#123; // write your code here int nums3[] = &#123;3, 2, 4&#125;; int target3 = 6; int nums4[] = &#123;2,7,11,15&#125;; int target4 = 9; int twoSum[] = Solution.twoSum(nums3, target3); System.out.print(twoSum[0] + \" \" + twoSum[1]); System.out.println(\" finish\"); &#125;&#125;class Solution &#123; public static int[] twoSum(int[] nums, int target) &#123; int flag = 0; int array[] = &#123;0,0&#125;; for(int i = 0; i &lt; nums.length; i++) &#123; if(flag == 1) &#123; break; &#125; for(int j = i + 1; j &lt; nums.length; j++) &#123; if((nums[i] + nums[j] == target)) &#123; array[0] = i; array[1] = j; flag = 1; break; &#125; &#125; &#125; return array; &#125;&#125; 改进方法1234567891011121314151617181920212223242526272829303132package com.company;public class Main &#123; public static void main(String[] args) &#123; // write your code here int nums3[] = &#123;3, 2, 4&#125;; int target3 = 6; int nums4[] = &#123;2,7,11,15&#125;; int target4 = 9; int twoSum[] = Solution.twoSum(nums3, target3); System.out.print(twoSum[0] + \" \" + twoSum[1]); System.out.println(\" finish\"); &#125;&#125;class Solution &#123; public static int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int result[] = new int[2]; for (int i = 0; i &lt; nums.length; i++)&#123; int num = target - nums[i]; if(map.containsKey(num))&#123; result[0] = map.get(num); result[1] = i; return result; &#125; map.put(nums[i], i); &#125; return result; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://londbell,github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://londbell,github.io/tags/LeetCode/"}]}]